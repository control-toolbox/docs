var documenterSearchIndex = {"docs":
[{"location":"api-solution.html#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"api-solution.html","page":"Solution","title":"Solution","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-solution.html","page":"Solution","title":"Solution","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"solution.jl\"]\nPrivate = false","category":"page"},{"location":"api-solution.html#CTBase.OptimalControlSolution","page":"Solution","title":"CTBase.OptimalControlSolution","text":"mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution\n\nType of an optimal control solution.\n\nFields\n\nstate_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ntimes::Union{Nothing, StepRangeLen, AbstractVector{<:Real}}: Default: nothing\ntime_name::String: Default:\nstate::Union{Nothing, Function}: Default: nothing\nstate_names::Vector{String}: Default: Vector{String}()\nadjoint::Union{Nothing, Function}: Default: nothing\ncontrol::Union{Nothing, Function}: Default: nothing\ncontrol_names::Vector{String}: Default: Vector{String}()\nobjective::Union{Nothing, Real}: Default: nothing\niterations::Union{Nothing, Integer}: Default: nothing\nstopping::Union{Nothing, Symbol}: Default: nothing\nmessage::Union{Nothing, String}: Default: nothing\nsuccess::Union{Nothing, Bool}: Default: nothing\ninfos::Dict{Symbol, Any}: Default: Dict{Symbol, Any}()\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#Callbacks","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"api-callbacks.html","page":"Callbacks","title":"Callbacks","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-callbacks.html","page":"Callbacks","title":"Callbacks","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"callbacks.jl\"]\nPrivate = false","category":"page"},{"location":"api-callbacks.html#CTBase.CTCallback","page":"Callbacks","title":"CTBase.CTCallback","text":"abstract type CTCallback\n\nAbstract type for callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.CTCallbacks","page":"Callbacks","title":"CTBase.CTCallbacks","text":"Tuple of callbacks\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.PrintCallback","page":"Callbacks","title":"CTBase.PrintCallback","text":"mutable struct PrintCallback <: CTCallback\n\nCallback for printing.\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.PrintCallback-Tuple","page":"Callbacks","title":"CTBase.PrintCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-callbacks.html#CTBase.StopCallback","page":"Callbacks","title":"CTBase.StopCallback","text":"Stopping callback.\n\n\n\n\n\n","category":"type"},{"location":"api-callbacks.html#CTBase.StopCallback-Tuple","page":"Callbacks","title":"CTBase.StopCallback","text":"Call the callback.\n\n\n\n\n\n","category":"method"},{"location":"api-callbacks.html#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"Callbacks","title":"CTBase.get_priority_print_callbacks","text":"get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority print callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-callbacks.html#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","page":"Callbacks","title":"CTBase.get_priority_stop_callbacks","text":"get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n\n\nGet the highest priority stop callbacks.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#API-for-developers","page":"Developers","title":"API for developers","text":"","category":"section"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"Here is the doc of private functions and types.","category":"page"},{"location":"api-developers.html","page":"Developers","title":"Developers","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"api-developers.html#CTBase.DescVarArg","page":"Developers","title":"CTBase.DescVarArg","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"constant"},{"location":"api-developers.html#CTBase.AbstractCTFunction","page":"Developers","title":"CTBase.AbstractCTFunction","text":"abstract type AbstractCTFunction <: Function\n\nAbstract type for functions.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractOptimalControlModel","page":"Developers","title":"CTBase.AbstractOptimalControlModel","text":"abstract type AbstractOptimalControlModel\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractOptimalControlSolution","page":"Developers","title":"CTBase.AbstractOptimalControlSolution","text":"abstract type AbstractOptimalControlSolution\n\nAbstract type for optimal control solutions.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.AbstractPlotNode","page":"Developers","title":"CTBase.AbstractPlotNode","text":"abstract type AbstractPlotNode\n\nAbstract node for plot.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.Control","page":"Developers","title":"CTBase.Control","text":"Type alias for a control.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PlotLeaf","page":"Developers","title":"CTBase.PlotLeaf","text":"struct PlotLeaf <: CTBase.AbstractPlotNode\n\nA leaf of a plot tree.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PlotNode","page":"Developers","title":"CTBase.PlotNode","text":"struct PlotNode <: CTBase.AbstractPlotNode\n\nA node of a plot tree.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.PrintCallbacks","page":"Developers","title":"CTBase.PrintCallbacks","text":"Tuple of print callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.StopCallbacks","page":"Developers","title":"CTBase.StopCallbacks","text":"Tuple of stop callbacks.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#CTBase.SymbolPlot","page":"Developers","title":"CTBase.SymbolPlot","text":"struct Tuple{Symbol, Integer}\n\nType alias for a plot element.\n\n\n\n\n\n","category":"type"},{"location":"api-developers.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlSolution}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::OptimalControlSolution\n)\n\n\nPrints the solution.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n\n\nPrint a tuple of descriptions.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.show-Union{Tuple{dimension_usage}, Tuple{time_dependence}, Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlModel{time_dependence, dimension_usage}}} where {time_dependence, dimension_usage}","page":"Developers","title":"Base.show","text":"show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::OptimalControlModel{time_dependence, dimension_usage}\n)\n\n\nPrint the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, AmbiguousDescription}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::AmbiguousDescription)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, InconsistentArgument}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::InconsistentArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectArgument}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectArgument)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectMethod}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectMethod)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, IncorrectOutput}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::IncorrectOutput)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#Base.showerror-Tuple{IO, NotImplemented}","page":"Developers","title":"Base.showerror","text":"showerror(io::IO, e::NotImplemented)\n\n\nPrint the exception.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__callbacks-Tuple{}","page":"Developers","title":"CTBase.__callbacks","text":"__callbacks() -> Tuple{}\n\n\nUsed to set the default value of the callbacks argument. The default value is (), which means that no additional callback is given.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__constraint_label-Tuple{}","page":"Developers","title":"CTBase.__constraint_label","text":"__constraint_label() -> Symbol\n\n\nUsed to set the default value of the label of a constraint. A unique value is given to each constraint using the gensym function and prefixing by :unamed.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__control_names-Tuple{Integer}","page":"Developers","title":"CTBase.__control_names","text":"__control_names(m::Integer) -> Any\n\n\nUsed to set the default value of the names of the controls. The default value is [\"u\"] for a one dimensional control, and [\"u₁\", \"u₂\", ...] for a multi dimensional control.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__criterion_type-Tuple{}","page":"Developers","title":"CTBase.__criterion_type","text":"__criterion_type() -> Symbol\n\n\nUsed to set the default value of the type of criterion. Either :min or :max. The default value is :min. The other possible criterion type is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__display-Tuple{}","page":"Developers","title":"CTBase.__display","text":"__display() -> Bool\n\n\nUsed to set the default value of the display argument. The default value is true, which means that the output is printed during resolution.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__fun_dimension_usage-Tuple{}","page":"Developers","title":"CTBase.__fun_dimension_usage","text":"__fun_dimension_usage() -> Symbol\n\n\nUsed to set the default value of the dimension usage of the functions.\n\nThe default value is :scalar, which means that the usage of the functions is considered scalar. The other possible usage is :vectorial.\n\nExample\n\nIf x is for instance a vector of dimension 2 and u a scalar, then the following usage  is considered scalar:\n\nf(x, u) = x[1] + u\n\nIf x and u are for instance both scalar, then the following usage is considered scalar:\n\nf(x, u) = x + u\n\nIf x is for instance a vector of dimension 2 and u a vector of dimension 3, then the following usage is also considered scalar:\n\nf(x, u) = x[1] + u[1]\n\nA vectorial usage is the following. For instance, if x is a vector of dimension 2 and u a scalar,  then the following usage is considered vectorial:\n\nf(x, u) = x[1] + u[1]\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__fun_time_dependence-Tuple{}","page":"Developers","title":"CTBase.__fun_time_dependence","text":"__fun_time_dependence() -> Symbol\n\n\nUsed to set the default value of the time dependence of the functions.\n\nThe default value is :autonomous, which means that the functions are considered time independent. The other possible time dependence is :nonautonomous, which means that the functions are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__init_interpolation-Tuple{}","page":"Developers","title":"CTBase.__init_interpolation","text":"__init_interpolation() -> CTBase.var\"#45#46\"\n\n\nUsed to set the default interpolation function used for initialisation. The default value is Interpolations.linear_interpolation, which means that the initial guess is linearly interpolated.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__matrix_dimension_stock-Tuple{}","page":"Developers","title":"CTBase.__matrix_dimension_stock","text":"__matrix_dimension_stock() -> Int64\n\n\nUsed to set the default value of the stockage of elements in a matrix. The default value is 1.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__mu_strategy_ipopt-Tuple{}","page":"Developers","title":"CTBase.__mu_strategy_ipopt","text":"__mu_strategy_ipopt() -> String\n\n\nUsed to set the default value of the μ strategy of ipopt for the direct method. The default value is adaptive.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__ocp_dimension_usage-Tuple{}","page":"Developers","title":"CTBase.__ocp_dimension_usage","text":"__ocp_dimension_usage() -> Symbol\n\n\nUsed to set the default value of the dimension usage of the Optimal Control Problem. The default value is :scalar, which means that the usage for all the functions used to define the Optimal Control Problem is considered scalar.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__ocp_time_dependence-Tuple{}","page":"Developers","title":"CTBase.__ocp_time_dependence","text":"__ocp_time_dependence() -> Symbol\n\n\nUsed to set the default value of the time dependence of the Optimal Control Problem. The default value is :autonomous, which means that the Optimal Control Problem is considered time independent. The other possible time dependence is :nonautonomous, which means that all the functions used to define the  Optimal Control Problem are considered time dependent.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__print_level_ipopt-Tuple{}","page":"Developers","title":"CTBase.__print_level_ipopt","text":"__print_level_ipopt() -> Int64\n\n\nUsed to set the default value of the print level of ipopt for the direct method. The default value is 5.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__state_names-Tuple{Integer}","page":"Developers","title":"CTBase.__state_names","text":"__state_names(n::Integer) -> Any\n\n\nUsed to set the default value of the names of the states. The default value is [\"x\"] for a one dimensional state, and [\"x₁\", \"x₂\", ...] for a multi dimensional state.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.__time_name-Tuple{}","page":"Developers","title":"CTBase.__time_name","text":"__time_name() -> String\n\n\nUsed to set the default value of the name of the time. The default value is t.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase._plot_time!-Tuple{Any, OptimalControlSolution, Symbol, Integer}","page":"Developers","title":"CTBase._plot_time!","text":"_plot_time!(\n    p,\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n\n\nUpdate the plot p with the i-th component of a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase._plot_time-Tuple{OptimalControlSolution, Integer, Symbol}","page":"Developers","title":"CTBase._plot_time","text":"_plot_time(\n    sol::OptimalControlSolution,\n    d::Integer,\n    s::Symbol;\n    t_label,\n    labels,\n    title,\n    kwargs...\n)\n\n\nPlot a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase._plot_time-Tuple{OptimalControlSolution, Symbol, Integer}","page":"Developers","title":"CTBase._plot_time","text":"_plot_time(\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n\n\nPlot the i-th component of a vectorial function of time f(t) ∈ Rᵈ where f is given by the symbol s. The argument s can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.constraint_type-NTuple{6, Any}","page":"Developers","title":"CTBase.constraint_type","text":"constraint_type(e, t, t0, tf, x, u)\n\n\nReturn the type constraint among  :initial, :final, :boundary, :control_range, :control_fun, :state_range, :state_fun, :mixed (:other otherwise), together with the appropriate value (range or updated expression).\n\nExample\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u)\n(:boundary, :(2 * var\"x#0\"[1] ^ 2))\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u)\n(:boundary, :(2 * var\"x#f\"[1] ^ 2))\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u)\n(:boundary, :(var\"x#f\"[1] - var\"x#0\"[2]))\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u)\n(:control_range, Index(1))\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u)\n(:control_fun, :(2 * u[1] ^ 2))\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u)\n(:state_range, Index(1))\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u)\n(:state_fun, :(2 * x[1] ^ 2))\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u)\n(:mixed, :((2 * u[1] ^ 2) * x))\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u)\n:other\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.ctindice-Tuple{Integer}","page":"Developers","title":"CTBase.ctindice","text":"ctindice(i::Integer) -> Char\n\n\nReturns i ∈ [0, 9] as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.ctupperscript-Tuple{Integer}","page":"Developers","title":"CTBase.ctupperscript","text":"ctupperscript(i::Integer) -> Char\n\n\nReturns i ∈ [0, 9] as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Matrix{<:Real}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Matrix{<:Real}) -> Vector{<:Real}\n\n\nReturns expand(matrix2vec(x, 1))\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Vector{<:Real}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Vector{<:Real}) -> Vector{<:Real}\n\n\nReturns x.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expand-Tuple{Vector{<:Vector{<:Real}}}","page":"Developers","title":"CTBase.expand","text":"expand(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nEquivalent to vec2vec(x)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.expr_it-Tuple{Any, Any, Any}","page":"Developers","title":"CTBase.expr_it","text":"expr_it(e, _Expr, f)\n\n\nExpr iterator: apply _Expr to nodes and f to leaves of the AST.\n\nExample\n\njulia> id(e) = expr_it(e, Expr, x -> x)\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.get-Tuple{OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}}","page":"Developers","title":"CTBase.get","text":"get(\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Any\n\n\nGet the data for plotting.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.has-Tuple{Any, Any, Any}","page":"Developers","title":"CTBase.has","text":"has(e, x, t)\n\n\nReturn true if e contains an x(t), x[i](t) or x[i:j](t) call.\n\nExample\n\njulia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.matrix2vec","page":"Developers","title":"CTBase.matrix2vec","text":"matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:MyNumber}}.\n\nNote. dim ∈ {1, 2} is the dimension along which the matrix is transformed.\n\n\n\n\n\n","category":"function"},{"location":"api-developers.html#CTBase.replace_call-NTuple{4, Any}","page":"Developers","title":"CTBase.replace_call","text":"replace_call(e, x, t, y)\n\n\nReplace calls in e such as x(t), x[i](t) or x[i:j](t) by y, y[i](t) or y[i:j](t), resp.\n\nExample\n\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.subs-Tuple{Any, Union{Real, Symbol}, Any}","page":"Developers","title":"CTBase.subs","text":"subs(e, e1, e2)\n\n\nSubstitute expression e1 by expression e2 in expression e.\n\nExamples\n\njulia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.vec2vec-Tuple{Vector{<:Real}, Integer}","page":"Developers","title":"CTBase.vec2vec","text":"vec2vec(\n    x::Vector{<:Real},\n    n::Integer\n) -> Vector{<:Vector{<:Real}}\n\n\nTransforms x to a Vector{<:Vector{<:MyNumber}}.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.vec2vec-Tuple{Vector{<:Vector{<:Real}}}","page":"Developers","title":"CTBase.vec2vec","text":"vec2vec(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n\n\nTransforms x to a Vector{<:MyNumber}.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}, Union{Symbol, Tuple{Symbol, Integer}}}","page":"Developers","title":"RecipesBase.apply_recipe","text":"apply_recipe(\n    plotattributes::AbstractDict{Symbol, Any},\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}},\n    yy::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Vector{RecipesBase.RecipeData}\n\n\nReturns x and y for the plot of the optimal control solution sol  corresponding respectively to the argument xx and the argument yy.\n\nNotes.\n\nThe argument xx can be :time, :state, :control or :adjoint.\nIf xx is :time, then, a label is added to the plot.\nThe argument yy can be :state, :control or :adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-developers.html#CTBase.@ctfunction_sv-Tuple{Any}","page":"Developers","title":"CTBase.@ctfunction_sv","text":"Generate callable types, that is functions, handling the dimension usage.\n\nNote: This macro is used to generate callable types for functions that are not time dependent. If the function is time dependent, use the macro @ctfunction_td_sv instead.\n\n\n\n\n\n","category":"macro"},{"location":"api-developers.html#CTBase.@ctfunction_td_sv-Tuple{Any}","page":"Developers","title":"CTBase.@ctfunction_td_sv","text":"Generate callable types, that is functions, handling the time dependence and the dimension usages.\n\n\n\n\n\n","category":"macro"},{"location":"api-ctbase.html#CTBase.jl","page":"CTBase.jl","title":"CTBase.jl","text":"","category":"section"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-ctbase.html","page":"CTBase.jl","title":"CTBase.jl","text":"Modules = [CTBase, Base]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"CTBase.jl\"]\nPrivate = false","category":"page"},{"location":"api-ctbase.html#CTBase.CTBase","page":"CTBase.jl","title":"CTBase.CTBase","text":"CTBase module.\n\nLists all the imported modules and packages:\n\nBase\nCore\nDocStringExtensions\nMLStyle\nParameters\nPlots\nPrintf\nReexport\n\nList of all the exported names:\n\nAd\nAdjoint\nAdjoints\nAmbiguousDescription\nBoundaryConstraintFunction\nCTCallback\nCTCallbacks\nCTException\nControlConstraintFunction\nControlFunction\nControls\nDescription\nDimension\nDynamicsFunction\nHamiltonian\nHamiltonianVectorField\nInconsistentArgument\nIncorrectArgument\nIncorrectMethod\nIncorrectOutput\nIndex\nLagrangeFunction\nMayerFunction\nMixedConstraintFunction\nModel\nMultiplierFunction\nMyNumber\nMyVector\nNotImplemented\nOptimalControlModel\nOptimalControlSolution\nPoisson\nPrintCallback\nState\nStateConstraintFunction\nStates\nStopCallback\nTime\nTimes\nTimesDisc\nVectorField\n\\\nadd\nconstraint\nconstraint!\nconstraints_labels\ncontrol!\nctgradient\nctindices\nctinterpolate\nctjacobian\nctupperscripts\ngetFullDescription\nget_priority_print_callbacks\nget_priority_stop_callbacks\nisautonomous\nismax\nismin\nisnonautonomous\nmakeDescription\nnlp_constraints\nobjective!\nplot\nremove_constraint!\nstate!\ntime!\n\n\n\n\n\n","category":"module"},{"location":"api-ctbase.html#CTBase.TimesDisc","page":"CTBase.jl","title":"CTBase.TimesDisc","text":"Type alias for a grid of times.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Adjoint","page":"CTBase.jl","title":"CTBase.Adjoint","text":"Type alias for an adjoint.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Adjoints","page":"CTBase.jl","title":"CTBase.Adjoints","text":"Type alias for a vector of adjoints.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Controls","page":"CTBase.jl","title":"CTBase.Controls","text":"Type alias for a vector of controls.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Dimension","page":"CTBase.jl","title":"CTBase.Dimension","text":"Type alias for a dimension.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.MyNumber","page":"CTBase.jl","title":"CTBase.MyNumber","text":"Type alias for a real number.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.MyVector","page":"CTBase.jl","title":"CTBase.MyVector","text":"Type alias for a vector of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.State","page":"CTBase.jl","title":"CTBase.State","text":"Type alias for a state.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.States","page":"CTBase.jl","title":"CTBase.States","text":"Type alias for a vector of states.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Time","page":"CTBase.jl","title":"CTBase.Time","text":"Type alias for a time.\n\n\n\n\n\n","category":"type"},{"location":"api-ctbase.html#CTBase.Times","page":"CTBase.jl","title":"CTBase.Times","text":"Type alias for a vector of times.\n\n\n\n\n\n","category":"type"},{"location":"api-parser.html#Parser","page":"Parser","title":"Parser","text":"","category":"section"},{"location":"api-parser.html","page":"Parser","title":"Parser","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-parser.html","page":"Parser","title":"Parser","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"ctparser_utils.jl\", \"ctparser.jl\"]\nPrivate = false","category":"page"},{"location":"api-print.html#Print","page":"Print","title":"Print","text":"","category":"section"},{"location":"api-print.html","page":"Print","title":"Print","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"print.jl\"]\nPrivate = false","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"An optimal control problem can be described as minimising the cost functional","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"g(t_0 x(t_0) t_f x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"where the state x and the control u are functions subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"and other constraints such as","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"beginarrayllcll\nxi_l  le xi(t u(t))        le xi_u \neta_l le eta(t x(t))       le eta_u \npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(t_0 x(t_0) t_f x(t_f)) le phi_u\nendarray","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Let us define the following optimal control problem.","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"using CTBase\n\nocp = Model()\n\nstate!(ocp, 2, [\"r\", \"v\"]) # dimension of the state with the names of the components\ncontrol!(ocp, 1)           # dimension of the control\ntime!(ocp, [0, 1], \"s\")    # initial and final time, with the name of the variable time\n\nconstraint!(ocp, :initial, [-1, 0])\nconstraint!(ocp, :final  , [ 0, 0])\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\nconstraint!(ocp, :dynamics, (x, u) -> A*x + B*u)\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2)\nnothing # hide","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"Then, we can print the form of this optimal control problem:","category":"page"},{"location":"api-print.html","page":"Print","title":"Print","text":"ocp","category":"page"},{"location":"api-plot.html#Plot","page":"Plot","title":"Plot","text":"","category":"section"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"plot.jl\"]\nPrivate = false","category":"page"},{"location":"api-plot.html#RecipesBase.plot-Tuple{OptimalControlSolution}","page":"Plot","title":"RecipesBase.plot","text":"plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    adjoint_style,\n    kwargs...\n) -> Any\n\n\nPlot the optimal control solution sol using the layout layout. The argument layout can be :group or :split (default).\n\nnote: Note\nThe keyword arguments state_style, control_style and adjoint_style are passed to the plot function of the Plots package. The state_style is passed to the plot of the state, the control_style is passed to the plot of the control and the adjoint_style is passed to the plot of the adjoint.\n\n\n\n\n\n","category":"method"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"using CTBase\n\n# create a solution\nn=2\nm=1\nt0=0.0\ntf=1.0\nx0=[-1.0, 0.0]\nxf=[0.0, 0.0]\na = x0[1]\nb = x0[2]\nC = [-(tf-t0)^3/6.0 (tf-t0)^2/2.0\n     -(tf-t0)^2/2.0 (tf-t0)]\nD = [-a-b*(tf-t0), -b]+xf\np0 = C\\D\nα = p0[1]\nβ = p0[2]\nx(t) = [a+b*(t-t0)+β*(t-t0)^2/2.0-α*(t-t0)^3/6.0, b+β*(t-t0)-α*(t-t0)^2/2.0]\np(t) = [α, -α*(t-t0)+β]\nu(t) = [p(t)[2]]\nobjective = 0.5*(α^2*(tf-t0)^3/3+β^2*(tf-t0)-α*β*(tf-t0)^2)\n#\nN=201\ntimes = range(t0, tf, N)\n#\n\nsol = OptimalControlSolution()\nsol.state_dimension = n\nsol.control_dimension = m\nsol.times = times\nsol.time_name=\"t\"\nsol.state = x\nsol.state_names = [ \"x\" * ctindices(i) for i ∈ range(1, n)]\nsol.adjoint = p\nsol.control = u\nsol.control_names = [ \"u\" ]\nsol.objective = objective\nsol.iterations = 0\nsol.stopping = :dummy\nsol.message = \"ceci est un test\"\nsol.success = true","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Let us consider we have defined an optimal control problem","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"ocp = Model()\n...","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"and solve it","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"sol = solve(ocp)","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"We can plot the solution with the default layout :split.","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, layout=:split, size=(800, 600))","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"Or with the layout :group.","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, layout=:group, size=(800, 300))","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"You can specify some styles:","category":"page"},{"location":"api-plot.html","page":"Plot","title":"Plot","text":"plot(sol, \n    state_style=(color=:blue,), \n    adjoint_style=(color=:black, linestyle=:dash),\n    control_style=(color=:red, linewidth=2),\n    size=(800, 600))","category":"page"},{"location":"api-description.html#Description","page":"Description","title":"Description","text":"","category":"section"},{"location":"api-description.html","page":"Description","title":"Description","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-description.html","page":"Description","title":"Description","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"description.jl\"]\nPrivate = false","category":"page"},{"location":"api-description.html#CTBase.Description","page":"Description","title":"CTBase.Description","text":"A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}.\n\n\n\n\n\n","category":"type"},{"location":"api-description.html#Base.:\\-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"Base.:\\","text":"\\(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturns the difference between the description x and the description y.\n\nExample\n\njulia> (:a, :b) \\ (:a,)\n(:b,)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nConcatenate the description y at the tuple of descriptions x if it is not already in the tuple x.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.add","text":"add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturns a tuple containing only the description y.\n\nExample\n\njulia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","page":"Description","title":"CTBase.getFullDescription","text":"getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturns a complete description from an incomplete description desc and  a list of complete descriptions desc_list. If several complete descriptions are possible,  then the first one is returned.\n\nExample\n\njulia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.makeDescription-Tuple{Tuple{Vararg{Symbol}}}","page":"Description","title":"CTBase.makeDescription","text":"makeDescription(\n    desc::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n\n\nReturns the description.\n\nExample\n\njulia> makeDescription((:a, :b))\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-description.html#CTBase.makeDescription-Tuple{Vararg{Symbol}}","page":"Description","title":"CTBase.makeDescription","text":"makeDescription(desc::Symbol...) -> Tuple{Vararg{Symbol}}\n\n\nCreate a description from a tuple of symbols.\n\nExample\n\njulia> makeDescription(:a, :b)\n(:a, :b)\n\n\n\n\n\n","category":"method"},{"location":"api-functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"api-functions.html","page":"Functions","title":"Functions","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-functions.html","page":"Functions","title":"Functions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"functions.jl\"]\nPrivate = false","category":"page"},{"location":"api-functions.html#CTBase.BoundaryConstraintFunction","page":"Functions","title":"CTBase.BoundaryConstraintFunction","text":"struct BoundaryConstraintFunction{dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nBoundaryConstraintFunction{dimension_usage}(f::Function) where {dimension_usage}\nBoundaryConstraintFunction(f::Function)\n\nwarning: Warning\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.ControlConstraintFunction","page":"Functions","title":"CTBase.ControlConstraintFunction","text":"struct ControlConstraintFunction{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nControlConstraintFunction{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nControlConstraintFunction{time_dependence}(f::Function) where {time_dependence}\nControlConstraintFunction(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.ControlFunction","page":"Functions","title":"CTBase.ControlFunction","text":"struct ControlFunction{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nControlFunction{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nControlFunction{time_dependence}(f::Function) where {time_dependence}\nControlFunction(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.DynamicsFunction","page":"Functions","title":"CTBase.DynamicsFunction","text":"struct DynamicsFunction{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nDynamicsFunction{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nDynamicsFunction{time_dependence}(f::Function) where {time_dependence}\nDynamicsFunction(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.Hamiltonian","page":"Functions","title":"CTBase.Hamiltonian","text":"struct Hamiltonian{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nHamiltonian{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nHamiltonian{time_dependence}(f::Function) where {time_dependence}\nHamiltonian(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.HamiltonianVectorField","page":"Functions","title":"CTBase.HamiltonianVectorField","text":"struct HamiltonianVectorField{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nHamiltonianVectorField{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nHamiltonianVectorField{time_dependence}(f::Function) where {time_dependence}\nHamiltonianVectorField(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.LagrangeFunction","page":"Functions","title":"CTBase.LagrangeFunction","text":"struct LagrangeFunction{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nLagrangeFunction{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nLagrangeFunction{time_dependence}(f::Function) where {time_dependence}\nLagrangeFunction(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.MayerFunction","page":"Functions","title":"CTBase.MayerFunction","text":"struct MayerFunction{dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nMayerFunction{dimension_usage}(f::Function) where {dimension_usage}\nMayerFunction(f::Function)\n\nwarning: Warning\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.MixedConstraintFunction","page":"Functions","title":"CTBase.MixedConstraintFunction","text":"struct MixedConstraintFunction{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nMixedConstraintFunction{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nMixedConstraintFunction{time_dependence}(f::Function) where {time_dependence}\nMixedConstraintFunction(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.MultiplierFunction","page":"Functions","title":"CTBase.MultiplierFunction","text":"struct MultiplierFunction{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nMultiplierFunction{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nMultiplierFunction{time_dependence}(f::Function) where {time_dependence}\nMultiplierFunction(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.StateConstraintFunction","page":"Functions","title":"CTBase.StateConstraintFunction","text":"struct StateConstraintFunction{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nStateConstraintFunction{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nStateConstraintFunction{time_dependence}(f::Function) where {time_dependence}\nStateConstraintFunction(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-functions.html#CTBase.VectorField","page":"Functions","title":"CTBase.VectorField","text":"struct VectorField{time_dependence, dimension_usage} <: CTBase.AbstractCTFunction\n\nFields\n\nf::Function\n\nConstructors\n\nVectorField{time_dependence, dimension_usage}(f::Function) where {time_dependence, dimension_usage}\nVectorField{time_dependence}(f::Function) where {time_dependence}\nVectorField(f::Function)\n\nwarning: Warning\nThe parameter time_dependence can be :autonomous or :nonautonomous.\nThe parameter dimension_usage can be :scalar or :vectorial.\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#Exceptions","page":"Exceptions","title":"Exceptions","text":"","category":"section"},{"location":"api-exceptions.html","page":"Exceptions","title":"Exceptions","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-exceptions.html","page":"Exceptions","title":"Exceptions","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"exceptions.jl\"]\nPrivate = false","category":"page"},{"location":"api-exceptions.html#CTBase.AmbiguousDescription","page":"Exceptions","title":"CTBase.AmbiguousDescription","text":"struct AmbiguousDescription <: CTException\n\nException thrown when the description is ambiguous / incorrect.\n\nFields\n\nvar::Tuple{Vararg{Symbol}}\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.CTException","page":"Exceptions","title":"CTBase.CTException","text":"abstract type CTException <: Exception\n\nAbstract type for exceptions.\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.InconsistentArgument","page":"Exceptions","title":"CTBase.InconsistentArgument","text":"struct InconsistentArgument <: CTException\n\nException thrown when an argument is inconsistent.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.IncorrectArgument","page":"Exceptions","title":"CTBase.IncorrectArgument","text":"struct IncorrectArgument <: CTException\n\nException thrown when an argument is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.IncorrectMethod","page":"Exceptions","title":"CTBase.IncorrectMethod","text":"struct IncorrectMethod <: CTException\n\nException thrown when a method is incorrect.\n\nFields\n\nvar::Symbol\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.IncorrectOutput","page":"Exceptions","title":"CTBase.IncorrectOutput","text":"struct IncorrectOutput <: CTException\n\nException thrown when the output is incorrect.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-exceptions.html#CTBase.NotImplemented","page":"Exceptions","title":"CTBase.NotImplemented","text":"struct NotImplemented <: CTException\n\nException thrown when a method is not implemented.\n\nFields\n\nvar::String\n\n\n\n\n\n","category":"type"},{"location":"api-model.html#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api-model.html","page":"Model","title":"Model","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-model.html","page":"Model","title":"Model","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"model.jl\"]\nPrivate = false","category":"page"},{"location":"api-model.html#CTBase.Index","page":"Model","title":"CTBase.Index","text":"mutable struct Index\n\nFields\n\nval::Integer\n\n\n\n\n\n","category":"type"},{"location":"api-model.html#CTBase.OptimalControlModel","page":"Model","title":"CTBase.OptimalControlModel","text":"mutable struct OptimalControlModel{time_dependence, dimension_usage} <: CTBase.AbstractOptimalControlModel\n\nFields\n\ninitial_time::Union{Nothing, Real}: Default: nothing\nfinal_time::Union{Nothing, Real}: Default: nothing\ntime_name::Union{Nothing, String}: Default: nothing\nlagrange::Union{Nothing, LagrangeFunction{time_dependence, dimension_usage}} where {time_dependence, dimension_usage}: Default: nothing\nmayer::Union{Nothing, MayerFunction{dimension_usage}} where dimension_usage: Default: nothing\ncriterion::Union{Nothing, Symbol}: Default: nothing\ndynamics::Union{Nothing, DynamicsFunction{time_dependence, dimension_usage}} where {time_dependence, dimension_usage}: Default: nothing\ndynamics!::Union{Nothing, Function}: Default: nothing\nstate_dimension::Union{Nothing, Integer}: Default: nothing\nstate_names::Union{Nothing, Vector{String}}: Default: nothing\ncontrol_dimension::Union{Nothing, Integer}: Default: nothing\ncontrol_names::Union{Nothing, Vector{String}}: Default: nothing\nconstraints::Dict{Symbol, Tuple}: Default: Dict{Symbol, Tuple{Vararg{Any}}}()\n\n\n\n\n\n","category":"type"},{"location":"api-model.html#CTBase.Model-Tuple{}","page":"Model","title":"CTBase.Model","text":"Model(\n;\n    time_dependence,\n    dimension_usage\n) -> OptimalControlModel{:autonomous, :scalar}\n\n\nReturns a new OptimalControlModel instance, that is a model of an optimal control problem.\n\nThe model is defined by the following arguments:\n\ntime_dependence: either :autonomous or :nonautonomous. Default is :autonomous.\ndimension_usage: either :scalar or :vectorial. Default is :scalar.\n\nExamples\n\njulia> ocp = Model()\njulia> ocp = Model(time_dependence=:nonautonomous)\njulia> ocp = Model(dimension_usage=:vectorial)\njulia> ocp = Model(time_dependence=:nonautonomous, dimension_usage=:vectorial)\n\nnote: Note\nIf the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control.\nIf the dimension usage of the model is defined as vectorial, then, one dimensional state and / or control variables are considered as vectors. If the model is defined as scalar, then, one dimensional state and / or control variables are considered as scalars.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint!","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\n\n\nAdd a :boundary, :control, :state or :mixed value functional constraint.\n\nExamples\n\njulia> constraint!(ocp, :boundary, f, [ 0, 0 ])\njulia> constraint!(ocp, :control, f, [ 0, 0 ])\njulia> constraint!(ocp, :state, f, [ 0, 0 ])\njulia> constraint!(ocp, :mixed, f, [ 0, 0 ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-2","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb,\n    ub\n) -> Tuple{Symbol, Symbol, CTBase.var\"#59#60\", Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb,\n    ub,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, CTBase.var\"#61#62\", Any, Any}\n\n\nAdd an :initial, :final, :control or :state box constraint (whole range).\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-3","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, UnitRange{<:Integer}},\n    val\n) -> Tuple{Symbol, Symbol, CTBase.var\"#61#62\", Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, UnitRange{<:Integer}},\n    val,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, CTBase.var\"#61#62\", Any, Any}\n\n\nAdd an :initial or :final value constraint on a range of the state.\n\nExamples\n\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(1), 0)\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-4","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val\n) -> Any\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, CTBase.var\"#59#60\", Any, Any}\n\n\nAdd an :initial or :final value constraint on the state.\n\nExamples\n\njulia> constraint!(ocp, :initial, [ 0, 0, 0 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-5","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, UnitRange{<:Integer}},\n    lb,\n    ub\n) -> Tuple{Symbol, Symbol, CTBase.var\"#61#62\", Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, UnitRange{<:Integer}},\n    lb,\n    ub,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, Any, Any, Any}\n\n\nAdd an :initial, :final, :control or :state box constraint on a range.\n\nExamples\n\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [1, 2])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [1, 2])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-6","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    lb,\n    ub\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    lb,\n    ub,\n    label::Symbol\n) -> Tuple{Symbol, Symbol, Function, Any, Any}\n\n\nAdd a :boundary, :control, :state or :mixed box functional constraint.\n\nExamples\n\njulia> constraint!(ocp, :boundary, f, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :control, f, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :state, f, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :mixed, f, [ 0, 0 ], [ 1, 2 ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.constraint!-Union{Tuple{dimension_usage}, Tuple{time_dependence}, Tuple{OptimalControlModel{time_dependence, dimension_usage}, Symbol, Function}} where {time_dependence, dimension_usage}","page":"Model","title":"CTBase.constraint!","text":"constraint!(\n    ocp::OptimalControlModel{time_dependence, dimension_usage},\n    type::Symbol,\n    f::Function\n) -> Any\n\n\nProvide dynamics (possibly in place).\n\nExamples\n\njulia> constraint!(ocp, :dynamics, f)\njulia> constraint!(ocp, :dynamics!, f!)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraint-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.constraint","text":"constraint(\n    ocp::OptimalControlModel,\n    label::Symbol\n) -> Function\n\n\nRetrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds).\n\nExamples\n\njulia> constraint(ocp, :eq)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.constraints_labels-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.constraints_labels","text":"constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n\n\nReturns the labels of the constraints as a Base.keys.\n\nExamples\n\njulia> constraints_labels(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.control!","page":"Model","title":"CTBase.control!","text":"control!(\n    ocp::OptimalControlModel,\n    m::Integer\n) -> Union{Vector{Vector{String}}, Vector{String}, String}\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    names::Union{String, Vector{String}}\n) -> Union{Vector{Vector{String}}, Vector{String}, String}\n\n\nDefine the control dimension and possibly the names of each coordinate.\n\nExamples\n\njulia> control!(ocp, 1, \"v\")\njulia> control!(ocp, 2, [ \"u₁\", \"u₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.isautonomous-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.isautonomous","text":"isautonomous(ocp::OptimalControlModel) -> Bool\n\n\nReturns true if the model has been defined as autonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.isautonomous-Tuple{Symbol}","page":"Model","title":"CTBase.isautonomous","text":"isautonomous(time_dependence::Symbol) -> Bool\n\n\nReturns !isnonautonomous(time_dependence)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.ismax-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.ismax","text":"ismax(ocp::OptimalControlModel) -> Bool\n\n\nReturns true if the criterion type of ocp is :max.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.ismin-Tuple{OptimalControlModel}","page":"Model","title":"CTBase.ismin","text":"ismin(ocp::OptimalControlModel) -> Bool\n\n\nReturns true if the criterion type of ocp is :min.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.isnonautonomous-Tuple{Symbol}","page":"Model","title":"CTBase.isnonautonomous","text":"isnonautonomous(time_dependence::Symbol) -> Bool\n\n\nReturns :nonautonomous == time_dependence\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.isnonautonomous-Union{Tuple{OptimalControlModel{time_dependence, dimension_usage}}, Tuple{dimension_usage}, Tuple{time_dependence}} where {time_dependence, dimension_usage}","page":"Model","title":"CTBase.isnonautonomous","text":"isnonautonomous(\n    ocp::OptimalControlModel{time_dependence, dimension_usage}\n) -> Bool\n\n\nReturns true if the model has been defined as nonautonomous.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.nlp_constraints-Union{Tuple{OptimalControlModel{time_dependence, dimension_usage}}, Tuple{dimension_usage}, Tuple{time_dependence}} where {time_dependence, dimension_usage}","page":"Model","title":"CTBase.nlp_constraints","text":"nlp_constraints(\n    ocp::OptimalControlModel{time_dependence, dimension_usage}\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#77\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#78\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#79\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#80\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n\n\nReturn a 6-tuple of tuples:\n\n(ξl, ξ, ξu) are control constraints\n(ηl, η, ηu) are state constraints\n(ψl, ψ, ψu) are mixed constraints\n(ϕl, ϕ, ϕu) are boundary constraints\n(ulb, uind, uub) are control linear constraints of a subset of indices\n(xlb, xind, xub) are state linear constraints of a subset of indices\n\nExamples\n\njulia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), \n    (ulb, uind, uub), (xlb, xind, xub) = nlp_constraints(ocp)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.objective!-Union{Tuple{dimension_usage}, Tuple{time_dependence}, Tuple{OptimalControlModel{time_dependence, dimension_usage}, Symbol, Function, Function}, Tuple{OptimalControlModel{time_dependence, dimension_usage}, Symbol, Function, Function, Symbol}} where {time_dependence, dimension_usage}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{time_dependence, dimension_usage},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n) -> Any\nobjective!(\n    ocp::OptimalControlModel{time_dependence, dimension_usage},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n) -> Any\n\n\nSet the criterion to the function g and f⁰. Type can be :bolza. Criterion is :min or :max.\n\nExamples\n\njulia> objective!(ocp, :bolza, (t0, x0, tf, xf) -> tf, (x, u) -> x[1]^2 + u[1]^2) \n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.objective!-Union{Tuple{dimension_usage}, Tuple{time_dependence}, Tuple{OptimalControlModel{time_dependence, dimension_usage}, Symbol, Function}, Tuple{OptimalControlModel{time_dependence, dimension_usage}, Symbol, Function, Symbol}} where {time_dependence, dimension_usage}","page":"Model","title":"CTBase.objective!","text":"objective!(\n    ocp::OptimalControlModel{time_dependence, dimension_usage},\n    type::Symbol,\n    f::Function\n) -> Any\nobjective!(\n    ocp::OptimalControlModel{time_dependence, dimension_usage},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n) -> Any\n\n\nSet the criterion to the function f. Type can be :mayer or :lagrange. Criterion is :min or :max.\n\nExamples\n\njulia> objective!(ocp, :mayer, (t0, x0, tf, xf) -> tf)\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u[1]^2)\n\nImportant\n\nIf you set twice the objective, only the last one will be taken into account.\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","page":"Model","title":"CTBase.remove_constraint!","text":"remove_constraint!(\n    ocp::OptimalControlModel,\n    label::Symbol\n) -> Dict{Symbol, Tuple}\n\n\nRemove a labeled constraint.\n\nExamples\n\njulia> remove_constraint!(ocp, :con)\n\n\n\n\n\n","category":"method"},{"location":"api-model.html#CTBase.state!","page":"Model","title":"CTBase.state!","text":"state!(\n    ocp::OptimalControlModel,\n    n::Integer\n) -> Union{Vector{Vector{String}}, Vector{String}, String}\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    names::Union{String, Vector{String}}\n) -> Union{Vector{Vector{String}}, Vector{String}, String}\n\n\nDefine the state dimension and possibly the names of each coordinate.\n\nExamples\n\njulia> state!(ocp, 1, \"y\")\njulia> state!(ocp, 2, [ \"x₁\", \"x₂\" ])\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    time::Real\n) -> String\ntime!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    time::Real,\n    name::String\n) -> String\n\n\nFix initial (resp. final) time, the final (resp. initial) time being variable (free), when type is :initial. And conversely when type is :final. \n\nExamples\n\njulia> time!(ocp, :initial, 0, \"t\")\njulia> time!(ocp, :final, 1, \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-model.html#CTBase.time!-2","page":"Model","title":"CTBase.time!","text":"time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> String\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> String\n\n\nFix initial and final times to t[1] and t[2], respectively.\n\nExamples\n\njulia> time!(ocp, [ 0, 1 ], \"t\")\n\n\n\n\n\n","category":"function"},{"location":"api-default.html#Default","page":"Default","title":"Default","text":"","category":"section"},{"location":"api-default.html","page":"Default","title":"Default","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-default.html","page":"Default","title":"Default","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"default.jl\"]\nPrivate = false","category":"page"},{"location":"api-utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"api-utils.html","page":"Utils","title":"Utils","text":"CurrentModule =  CTBase","category":"page"},{"location":"api-utils.html","page":"Utils","title":"Utils","text":"Modules = [CTBase]\nOrder = [:module, :constant, :type, :function, :macro]\nPages = [\"utils.jl\"]\nPrivate = false","category":"page"},{"location":"api-utils.html#CTBase.Ad-Tuple{Any, Any}","page":"Utils","title":"CTBase.Ad","text":"Ad(X, f) -> CTBase.var\"#47#48\"\n\n\nLie derivative of f along X.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.Poisson-Tuple{Any, Any}","page":"Utils","title":"CTBase.Poisson","text":"Poisson(f, g) -> CTBase.var\"#fg#51\"\n\n\nReturns the Poisson bracket of f and g.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctgradient-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctgradient","text":"ctgradient(f::Function, x) -> Any\n\n\nReturns the gradient of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctindices-Tuple{Integer}","page":"Utils","title":"CTBase.ctindices","text":"ctindices(i::Integer) -> String\n\n\nReturns i > 0 as a subscript.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctinterpolate-Tuple{Any, Any}","page":"Utils","title":"CTBase.ctinterpolate","text":"ctinterpolate(x, f) -> Any\n\n\nReturns the interpolation of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctjacobian-Tuple{Function, Any}","page":"Utils","title":"CTBase.ctjacobian","text":"ctjacobian(f::Function, x) -> Any\n\n\nReturns the Jacobian of f at x.\n\n\n\n\n\n","category":"method"},{"location":"api-utils.html#CTBase.ctupperscripts-Tuple{Integer}","page":"Utils","title":"CTBase.ctupperscripts","text":"ctupperscripts(i::Integer) -> String\n\n\nReturns i > 0 as an upperscript.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Introduction-to-the-CTBase.jl-package","page":"Introduction","title":"Introduction to the CTBase.jl package","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTBase.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"To install a package from the control-toolbox ecosystem, please visit the installation page.","category":"page"}]
}
