var documenterSearchIndex = {"docs":
[{"location":"api.html#CTDirect-API","page":"API","title":"CTDirect API","text":"","category":"section"},{"location":"api.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Pages   = [\"api.md\"]\nModules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#Available-methods","page":"API","title":"Available methods","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"using CTDirect\nMethods()","category":"page"},{"location":"api.html#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [CTDirect]\nOrder = [:module, :constant, :type, :function, :macro]\nPrivate = false","category":"page"},{"location":"api.html#CTDirect.OptimalControlInit","page":"API","title":"CTDirect.OptimalControlInit","text":"Initialization of the optimal control problem solution for the NLP problem.\n\nConstructors:\n\nOptimalControlInit(): default initialization\nOptimalControlInit(x_init, u_init, v_init): constant vector or function handles\nOptimalControlInit(sol): from existing solution\n\nExamples\n\njulia> init = OptimalControlInit()\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3, v_init=0.5)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=t->sin(t), v_init=0.5)\njulia> init = OptimalControlInit(sol)\n\n\n\n\n\n","category":"type"},{"location":"api.html#CTDirect.Methods-Tuple{}","page":"API","title":"CTDirect.Methods","text":"Methods() -> Tuple{Tuple{Vararg{Symbol}}}\n\n\nReturn the list of available methods to solve the optimal control problem.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.is_solvable-Tuple{Any}","page":"API","title":"CTDirect.is_solvable","text":"is_solvable(ocp) -> Bool\n\n\nReturn if the optimal control problem ocp is solvable or not by the method solve.\n\n\n\n\n\n","category":"method"},{"location":"api.html#CTDirect.solve-Tuple{CTBase.OptimalControlModel, Vararg{Any}}","page":"API","title":"CTDirect.solve","text":"solve(\n    ocp::CTBase.OptimalControlModel,\n    description...;\n    display,\n    init,\n    grid_size,\n    print_level,\n    mu_strategy,\n    kwargs...\n) -> CTBase.OptimalControlSolution\n\n\nSolve the the optimal control problem ocp by the method given by the (optional) description. Return an  OptimalControlSolution from CTBase package, that is an approximation of  the optimal solution if the method has converged correctly.\n\nThe (optional) description\n\nYou can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list, the higher is the priority.\n\nKeyword arguments:\n\ndisplay: print or not information during the resolution\ninit: an initial condition for the solver\ngrid_size: number of time steps for the discretization\nprint_level: print level for the Ipopt solver\nmu_strategy: mu strategy for the Ipopt solver\n\nwarning: Warning\nThere is only one available method for the moment: the direct method transforms the optimal control problem into a nonlinear programming problem (NLP) solved by Ipopt, thanks to the package  ADNLPModels.\n\ntip: Tip\nTo see the list of available methods, simply call Methods().\nYou can pass any other option by a pair keyword=value according to the chosen method. See for instance, Ipopt options.\nThe default values for the keyword arguments are given here.\n\njulia> solve(ocp)\njulia> solve(ocp, :adnlp)\njulia> solve(ocp, :adnlp, :ipopt)\njulia> solve(ocp, display=false, init=OptimalControlInit(), grid_size=100, print_level=0, mu_strategy=\"adaptive\")\n\n\n\n\n\n","category":"method"},{"location":"dev-api.html#Internal-functions","page":"Internal functions","title":"Internal functions","text":"","category":"section"},{"location":"dev-api.html","page":"Internal functions","title":"Internal functions","text":"CurrentModule = CTDirect ","category":"page"},{"location":"dev-api.html","page":"Internal functions","title":"Internal functions","text":"Modules = [CTDirect]\nOrder = [:module, :type, :function, :macro]\nPublic = false","category":"page"},{"location":"index.html#CTDirect.jl","page":"Introduction","title":"CTDirect.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"CurrentModule =  CTDirect","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The CTDirect.jl package is part of the control-toolbox ecosystem.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"note: Install\nTo install a package from the control-toolbox ecosystem,  please visit the installation page.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"g(x(t_0) x(t_f)) + int_t_0^t_f f^0(t x(t) u(t))mathrmdt","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"where the state x and the control u are functions, subject, for t in t_0 t_f, to the differential constraint","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"   dotx(t) = f(t x(t) u(t))","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"and other constraints such as","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarrayllcll\npsi_l le psi(t x(t) u(t)) le psi_u \nphi_l le phi(x(t_0) x(t_f)) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on Pontryaginâ€™s Maximum Principle, but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance[1] and [2] for more details on direct transcription methods and NLP algorithms.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[1]: J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"[2]: J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Summary of the time discretization:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"beginarraylcl\nt in t_0t_f    to  t_0 ldots t_N=t_f02em\nx(cdot) u(cdot)  to  X=x_0 ldots x_N u_0 ldots u_N 1em\nhline\n\ntextcriterion  to  min g(x_0 x_N) 02em\ntextdynamics   to  x_i+i = x_i + (t_i+i - t_i) f(t_i x_i u_i)  text(Euler)02em\ntextpath constraints to psi_l le psi(t_i x_i u_i) le psi_u 02em\ntextlimit conditions to phi_l le phi(x_0 x_N) le phi_u\nendarray","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(NLP)quad left\nbeginarraylr\nmin  F(X) \nLB le C(X) le UB\nendarray\nright","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"We use packages from JuliaSmoothOptimizers to solve the (NLP) problem.","category":"page"}]
}
