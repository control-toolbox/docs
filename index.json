[{"id":3,"pagetitle":"CTBase API","title":"CTBase API","ref":"/optimalcontrol/stable/#CTBase-API","content":" CTBase API This is just a dump of CTBase API documentation. For more details about  CTBase.jl  package, see the  documentation ."},{"id":4,"pagetitle":"CTBase API","title":"Index","ref":"/optimalcontrol/stable/#Index","content":" Index CTBase.CTBase CTBase.AbstractHamiltonian CTBase.AmbiguousDescription CTBase.Autonomous CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.CTCallback CTBase.CTCallbacks CTBase.CTException CTBase.Control CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlLaw CTBase.ControlLaw CTBase.ControlLaw CTBase.ControlLaw CTBase.Controls CTBase.Costate CTBase.Costates CTBase.DCostate CTBase.DState CTBase.Description CTBase.Dimension CTBase.Dynamics CTBase.Dynamics CTBase.Dynamics CTBase.Dynamics CTBase.FeedbackControl CTBase.FeedbackControl CTBase.FeedbackControl CTBase.FeedbackControl CTBase.Fixed CTBase.Hamiltonian CTBase.Hamiltonian CTBase.Hamiltonian CTBase.Hamiltonian CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.IncorrectArgument CTBase.IncorrectMethod CTBase.IncorrectOutput CTBase.Index CTBase.Lagrange CTBase.Lagrange CTBase.Lagrange CTBase.Lagrange CTBase.Mayer CTBase.Mayer CTBase.Mayer CTBase.Mayer CTBase.MixedConstraint CTBase.MixedConstraint CTBase.MixedConstraint CTBase.MixedConstraint CTBase.Multiplier CTBase.Multiplier CTBase.Multiplier CTBase.Multiplier CTBase.NonAutonomous CTBase.NonFixed CTBase.NotImplemented CTBase.OptimalControlModel CTBase.OptimalControlSolution CTBase.ParsingError CTBase.PrintCallback CTBase.PrintCallback CTBase.State CTBase.StateConstraint CTBase.StateConstraint CTBase.StateConstraint CTBase.StateConstraint CTBase.States CTBase.StopCallback CTBase.StopCallback CTBase.Time CTBase.TimeDependence CTBase.Times CTBase.TimesDisc CTBase.UnauthorizedCall CTBase.Variable CTBase.VariableConstraint CTBase.VariableConstraint CTBase.VariableDependence CTBase.VectorField CTBase.VectorField CTBase.VectorField CTBase.VectorField CTBase.ctNumber CTBase.ctVector CTBase.:⋅ CTBase.:⋅ CTBase.:⋅ CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lift CTBase.Lift CTBase.Lift CTBase.Model CTBase.Model CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.add CTBase.add CTBase.constraint CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint_type CTBase.constraints_labels CTBase.control! CTBase.ct_repl CTBase.ctgradient CTBase.ctgradient CTBase.ctgradient CTBase.ctindices CTBase.ctinterpolate CTBase.ctjacobian CTBase.ctjacobian CTBase.ctjacobian CTBase.ctupperscripts CTBase.dynamics! CTBase.getFullDescription CTBase.get_priority_print_callbacks CTBase.get_priority_stop_callbacks CTBase.is_max CTBase.is_min CTBase.is_time_dependent CTBase.is_time_independent CTBase.is_variable_dependent CTBase.is_variable_independent CTBase.nlp_constraints CTBase.objective! CTBase.objective! CTBase.remove_constraint! CTBase.replace_call CTBase.replace_call CTBase.state! CTBase.time! CTBase.time! CTBase.time! CTBase.time! CTBase.time! CTBase.variable! CTBase.∂ₜ CTBase.@Lie CTBase.@def"},{"id":5,"pagetitle":"CTBase API","title":"Documentation","ref":"/optimalcontrol/stable/#Documentation","content":" Documentation"},{"id":6,"pagetitle":"CTBase API","title":"CTBase.CTBase","ref":"/optimalcontrol/stable/#CTBase.CTBase","content":" CTBase.CTBase  —  Module CTBase  module. Lists all the imported modules and packages: Base Core DataStructures DocStringExtensions LinearAlgebra MLStyle Parameters Plots PrettyTables Printf ReplMaker Unicode List of all the exported names: AbstractHamiltonian AmbiguousDescription Autonomous BoundaryConstraint CTCallback CTCallbacks CTException Control ControlConstraint ControlLaw Controls Costate Costates DCostate DState Description Dimension Dynamics FeedbackControl Fixed Hamiltonian HamiltonianLift HamiltonianVectorField IncorrectArgument IncorrectMethod IncorrectOutput Index Lagrange @Lie Lie Lift Mayer MixedConstraint Model Multiplier NonAutonomous NonFixed NotImplemented OptimalControlModel OptimalControlSolution ParsingError Poisson PrintCallback State StateConstraint States StopCallback Time TimeDependence Times TimesDisc UnauthorizedCall Variable VariableConstraint VariableDependence VectorField add constraint constraint! constraint_type constraints_labels control! ctNumber ctVector ct_repl ctgradient ctindices ctinterpolate ctjacobian ctupperscripts @def dynamics! getFullDescription get_priority_print_callbacks get_priority_stop_callbacks is_max is_min is_time_dependent is_time_independent is_variable_dependent is_variable_independent nlp_constraints objective! plot plot! remove_constraint! replace_call state! time! variable! ∂ₜ ⋅"},{"id":7,"pagetitle":"CTBase API","title":"CTBase.Control","ref":"/optimalcontrol/stable/#CTBase.Control","content":" CTBase.Control  —  Type Type alias for a control."},{"id":8,"pagetitle":"CTBase API","title":"CTBase.Costate","ref":"/optimalcontrol/stable/#CTBase.Costate","content":" CTBase.Costate  —  Type Type alias for an costate."},{"id":9,"pagetitle":"CTBase API","title":"CTBase.DCostate","ref":"/optimalcontrol/stable/#CTBase.DCostate","content":" CTBase.DCostate  —  Type Type alias for a tangent vector to the costate space."},{"id":10,"pagetitle":"CTBase API","title":"CTBase.DState","ref":"/optimalcontrol/stable/#CTBase.DState","content":" CTBase.DState  —  Type Type alias for a tangent vector to the state space."},{"id":11,"pagetitle":"CTBase API","title":"CTBase.State","ref":"/optimalcontrol/stable/#CTBase.State","content":" CTBase.State  —  Type Type alias for a state."},{"id":12,"pagetitle":"CTBase API","title":"CTBase.TimesDisc","ref":"/optimalcontrol/stable/#CTBase.TimesDisc","content":" CTBase.TimesDisc  —  Type Type alias for a grid of times."},{"id":13,"pagetitle":"CTBase API","title":"CTBase.Variable","ref":"/optimalcontrol/stable/#CTBase.Variable","content":" CTBase.Variable  —  Type Type alias for a variable."},{"id":14,"pagetitle":"CTBase API","title":"CTBase.ctVector","ref":"/optimalcontrol/stable/#CTBase.ctVector","content":" CTBase.ctVector  —  Type Type alias for a vector of real numbers."},{"id":15,"pagetitle":"CTBase API","title":"CTBase.AbstractHamiltonian","ref":"/optimalcontrol/stable/#CTBase.AbstractHamiltonian","content":" CTBase.AbstractHamiltonian  —  Type abstract type AbstractHamiltonian{time_dependence, variable_dependence} Abstract type for hamiltonians."},{"id":16,"pagetitle":"CTBase API","title":"CTBase.AmbiguousDescription","ref":"/optimalcontrol/stable/#CTBase.AmbiguousDescription","content":" CTBase.AmbiguousDescription  —  Type struct AmbiguousDescription <: CTException Exception thrown when the description is ambiguous / incorrect. Fields var::Tuple{Vararg{Symbol}}"},{"id":17,"pagetitle":"CTBase API","title":"CTBase.Autonomous","ref":"/optimalcontrol/stable/#CTBase.Autonomous","content":" CTBase.Autonomous  —  Type abstract type Autonomous <: TimeDependence"},{"id":18,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/optimalcontrol/stable/#CTBase.BoundaryConstraint","content":" CTBase.BoundaryConstraint  —  Type struct BoundaryConstraint{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  BoundaryConstraint  returns a  BoundaryConstraint  of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. When the constraint is dimension 1, return a scalar. Call The call returns the evaluation of the  BoundaryConstraint  for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]"},{"id":19,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/optimalcontrol/stable/#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.BoundaryConstraint  —  Method BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n Return a  BoundaryConstraint  of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)"},{"id":20,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/optimalcontrol/stable/#CTBase.BoundaryConstraint-Tuple{Function}","content":" CTBase.BoundaryConstraint  —  Method BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n Return a  BoundaryConstraint  of a function. Dependencies are specified with a boolean, variable, false by default. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)"},{"id":21,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/optimalcontrol/stable/#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.BoundaryConstraint  —  Method Return the evaluation of the BoundaryConstraint. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]"},{"id":22,"pagetitle":"CTBase API","title":"CTBase.CTCallback","ref":"/optimalcontrol/stable/#CTBase.CTCallback","content":" CTBase.CTCallback  —  Type abstract type CTCallback Abstract type for callbacks."},{"id":23,"pagetitle":"CTBase API","title":"CTBase.CTCallbacks","ref":"/optimalcontrol/stable/#CTBase.CTCallbacks","content":" CTBase.CTCallbacks  —  Type Tuple of callbacks"},{"id":24,"pagetitle":"CTBase API","title":"CTBase.CTException","ref":"/optimalcontrol/stable/#CTBase.CTException","content":" CTBase.CTException  —  Type abstract type CTException <: Exception Abstract type for exceptions."},{"id":25,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/optimalcontrol/stable/#CTBase.ControlConstraint","content":" CTBase.ControlConstraint  —  Type struct ControlConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlConstraint  returns a  ControlConstraint  of a function. The function must take 1 to 3 arguments,  u  to  (t, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true) Warning When the control is of dimension 1, consider  u  as a scalar. Call The call returns the evaluation of the  ControlConstraint  for given values. Examples julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":26,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/optimalcontrol/stable/#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)"},{"id":27,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/optimalcontrol/stable/#CTBase.ControlConstraint-Tuple{Function}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  ControlConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)"},{"id":28,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/optimalcontrol/stable/#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlConstraint  —  Method Return the value of the ControlConstraint function. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":29,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/optimalcontrol/stable/#CTBase.ControlLaw","content":" CTBase.ControlLaw  —  Type struct ControlLaw{time_dependence, variable_dependence} Fields f::Function Similar to  Hamiltonian  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlLaw  returns a  ControlLaw  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  ControlLaw  for given values. Examples julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":30,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/optimalcontrol/stable/#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)"},{"id":31,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/optimalcontrol/stable/#CTBase.ControlLaw-Tuple{Function}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)"},{"id":32,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/optimalcontrol/stable/#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlLaw  —  Method Return the value of the ControlLaw function. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":33,"pagetitle":"CTBase API","title":"CTBase.Controls","ref":"/optimalcontrol/stable/#CTBase.Controls","content":" CTBase.Controls  —  Type Type alias for a vector of controls."},{"id":34,"pagetitle":"CTBase API","title":"CTBase.Costates","ref":"/optimalcontrol/stable/#CTBase.Costates","content":" CTBase.Costates  —  Type Type alias for a vector of costates."},{"id":35,"pagetitle":"CTBase API","title":"CTBase.Description","ref":"/optimalcontrol/stable/#CTBase.Description","content":" CTBase.Description  —  Type A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}."},{"id":36,"pagetitle":"CTBase API","title":"CTBase.Dimension","ref":"/optimalcontrol/stable/#CTBase.Dimension","content":" CTBase.Dimension  —  Type Type alias for a dimension."},{"id":37,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/optimalcontrol/stable/#CTBase.Dynamics","content":" CTBase.Dynamics  —  Type struct Dynamics{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Dynamics  returns a  Dynamics  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Dynamics  for given values. Examples julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":38,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/optimalcontrol/stable/#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)"},{"id":39,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/optimalcontrol/stable/#CTBase.Dynamics-Tuple{Function}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)"},{"id":40,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/optimalcontrol/stable/#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Dynamics  —  Method Return the value of the Dynamics function. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":41,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/optimalcontrol/stable/#CTBase.FeedbackControl","content":" CTBase.FeedbackControl  —  Type struct FeedbackControl{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  FeedbackControl  returns a  FeedbackControl  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  FeedbackControl  for given values. Examples julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5"},{"id":42,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/optimalcontrol/stable/#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)"},{"id":43,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/optimalcontrol/stable/#CTBase.FeedbackControl-Tuple{Function}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)"},{"id":44,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/optimalcontrol/stable/#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.FeedbackControl  —  Method Return the value of the FeedbackControl function. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5"},{"id":45,"pagetitle":"CTBase API","title":"CTBase.Fixed","ref":"/optimalcontrol/stable/#CTBase.Fixed","content":" CTBase.Fixed  —  Type abstract type Fixed <: VariableDependence"},{"id":46,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/optimalcontrol/stable/#CTBase.Hamiltonian","content":" CTBase.Hamiltonian  —  Type struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Hamiltonian  returns a  Hamiltonian  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Hamiltonian  for given values. Examples julia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":47,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/optimalcontrol/stable/#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)"},{"id":48,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/optimalcontrol/stable/#CTBase.Hamiltonian-Tuple{Function}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)"},{"id":49,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/optimalcontrol/stable/#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Hamiltonian  —  Method Return the value of the Hamiltonian. julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":50,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/optimalcontrol/stable/#CTBase.HamiltonianLift","content":" CTBase.HamiltonianLift  —  Type struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Lifts X::VectorField The values for  time_dependence  and  variable_dependence  are deternimed by the values of those for the VectorField. Constructor The constructor  HamiltonianLift  returns a  HamiltonianLift  of a  VectorField . Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianLift  for given values. Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3 Alternatively, it is possible to construct the  HamiltonianLift  from a  Function  being the  VectorField . julia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue"},{"id":51,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/optimalcontrol/stable/#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)"},{"id":52,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/optimalcontrol/stable/#CTBase.HamiltonianLift-Tuple{Function}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)"},{"id":53,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/optimalcontrol/stable/#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianLift  —  Method Return the value of the HamiltonianLift. Examples julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3"},{"id":54,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/optimalcontrol/stable/#CTBase.HamiltonianVectorField","content":" CTBase.HamiltonianVectorField  —  Type struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  HamiltonianVectorField  returns a  HamiltonianVectorField  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianVectorField  for given values. Examples julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]"},{"id":55,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/optimalcontrol/stable/#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)"},{"id":56,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/optimalcontrol/stable/#CTBase.HamiltonianVectorField-Tuple{Function}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)"},{"id":57,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/optimalcontrol/stable/#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianVectorField  —  Method Return the value of the HamiltonianVectorField. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]"},{"id":58,"pagetitle":"CTBase API","title":"CTBase.IncorrectArgument","ref":"/optimalcontrol/stable/#CTBase.IncorrectArgument","content":" CTBase.IncorrectArgument  —  Type struct IncorrectArgument <: CTException Exception thrown when an argument is inconsistent. Fields var::String"},{"id":59,"pagetitle":"CTBase API","title":"CTBase.IncorrectMethod","ref":"/optimalcontrol/stable/#CTBase.IncorrectMethod","content":" CTBase.IncorrectMethod  —  Type struct IncorrectMethod <: CTException Exception thrown when a method is incorrect. Fields var::Symbol"},{"id":60,"pagetitle":"CTBase API","title":"CTBase.IncorrectOutput","ref":"/optimalcontrol/stable/#CTBase.IncorrectOutput","content":" CTBase.IncorrectOutput  —  Type struct IncorrectOutput <: CTException Exception thrown when the output is incorrect. Fields var::String"},{"id":61,"pagetitle":"CTBase API","title":"CTBase.Index","ref":"/optimalcontrol/stable/#CTBase.Index","content":" CTBase.Index  —  Type mutable struct Index Fields val::Integer"},{"id":62,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/optimalcontrol/stable/#CTBase.Lagrange","content":" CTBase.Lagrange  —  Type struct Lagrange{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Lagrange  returns a  Lagrange  cost of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Lagrange  cost for given values. Examples julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3"},{"id":63,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/optimalcontrol/stable/#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n"},{"id":64,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/optimalcontrol/stable/#CTBase.Lagrange-Tuple{Function}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n"},{"id":65,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/optimalcontrol/stable/#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Lagrange  —  Method Return the value of the Lagrange function. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3"},{"id":66,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/optimalcontrol/stable/#CTBase.Mayer","content":" CTBase.Mayer  —  Type struct Mayer{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  Mayer  returns a  Mayer  cost of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. Call The call returns the evaluation of the  Mayer  cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4"},{"id":67,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/optimalcontrol/stable/#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","content":" CTBase.Mayer  —  Method Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n Return a  Mayer  cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)"},{"id":68,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/optimalcontrol/stable/#CTBase.Mayer-Tuple{Function}","content":" CTBase.Mayer  —  Method Mayer(f::Function; variable) -> Mayer{Fixed}\n Return a  Mayer  cost of a function. Dependencies are specified with a boolean, variable, false by default. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)"},{"id":69,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/optimalcontrol/stable/#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Mayer  —  Method Return the evaluation of the Mayer cost. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4"},{"id":70,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/optimalcontrol/stable/#CTBase.MixedConstraint","content":" CTBase.MixedConstraint  —  Type struct MixedConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  Lagrange  in the usage, but the dimension of the output of the function  f  is arbitrary. The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  MixedConstraint  returns a  MixedConstraint  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  MixedConstraint  for given values. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":71,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/optimalcontrol/stable/#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)"},{"id":72,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/optimalcontrol/stable/#CTBase.MixedConstraint-Tuple{Function}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)"},{"id":73,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/optimalcontrol/stable/#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.MixedConstraint  —  Method Return the value of the MixedConstraint function. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":74,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/optimalcontrol/stable/#CTBase.Multiplier","content":" CTBase.Multiplier  —  Type struct Multiplier{time_dependence, variable_dependence} Fields f::Function Similar to  ControlLaw  in the usage. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Multiplier  returns a  Multiplier  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Multiplier  for given values. Examples julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":75,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/optimalcontrol/stable/#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)"},{"id":76,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/optimalcontrol/stable/#CTBase.Multiplier-Tuple{Function}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)"},{"id":77,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/optimalcontrol/stable/#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Multiplier  —  Method Return the value of the Multiplier function. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":78,"pagetitle":"CTBase API","title":"CTBase.NonAutonomous","ref":"/optimalcontrol/stable/#CTBase.NonAutonomous","content":" CTBase.NonAutonomous  —  Type abstract type NonAutonomous <: TimeDependence"},{"id":79,"pagetitle":"CTBase API","title":"CTBase.NonFixed","ref":"/optimalcontrol/stable/#CTBase.NonFixed","content":" CTBase.NonFixed  —  Type abstract type NonFixed <: VariableDependence"},{"id":80,"pagetitle":"CTBase API","title":"CTBase.NotImplemented","ref":"/optimalcontrol/stable/#CTBase.NotImplemented","content":" CTBase.NotImplemented  —  Type struct NotImplemented <: CTException Exception thrown when a method is not implemented. Fields var::String"},{"id":81,"pagetitle":"CTBase API","title":"CTBase.OptimalControlModel","ref":"/optimalcontrol/stable/#CTBase.OptimalControlModel","content":" CTBase.OptimalControlModel  —  Type mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel Fields model_expression::Union{Nothing, Expr} : Default: nothing initial_time::Union{Nothing, Index, Real} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time::Union{Nothing, Index, Real} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing lagrange::Union{Nothing, Lagrange} : Default: nothing mayer::Union{Nothing, Mayer} : Default: nothing criterion::Union{Nothing, Symbol} : Default: nothing dynamics::Union{Nothing, Dynamics} : Default: nothing constraints::Dict{Symbol, Tuple} : Default: Dict{Symbol, Tuple{Vararg{Any}}}()"},{"id":82,"pagetitle":"CTBase API","title":"CTBase.OptimalControlSolution","ref":"/optimalcontrol/stable/#CTBase.OptimalControlSolution","content":" CTBase.OptimalControlSolution  —  Type mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution Type of an optimal control solution. Fields times::Union{Nothing, StepRangeLen, AbstractVector{<:Real}} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing control::Union{Nothing, Function} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing state::Union{Nothing, Function} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing variable::Union{Nothing, Real, AbstractVector{<:Real}} : Default: nothing costate::Union{Nothing, Function} : Default: nothing objective::Union{Nothing, Real} : Default: nothing iterations::Union{Nothing, Integer} : Default: nothing stopping::Union{Nothing, Symbol} : Default: nothing message::Union{Nothing, String} : Default: nothing success::Union{Nothing, Bool} : Default: nothing infos::Dict{Symbol, Any} : Default: Dict{Symbol, Any}()"},{"id":83,"pagetitle":"CTBase API","title":"CTBase.ParsingError","ref":"/optimalcontrol/stable/#CTBase.ParsingError","content":" CTBase.ParsingError  —  Type struct ParsingError <: CTException Exception thrown for syntax error during abstract parsing. Fields var::String"},{"id":84,"pagetitle":"CTBase API","title":"CTBase.PrintCallback","ref":"/optimalcontrol/stable/#CTBase.PrintCallback","content":" CTBase.PrintCallback  —  Type mutable struct PrintCallback <: CTCallback Callback for printing."},{"id":85,"pagetitle":"CTBase API","title":"CTBase.PrintCallback","ref":"/optimalcontrol/stable/#CTBase.PrintCallback-Tuple","content":" CTBase.PrintCallback  —  Method Call the callback."},{"id":86,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/optimalcontrol/stable/#CTBase.StateConstraint","content":" CTBase.StateConstraint  —  Type struct StateConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  StateConstraint  returns a  StateConstraint  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  StateConstraint  for given values. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":87,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/optimalcontrol/stable/#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)"},{"id":88,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/optimalcontrol/stable/#CTBase.StateConstraint-Tuple{Function}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)"},{"id":89,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/optimalcontrol/stable/#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.StateConstraint  —  Method Return the value of the StateConstraint function. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":90,"pagetitle":"CTBase API","title":"CTBase.States","ref":"/optimalcontrol/stable/#CTBase.States","content":" CTBase.States  —  Type Type alias for a vector of states."},{"id":91,"pagetitle":"CTBase API","title":"CTBase.StopCallback","ref":"/optimalcontrol/stable/#CTBase.StopCallback","content":" CTBase.StopCallback  —  Type Stopping callback."},{"id":92,"pagetitle":"CTBase API","title":"CTBase.StopCallback","ref":"/optimalcontrol/stable/#CTBase.StopCallback-Tuple","content":" CTBase.StopCallback  —  Method Call the callback."},{"id":93,"pagetitle":"CTBase API","title":"CTBase.Time","ref":"/optimalcontrol/stable/#CTBase.Time","content":" CTBase.Time  —  Type Type alias for a time."},{"id":94,"pagetitle":"CTBase API","title":"CTBase.TimeDependence","ref":"/optimalcontrol/stable/#CTBase.TimeDependence","content":" CTBase.TimeDependence  —  Type abstract type TimeDependence"},{"id":95,"pagetitle":"CTBase API","title":"CTBase.Times","ref":"/optimalcontrol/stable/#CTBase.Times","content":" CTBase.Times  —  Type Type alias for a vector of times."},{"id":96,"pagetitle":"CTBase API","title":"CTBase.UnauthorizedCall","ref":"/optimalcontrol/stable/#CTBase.UnauthorizedCall","content":" CTBase.UnauthorizedCall  —  Type struct UnauthorizedCall <: CTException Exception thrown when a call to a function is not authorized. Fields var::String"},{"id":97,"pagetitle":"CTBase API","title":"CTBase.VariableConstraint","ref":"/optimalcontrol/stable/#CTBase.VariableConstraint","content":" CTBase.VariableConstraint  —  Type struct VariableConstraint Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VariableConstraint  returns a  VariableConstraint  of a function. The function must take 1 argument,  v . Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]]) Warning When the variable is of dimension 1, consider  v  as a scalar. Call The call returns the evaluation of the  VariableConstraint  for given values. Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]"},{"id":98,"pagetitle":"CTBase API","title":"CTBase.VariableConstraint","ref":"/optimalcontrol/stable/#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VariableConstraint  —  Method Return the value of the VariableConstraint function. julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]"},{"id":99,"pagetitle":"CTBase API","title":"CTBase.VariableDependence","ref":"/optimalcontrol/stable/#CTBase.VariableDependence","content":" CTBase.VariableDependence  —  Type abstract type VariableDependence"},{"id":100,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/optimalcontrol/stable/#CTBase.VectorField","content":" CTBase.VectorField  —  Type struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VectorField  returns a  VectorField  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  VectorField  for given values. Examples julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":101,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/optimalcontrol/stable/#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)"},{"id":102,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/optimalcontrol/stable/#CTBase.VectorField-Tuple{Function}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)"},{"id":103,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/optimalcontrol/stable/#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VectorField  —  Method Return the value of the VectorField. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":104,"pagetitle":"CTBase API","title":"CTBase.ctNumber","ref":"/optimalcontrol/stable/#CTBase.ctNumber","content":" CTBase.ctNumber  —  Type Type alias for a real number."},{"id":105,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/optimalcontrol/stable/#CTBase.:⋅-Tuple{Function, Function}","content":" CTBase.:⋅  —  Method ⋅(X::Function, f::Function) -> Function\n Lie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError"},{"id":106,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/optimalcontrol/stable/#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#105#107\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0"},{"id":107,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/optimalcontrol/stable/#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#109#111\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case Example julia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10"},{"id":108,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/optimalcontrol/stable/#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n Lie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10"},{"id":109,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/optimalcontrol/stable/#CTBase.Lie-Tuple{Function, Function}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n Lie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10"},{"id":110,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/optimalcontrol/stable/#CTBase.Lie-Tuple{VectorField, Function}","content":" CTBase.Lie  —  Method Lie(X::VectorField, f::Function) -> Function\n Lie derivative of a scalar function along a vector field. Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10"},{"id":111,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/optimalcontrol/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField{Autonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case Example julia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]"},{"id":112,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/optimalcontrol/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case Example julia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]"},{"id":113,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/optimalcontrol/stable/#CTBase.Lift-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lift  —  Method Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2"},{"id":114,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/optimalcontrol/stable/#CTBase.Lift-Tuple{Function}","content":" CTBase.Lift  —  Method Lift(X::Function; autonomous, variable) -> HamiltonianLift\n Return the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2"},{"id":115,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/optimalcontrol/stable/#CTBase.Lift-Tuple{VectorField}","content":" CTBase.Lift  —  Method Lift(X::VectorField) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField. Example julia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2"},{"id":116,"pagetitle":"CTBase API","title":"CTBase.Model","ref":"/optimalcontrol/stable/#CTBase.Model-Tuple{Vararg{DataType}}","content":" CTBase.Model  —  Method Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following argument: dependencies : either  Autonomous  or  NonAutonomous . Default is  Autonomous . And either  NonFixed  or  Fixed . Default is  Fixed . Examples julia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control."},{"id":117,"pagetitle":"CTBase API","title":"CTBase.Model","ref":"/optimalcontrol/stable/#CTBase.Model-Tuple{}","content":" CTBase.Model  —  Method Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following optional keyword argument: autonomous : either  true  or  false . Default is  true . variable : either  true  or  false . Default is  false . Examples julia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control."},{"id":118,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/optimalcontrol/stable/#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":119,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/optimalcontrol/stable/#CTBase.Poisson-Tuple{Function, Function}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":120,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/optimalcontrol/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift{Autonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20"},{"id":121,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/optimalcontrol/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift{NonAutonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case Example julia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":122,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/optimalcontrol/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n Poisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":123,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/optimalcontrol/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n Poisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g) Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":124,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/optimalcontrol/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n Poisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g) Example julia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100"},{"id":125,"pagetitle":"CTBase API","title":"CTBase.add","ref":"/optimalcontrol/stable/#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Concatenate the description  y  at the tuple of descriptions  x  if it is not already in the tuple  x . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))"},{"id":126,"pagetitle":"CTBase API","title":"CTBase.add","ref":"/optimalcontrol/stable/#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Return a tuple containing only the description  y . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)"},{"id":127,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/optimalcontrol/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  value functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[2], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u+v[1], 0)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u-t*v[2], 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t+v[1], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]-u*v[1], 0)"},{"id":128,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/optimalcontrol/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint (whole range). Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 0, 1) # the variable here is of dimension 1"},{"id":129,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/optimalcontrol/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on a range of the state, or a value constraint on a range of the  :variable . Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\njulia> constraint!(ocp, :variable, 2:3, [ 0, 3 ])"},{"id":130,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/optimalcontrol/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on the state, or a  :variable  value. Can also be used with  :state  and  :control . Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0 ])\njulia> constraint!(ocp, :final, 2) # if the state is of dimension 1\njulia> constraint!(ocp, :variable, [ 3, 0, 1 ])"},{"id":131,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/optimalcontrol/stable/#CTBase.constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol;\n    rg,\n    f,\n    val,\n    lb,\n    ub,\n    label\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :control, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :state, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial, rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])"},{"id":132,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/optimalcontrol/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where V<:VariableDependence","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 1:2, [ 0, 0 ], [ 1, 2 ])"},{"id":133,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/optimalcontrol/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where {T, V}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  box functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0, 1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0, 1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 0, 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u, v) -> x[1]-v[2]*u, 0, 1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u+v[2], 0, 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t*v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]*v[2]-u, 0, 1)"},{"id":134,"pagetitle":"CTBase API","title":"CTBase.constraint","ref":"/optimalcontrol/stable/#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.constraint  —  Method constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n Retrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds). Example julia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1"},{"id":135,"pagetitle":"CTBase API","title":"CTBase.constraint_type","ref":"/optimalcontrol/stable/#CTBase.constraint_type-NTuple{7, Any}","content":" CTBase.constraint_type  —  Method constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n Return the type constraint among  :initial ,  :final ,  :boundary ,  :control_range ,  :control_fun ,  :state_range ,  :state_fun ,  :mixed ,  :variable_range ,  :variable_fun  ( :other  otherwise), together with the appropriate value (range, updated expression...) Example julia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, Index(1))\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, Index(1))\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, Index(2))\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v ^ 2 + 1))\n\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v[2] ^ 2 + 1))"},{"id":136,"pagetitle":"CTBase API","title":"CTBase.constraints_labels","ref":"/optimalcontrol/stable/#CTBase.constraints_labels-Tuple{OptimalControlModel}","content":" CTBase.constraints_labels  —  Method constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n Return the labels of the constraints as a  Base.keys . Example julia> constraints_labels(ocp)"},{"id":137,"pagetitle":"CTBase API","title":"CTBase.control!","ref":"/optimalcontrol/stable/#CTBase.control!","content":" CTBase.control!  —  Function control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the control dimension and possibly the names of each coordinate. Note You must use control! only once to set the control dimension. Examples julia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]"},{"id":138,"pagetitle":"CTBase API","title":"CTBase.ct_repl","ref":"/optimalcontrol/stable/#CTBase.ct_repl-Tuple{}","content":" CTBase.ct_repl  —  Method ct_repl(; debug, demo) -> Any\n Create a ct REPL."},{"id":139,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/optimalcontrol/stable/#CTBase.ctgradient-Tuple{Function, Any}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x) -> Any\n Return the gradient of  f  at  x ."},{"id":140,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/optimalcontrol/stable/#CTBase.ctgradient-Tuple{Function, Real}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x::Real) -> Any\n Return the gradient of  f  at  x ."},{"id":141,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/optimalcontrol/stable/#CTBase.ctgradient-Tuple{VectorField, Any}","content":" CTBase.ctgradient  —  Method ctgradient(X::VectorField, x) -> Any\n Return the gradient of  X  at  x ."},{"id":142,"pagetitle":"CTBase API","title":"CTBase.ctindices","ref":"/optimalcontrol/stable/#CTBase.ctindices-Tuple{Integer}","content":" CTBase.ctindices  —  Method ctindices(i::Integer) -> String\n Return  i  > 0 as a subscript."},{"id":143,"pagetitle":"CTBase API","title":"CTBase.ctinterpolate","ref":"/optimalcontrol/stable/#CTBase.ctinterpolate-Tuple{Any, Any}","content":" CTBase.ctinterpolate  —  Method ctinterpolate(x, f) -> Any\n Return the interpolation of  f  at  x ."},{"id":144,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/optimalcontrol/stable/#CTBase.ctjacobian-Tuple{Function, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x) -> Any\n Return the Jacobian of  f  at  x ."},{"id":145,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/optimalcontrol/stable/#CTBase.ctjacobian-Tuple{Function, Real}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x::Real) -> Any\n Return the Jacobian of  f  at  x ."},{"id":146,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/optimalcontrol/stable/#CTBase.ctjacobian-Tuple{VectorField, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(X::VectorField, x) -> Any\n Return the Jacobian of  X  at  x ."},{"id":147,"pagetitle":"CTBase API","title":"CTBase.ctupperscripts","ref":"/optimalcontrol/stable/#CTBase.ctupperscripts-Tuple{Integer}","content":" CTBase.ctupperscripts  —  Method ctupperscripts(i::Integer) -> String\n Return  i  > 0 as an upperscript."},{"id":148,"pagetitle":"CTBase API","title":"CTBase.dynamics!","ref":"/optimalcontrol/stable/#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.dynamics!  —  Method dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n Set the dynamics. Note You can use dynamics! only once to define the dynamics. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> dynamics!(ocp, f)"},{"id":149,"pagetitle":"CTBase API","title":"CTBase.getFullDescription","ref":"/optimalcontrol/stable/#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","content":" CTBase.getFullDescription  —  Method getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n Return a complete description from an incomplete description  desc  and  a list of complete descriptions  desc_list . If several complete descriptions are possible,  then the first one is returned. Example julia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)"},{"id":150,"pagetitle":"CTBase API","title":"CTBase.get_priority_print_callbacks","ref":"/optimalcontrol/stable/#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_print_callbacks  —  Method get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority print callbacks."},{"id":151,"pagetitle":"CTBase API","title":"CTBase.get_priority_stop_callbacks","ref":"/optimalcontrol/stable/#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_stop_callbacks  —  Method get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority stop callbacks."},{"id":152,"pagetitle":"CTBase API","title":"CTBase.is_max","ref":"/optimalcontrol/stable/#CTBase.is_max-Tuple{OptimalControlModel}","content":" CTBase.is_max  —  Method is_max(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :max ."},{"id":153,"pagetitle":"CTBase API","title":"CTBase.is_min","ref":"/optimalcontrol/stable/#CTBase.is_min-Tuple{OptimalControlModel}","content":" CTBase.is_min  —  Method is_min(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :min ."},{"id":154,"pagetitle":"CTBase API","title":"CTBase.is_time_dependent","ref":"/optimalcontrol/stable/#CTBase.is_time_dependent-Tuple{OptimalControlModel{NonAutonomous}}","content":" CTBase.is_time_dependent  —  Method is_time_dependent(\n    ocp::OptimalControlModel{NonAutonomous}\n) -> Bool\n Return  true  if the model has been defined as time dependent."},{"id":155,"pagetitle":"CTBase API","title":"CTBase.is_time_independent","ref":"/optimalcontrol/stable/#CTBase.is_time_independent-Tuple{OptimalControlModel}","content":" CTBase.is_time_independent  —  Method is_time_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as time independent."},{"id":156,"pagetitle":"CTBase API","title":"CTBase.is_variable_dependent","ref":"/optimalcontrol/stable/#CTBase.is_variable_dependent-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","content":" CTBase.is_variable_dependent  —  Method is_variable_dependent(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n Return  true  if the model has been defined as variable dependent."},{"id":157,"pagetitle":"CTBase API","title":"CTBase.is_variable_independent","ref":"/optimalcontrol/stable/#CTBase.is_variable_independent-Tuple{OptimalControlModel}","content":" CTBase.is_variable_independent  —  Method is_variable_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as variable independent."},{"id":158,"pagetitle":"CTBase API","title":"CTBase.nlp_constraints","ref":"/optimalcontrol/stable/#CTBase.nlp_constraints-Tuple{OptimalControlModel}","content":" CTBase.nlp_constraints  —  Method nlp_constraints(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#99\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#100\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#101\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#102\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#θ#103\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n Return a 6-tuple of tuples: (ξl, ξ, ξu)  are control constraints (ηl, η, ηu)  are state constraints (ψl, ψ, ψu)  are mixed constraints (ϕl, ϕ, ϕu)  are boundary constraints (θl, θ, θu)  are variable constraints (ul, uind, uu)  are control linear constraints of a subset of indices (xl, xind, xu)  are state linear constraints of a subset of indices (vl, vind, vu)  are variable linear constraints of a subset of indices Note The dimensions of the state and control must be set before calling  nlp_constraints . Example julia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints(ocp)"},{"id":159,"pagetitle":"CTBase API","title":"CTBase.objective!","ref":"/optimalcontrol/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  g  and  f⁰ . Type can be  :bolza . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1"},{"id":160,"pagetitle":"CTBase API","title":"CTBase.objective!","ref":"/optimalcontrol/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  f . Type can be  :mayer  or  :lagrange . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1 Warning If you set twice the objective, only the last one will be taken into account."},{"id":161,"pagetitle":"CTBase API","title":"CTBase.remove_constraint!","ref":"/optimalcontrol/stable/#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.remove_constraint!  —  Method remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n Remove a labeled constraint. Example julia> remove_constraint!(ocp, :con)"},{"id":162,"pagetitle":"CTBase API","title":"CTBase.replace_call","ref":"/optimalcontrol/stable/#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Symbol, t, y) -> Any\n Replace calls in e of the form  (...x...)(t)  by  (...y...) . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)"},{"id":163,"pagetitle":"CTBase API","title":"CTBase.replace_call","ref":"/optimalcontrol/stable/#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Vector{Symbol}, t, y) -> Any\n Replace calls in e of the form  (...x1...x2...)(t)  by  (...y1...y2...)  for all symbols  x1 ,  x2 ... in the vector  x . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])"},{"id":164,"pagetitle":"CTBase API","title":"CTBase.state!","ref":"/optimalcontrol/stable/#CTBase.state!","content":" CTBase.state!  —  Function state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the state dimension and possibly the names of each component. Note You must use state! only once to set the state dimension. Examples julia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]"},{"id":165,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/optimalcontrol/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real,\n    name::String\n)\n Fix final time, initial time is free and given by the variable at the provided index. Examples julia> time!(ocp, Index(2), 1, \"t\")"},{"id":166,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/optimalcontrol/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index,\n    name::String\n)\n Initial and final times are free and given by the variable at the provided indices. Examples julia> time!(ocp, Index(2), Index(3), \"t\")"},{"id":167,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/optimalcontrol/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index,\n    name::String\n)\n Fix initial time, final time is free and given by the variable at the provided index. Note You must use time! only once to set either the initial or the final time, or both. Examples julia> time!(ocp, 0, Index(2), \"t\")"},{"id":168,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/optimalcontrol/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> Any\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> Any\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, [ 0, 1 ])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [ 0, 1 ], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [ 0, 1 ], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\""},{"id":169,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/optimalcontrol/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(ocp::OptimalControlModel, t0::Real, tf::Real)\ntime!(\n    ocp::OptimalControlModel,\n    t0::Real,\n    tf::Real,\n    name::String\n)\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, 0, 1)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, 0, 1, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, 0, 1, :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\""},{"id":170,"pagetitle":"CTBase API","title":"CTBase.variable!","ref":"/optimalcontrol/stable/#CTBase.variable!","content":" CTBase.variable!  —  Function variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the variable dimension and possibly the names of each component. Note You can use variable! once to set the variable dimension when the model is  NonFixed . Examples julia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])"},{"id":171,"pagetitle":"CTBase API","title":"CTBase.∂ₜ","ref":"/optimalcontrol/stable/#CTBase.∂ₜ-Tuple{Any}","content":" CTBase.∂ₜ  —  Method ∂ₜ(f) -> CTBase.var\"#114#116\"\n Partial derivative wrt time of a function. Example julia> ∂ₜ((t,x) -> t*x)(0,8)\n8"},{"id":172,"pagetitle":"CTBase API","title":"RecipesBase.plot!","ref":"/optimalcontrol/stable/#RecipesBase.plot!-Tuple{Plots.Plot, OptimalControlSolution}","content":" RecipesBase.plot!  —  Method plot!(\n    p::Plots.Plot,\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Plots.Plot\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate."},{"id":173,"pagetitle":"CTBase API","title":"RecipesBase.plot","ref":"/optimalcontrol/stable/#RecipesBase.plot-Tuple{OptimalControlSolution}","content":" RecipesBase.plot  —  Method plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Any\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate."},{"id":174,"pagetitle":"CTBase API","title":"CTBase.@Lie","ref":"/optimalcontrol/stable/#CTBase.@Lie-Tuple{Expr}","content":" CTBase.@Lie  —  Macro Macros for Lie and Poisson brackets Example julia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1,0,7])\n3.0"},{"id":175,"pagetitle":"CTBase API","title":"CTBase.@def","ref":"/optimalcontrol/stable/#CTBase.@def","content":" CTBase.@def  —  Macro Define an optimal control problem. One pass parsing of the definition. Example @def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend"},{"id":178,"pagetitle":"CTDirect API","title":"CTDirect API","ref":"/optimalcontrol/stable/#CTDirect-API","content":" CTDirect API This is just a dump of CTDirect API documentation. For more details about  CTDirect.jl  package, see the  documentation ."},{"id":179,"pagetitle":"CTDirect API","title":"Index","ref":"/optimalcontrol/stable/#Index","content":" Index CTDirect.OptimalControlInit CTDirect.available_methods CTDirect.is_solvable CTDirect.solve"},{"id":180,"pagetitle":"CTDirect API","title":"Documentation","ref":"/optimalcontrol/stable/#Documentation","content":" Documentation"},{"id":181,"pagetitle":"CTDirect API","title":"CTDirect.OptimalControlInit","ref":"/optimalcontrol/stable/#CTDirect.OptimalControlInit","content":" CTDirect.OptimalControlInit  —  Type Initialization of the optimal control problem solution for the NLP problem. Constructors: OptimalControlInit() : default initialization OptimalControlInit(x_init, u_init, v_init) : constant vector or function handles OptimalControlInit(sol) : from existing solution Examples julia> init = OptimalControlInit()\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3, v_init=0.5)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=t->sin(t), v_init=0.5)\njulia> init = OptimalControlInit(sol)"},{"id":182,"pagetitle":"CTDirect API","title":"CTDirect.available_methods","ref":"/optimalcontrol/stable/#CTDirect.available_methods-Tuple{}","content":" CTDirect.available_methods  —  Method available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n Return the list of available methods to solve the optimal control problem."},{"id":183,"pagetitle":"CTDirect API","title":"CTDirect.is_solvable","ref":"/optimalcontrol/stable/#CTDirect.is_solvable-Tuple{Any}","content":" CTDirect.is_solvable  —  Method is_solvable(ocp) -> Bool\n Return if the optimal control problem  ocp  is solvable or not by the method  solve ."},{"id":184,"pagetitle":"CTDirect API","title":"CTDirect.solve","ref":"/optimalcontrol/stable/#CTDirect.solve-Tuple{OptimalControlModel, Vararg{Any}}","content":" CTDirect.solve  —  Method solve(\n    ocp::OptimalControlModel,\n    description...;\n    display,\n    init,\n    grid_size,\n    print_level,\n    mu_strategy,\n    kwargs...\n) -> OptimalControlSolution\n Solve the the optimal control problem  ocp  by the method given by the (optional) description. Return an   OptimalControlSolution  from  CTBase  package, that is an approximation of  the optimal solution if the method has converged correctly. The (optional) description You can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list, the higher is the priority. Keyword arguments: display : print or not information during the resolution init : an initial condition for the solver grid_size : number of time steps for the discretization print_level : print level for the  Ipopt  solver mu_strategy : mu strategy for the  Ipopt  solver Warning There is only one available method for the moment: the direct method transforms the optimal control problem into a nonlinear programming problem (NLP) solved by  Ipopt , thanks to the package   ADNLPModels . Tip To see the list of available methods, simply call  available_methods() . You can pass any other option by a pair  keyword=value  according to the chosen method. See for instance,  Ipopt  options . The default values for the keyword arguments are given  here . julia> solve(ocp)\njulia> solve(ocp, :adnlp)\njulia> solve(ocp, :adnlp, :ipopt)\njulia> solve(ocp, display=false, init=OptimalControlInit(), grid_size=100, print_level=0, mu_strategy=\"adaptive\")"},{"id":187,"pagetitle":"CTFlows API","title":"CTFlows API","ref":"/optimalcontrol/stable/#CTFlows-API","content":" CTFlows API This is just a dump of CTFlows API documentation. For more details about  CTFlows.jl  package, see the  documentation ."},{"id":188,"pagetitle":"CTFlows API","title":"Index","ref":"/optimalcontrol/stable/#Index","content":" Index CTFlows.Flow CTFlows.Flow"},{"id":189,"pagetitle":"CTFlows API","title":"Documentation","ref":"/optimalcontrol/stable/#Documentation","content":" Documentation"},{"id":190,"pagetitle":"CTFlows API","title":"CTFlows.Flow","ref":"/optimalcontrol/stable/#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Union{ControlLaw{T, V}, FeedbackControl{T, V}, Function}, Union{MixedConstraint{T, V}, StateConstraint{T, V}, Function}, Union{Multiplier{T, V}, Function}}} where {T, V}","content":" CTFlows.Flow  —  Method Flow(\n    ocp::OptimalControlModel{T, V},\n    u_::Union{ControlLaw{T, V}, FeedbackControl{T, V}, Function},\n    g_::Union{MixedConstraint{T, V}, StateConstraint{T, V}, Function},\n    μ_::Union{Multiplier{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n Flow from an optimal control problem, a control function in feedback form, a state constraint and its  associated multiplier in feedback form. Example julia> ocp = Model(autonomous=false)\njulia> f = Flow(ocp, (t, x, p) -> p[1], (t, x, u) -> x[1] - 1, (t, x, p) -> x[1]+p[1]) Warning The time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem."},{"id":191,"pagetitle":"CTFlows API","title":"CTFlows.Flow","ref":"/optimalcontrol/stable/#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Union{ControlLaw{T, V}, Function}}} where {T, V}","content":" CTFlows.Flow  —  Method Flow(\n    ocp::OptimalControlModel{T, V},\n    u_::Union{ControlLaw{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n Flow from an optimal control problem and a control function in feedback form. Example julia> f = Flow(ocp, (x, p) -> p) Warning The time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem."},{"id":194,"pagetitle":"CTProblems API","title":"CTProblems API","ref":"/optimalcontrol/stable/#CTProblems-API","content":" CTProblems API This is just a dump of CTProblems API documentation. For more details about  CTProblems.jl  package, see the  documentation ."},{"id":195,"pagetitle":"CTProblems API","title":"Index","ref":"/optimalcontrol/stable/#Index","content":" Index CTProblems.CTProblems CTProblems.Problem CTProblems.Problems CTProblems.ProblemsDescriptions CTProblems.@Problems CTProblems.@ProblemsDescriptions"},{"id":196,"pagetitle":"CTProblems API","title":"Documentation","ref":"/optimalcontrol/stable/#Documentation","content":" Documentation"},{"id":197,"pagetitle":"CTProblems API","title":"CTProblems.CTProblems","ref":"/optimalcontrol/stable/#CTProblems.CTProblems","content":" CTProblems.CTProblems  —  Module CTProblems  module. Lists all the imported modules and packages: Base CTBase CTFlows Core DocStringExtensions ForwardDiff LinearAlgebra MINPACK OrdinaryDiffEq List of all the exported names: Problem @Problems Problems @ProblemsDescriptions ProblemsDescriptions plot"},{"id":198,"pagetitle":"CTProblems API","title":"CTProblems.Problem","ref":"/optimalcontrol/stable/#CTProblems.Problem-Tuple{Vararg{Symbol}}","content":" CTProblems.Problem  —  Method Problem(\n    description::Symbol...\n) -> CTProblems.OptimalControlProblem\n Return the optimal control problem described by  description . If you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority. Example julia> Problem(:integrator, :energy)"},{"id":199,"pagetitle":"CTProblems API","title":"CTProblems.Problems","ref":"/optimalcontrol/stable/#CTProblems.Problems-Tuple{Vararg{Symbol}}","content":" CTProblems.Problems  —  Method Problems(\n    description::Symbol...\n) -> Tuple{Vararg{CTProblems.OptimalControlProblem}}\n Return the list of optimal control problems consistent with the description. If you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority. Example julia> Problems(:integrator, :energy)"},{"id":200,"pagetitle":"CTProblems API","title":"CTProblems.ProblemsDescriptions","ref":"/optimalcontrol/stable/#CTProblems.ProblemsDescriptions-Tuple{Vararg{Symbol}}","content":" CTProblems.ProblemsDescriptions  —  Method ProblemsDescriptions(\n    description::Symbol...\n) -> Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n Return the list of problems descriptions consistent with the description, as a Tuple of Description.  Example julia> ProblemsDescriptions(:integrator, :energy)"},{"id":201,"pagetitle":"CTProblems API","title":"CTProblems.@Problems","ref":"/optimalcontrol/stable/#CTProblems.@Problems","content":" CTProblems.@Problems  —  Macro Return the list of problems consistent with the description. Example julia> @Problems :integrator & :energy Note You have to define a logical condition with the combination of symbols and the three  operators:  ! ,  |  and  & , respectively for the negation, the disjunction and the conjunction."},{"id":202,"pagetitle":"CTProblems API","title":"CTProblems.@ProblemsDescriptions","ref":"/optimalcontrol/stable/#CTProblems.@ProblemsDescriptions","content":" CTProblems.@ProblemsDescriptions  —  Macro Return the list of problems descriptions consistent with the expression. Example julia> @ProblemsDescriptions :integrator & :energy Note You have to define a logical condition with the combination of symbols and the three  operators:  ! ,  |  and  & , respectively for the negation, the disjunction and the conjunction."},{"id":205,"pagetitle":"API","title":"OptimalControl API","ref":"/optimalcontrol/stable/#OptimalControl-API","content":" OptimalControl API"},{"id":206,"pagetitle":"API","title":"Index","ref":"/optimalcontrol/stable/#Index","content":" Index OptimalControl.OptimalControl OptimalControl.available_methods OptimalControl.solve"},{"id":207,"pagetitle":"API","title":"Available methods","ref":"/optimalcontrol/stable/#Available-methods","content":" Available methods using OptimalControl\navailable_methods() (:direct, :adnlp, :ipopt)\n"},{"id":208,"pagetitle":"API","title":"Documentation","ref":"/optimalcontrol/stable/#Documentation","content":" Documentation"},{"id":209,"pagetitle":"API","title":"OptimalControl.OptimalControl","ref":"/optimalcontrol/stable/#OptimalControl.OptimalControl","content":" OptimalControl.OptimalControl  —  Module OptimalControl  module. Lists all the imported modules and packages: Base CTBase CTDirect CTFlows CTProblems Core DocStringExtensions List of all the exported names: * Autonomous ControlConstraint ControlLaw FeedbackControl Fixed Flow Hamiltonian HamiltonianLift HamiltonianVectorField Index @Lie Lie Lift MixedConstraint Model Multiplier NonAutonomous NonFixed ParsingError Poisson Problem @Problems Problems @ProblemsDescriptions ProblemsDescriptions StateConstraint VectorField available_methods constraint constraint! control! ct_repl @def dynamics! is_max is_min is_time_dependent is_time_independent is_variable_dependent is_variable_independent objective! plot plot! remove_constraint! solve state! time! variable! ∂ₜ ⋅ source"},{"id":210,"pagetitle":"API","title":"OptimalControl.available_methods","ref":"/optimalcontrol/stable/#OptimalControl.available_methods-Tuple{}","content":" OptimalControl.available_methods  —  Method available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n Return the list of available methods to solve the optimal control problem. source"},{"id":211,"pagetitle":"API","title":"OptimalControl.solve","ref":"/optimalcontrol/stable/#OptimalControl.solve-Tuple{OptimalControlModel, Vararg{Symbol}}","content":" OptimalControl.solve  —  Method solve(\n    ocp::OptimalControlModel,\n    description::Symbol...;\n    display,\n    init,\n    kwargs...\n) -> Union{Nothing, OptimalControlSolution}\n Solve the the optimal control problem  ocp  by the method given by the (optional) description. The (optional) description You can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list,  the higher is the priority. Keyword arguments: display : print or not information during the resolution init : an initial condition for the solver Warning There is only one available method for the moment: a direct method which transforms the optimal control problem into a nonlinear programming problem (NLP) solved by  Ipopt , thanks to the package   ADNLPModels . The direct method comes from the   CTDirect  package. Tip To see the list of available methods, simply call  available_methods() . You can pass any other option by a pair  keyword=value  according to the chosen method. Examples julia> sol = solve(ocp)\njulia> sol = solve(ocp, :direct)\njulia> sol = solve(ocp, :direct, :ipopt)\njulia> sol = solve(ocp, :direct, :ipopt, display=false)\njulia> sol = solve(ocp, :direct, :ipopt, display=false, init=sol)\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2],))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=0.5, variable=[1, 2]))\njulia> sol = solve(ocp, init=(state=[-0.5, 0.2], control=t->6-12*t))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=0.5))\njulia> sol = solve(ocp, init=(state=t->[-1+t, t*(t-1)], control=t->6-12*t)) source"},{"id":214,"pagetitle":"Introduction","title":"OptimalControl.jl","ref":"/optimalcontrol/stable/#OptimalControl.jl","content":" OptimalControl.jl The  OptimalControl.jl  package aims to provide tools to solve optimal control problems by direct and indirect methods. It is part of the  control-toolbox ecosystem : Install and documentation To install a package from the control-toolbox ecosystem,  please visit the  installation page . The documentation is accessible from the main menu. An optimal control problem with fixed initial and final times can be described as minimising the cost functional \\[g(x(t_0), x(t_f)) + \\int_{t_0}^{t_f} f^{0}(t, x(t), u(t))~\\mathrm{d}t\\] where the state  $x$  and the control  $u$  are functions subject, for  $t \\in [t_0, t_f]$ , to the differential constraint \\[   \\dot{x}(t) = f(t, x(t), u(t))\\] and other constraints such as \\[\\begin{array}{llcll}\n~\\xi_l  &\\le& \\xi(t, u(t))        &\\le& \\xi_u, \\\\\n\\eta_l &\\le& \\eta(t, x(t))       &\\le& \\eta_u, \\\\\n\\psi_l &\\le& \\psi(t, x(t), u(t)) &\\le& \\psi_u, \\\\\n\\phi_l &\\le& \\phi(t_0, x(t_0), t_f, x(t_f)) &\\le& \\phi_u.\n\\end{array}\\] See our tutorials to get started solving optimal control problems: Basic example : a simple smooth optimal control problem solved by the direct method. Advanced example : the  Goddard problem  solved by direct and indirect methods."},{"id":217,"pagetitle":"JuliaCon2023","title":"Solving optimal control problems with Julia","ref":"/optimalcontrol/stable/#Solving-optimal-control-problems-with-Julia","content":" Solving optimal control problems with Julia"},{"id":218,"pagetitle":"JuliaCon2023","title":"Jean-Baptiste Caillau ,  Olivier Cots ,  Joseph Gergaud ,  Pierre Martinon ,  Sophia Sed","ref":"/optimalcontrol/stable/#[Jean-Baptiste-Caillau](http://caillau.perso.math.cnrs.fr),-[Olivier-Cots](https://ocots.github.io),-[Joseph-Gergaud](https://scholar.google.com/citations?userpkH4An4AAAAJ-and-hlfr),-[Pierre-Martinon](https://www.linkedin.com/in/pierre-martinon-b4603a17),-[Sophia-Sed](https://iww.inria.fr/sed-sophia)","content":" Jean-Baptiste Caillau ,  Olivier Cots ,  Joseph Gergaud ,  Pierre Martinon ,  Sophia Sed"},{"id":219,"pagetitle":"JuliaCon2023","title":"What it's about","ref":"/optimalcontrol/stable/#What-it's-about","content":" What it's about Nonlinear optimal control of ODEs: \\[g(x(t_0),x(t_f)) + \\int_{t_0}^{t_f} f^0(x(t), u(t)) \\to \\min\\] subject to \\[\\dot{x}(t) = f(x(t), u(t)),\\quad t \\in [0, t_f]\\] plus boundary, control and state constraints Our core interests: numerical & geometrical methods in control, applications"},{"id":220,"pagetitle":"JuliaCon2023","title":"Where it comes from","ref":"/optimalcontrol/stable/#Where-it-comes-from","content":" Where it comes from BOCOP: the optimal control solver HamPath: indirect and Hamiltonian pathfollowing Coupling direct and indirect solvers, examples"},{"id":221,"pagetitle":"JuliaCon2023","title":"OptimalControl.jl","ref":"/optimalcontrol/stable/#OptimalControl.jl","content":" OptimalControl.jl Basic example: double integrator Basic example: double integrator (cont'ed) Advanced example: Goddard problem"},{"id":222,"pagetitle":"JuliaCon2023","title":"Wrap up","ref":"/optimalcontrol/stable/#Wrap-up","content":" Wrap up [X] High level modelling of optimal control problems [X] Efficient numerical resolution coupling direct and indirect methods [X] Collection of examples "},{"id":223,"pagetitle":"JuliaCon2023","title":"Future","ref":"/optimalcontrol/stable/#Future","content":" Future ct_repl Additional solvers: direct shooting, collocation for BVP, Hamiltonian pathfollowing... ... and open to contributions! CTProblems.jl"},{"id":224,"pagetitle":"JuliaCon2023","title":"control-toolbox.org","ref":"/optimalcontrol/stable/#control-toolbox.org","content":" control-toolbox.org Open toolbox Collection of Julia Packages rooted at  OptimalControl.jl"},{"id":225,"pagetitle":"JuliaCon2023","title":"Credits (not exhaustive!)","ref":"/optimalcontrol/stable/#Credits-(not-exhaustive!)","content":" Credits (not exhaustive!) DifferentialEquations.jl JuMP ,  InfiniteOpt.jl ,  ADNLPModels.jl Ipopt JuliaDiff  ( FowardDiff.jl ,  Zygote.jl ) MLStyle.jl REPLMaker.jl"},{"id":226,"pagetitle":"JuliaCon2023","title":"caseazatmiftakhov.org  (2019-)","ref":"/optimalcontrol/stable/#[caseazatmiftakhov.org](https://caseazatmiftakhov.org)-(2019-)","content":" caseazatmiftakhov.org  (2019-)"},{"id":231,"pagetitle":"Basic example (functional version)","title":"Basic example (functional version)","ref":"/optimalcontrol/stable/#basic-f","content":" Basic example (functional version) Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force  $u$ . We denote by  $x = (x_1, x_2)$  the state of the wagon, that is its position  $x_1$  and its velocity  $x_2$ . We assume that the mass is constant and unitary and that there is no friction. The dynamics is thus given by \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t) \\in \\mathbb{R},\\] which is simply the  double integrator  system. Les us consider a transfer starting at time  $t_0 = 0$  and ending at time  $t_f = 1$ , for which we want to minimise the transfer energy \\[    \\frac{1}{2}\\int_{0}^{1} u^2(t) \\, \\mathrm{d}t\\] starting from the condition  $x(0) = (-1, 0)$  and with the goal to reach the target  $x(1) = (0, 0)$ . Solution and details See the page   Double integrator: energy minimisation   for the analytical solution and details about this problem. First, we need to import the  OptimalControl.jl  package: using OptimalControl Then, we can define the problem ocp = Model()\n\ntime!(ocp, [ 0, 1 ])\nstate!(ocp, 2)\ncontrol!(ocp, 1)\n\nconstraint!(ocp, :initial, [ -1, 0 ])\nconstraint!(ocp, :final,   [  0, 0 ])\n\ndynamics!(ocp, (x, u) -> [ x[2], u ])\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2) Solve it sol = solve(ocp) Method = (:direct, :adnlp, :ipopt)\nThis is Ipopt version 3.14.13, running with linear solver MUMPS 5.6.0.\n\nNumber of nonzeros in equality constraint Jacobian...:     1205\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:      101\n\nTotal number of variables............................:      404\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      305\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0000000e-01 1.10e+00 1.92e-14   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1 -5.0000000e-03 1.81e-01 1.78e-15 -11.0 6.04e+00    -  1.00e+00 1.00e+00h  1\n   2  6.0023829e+00 8.88e-16 1.78e-15 -11.0 6.01e+00    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 2\n\n                                   (scaled)                 (unscaled)\nObjective...............:   6.0023829460295719e+00    6.0023829460295719e+00\nDual infeasibility......:   1.7763568394002505e-15    1.7763568394002505e-15\nConstraint violation....:   8.8817841970012523e-16    8.8817841970012523e-16\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00\nOverall NLP error.......:   1.7763568394002505e-15    1.7763568394002505e-15\n\n\nNumber of objective function evaluations             = 3\nNumber of objective gradient evaluations             = 3\nNumber of equality constraint evaluations            = 3\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 3\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 2\nTotal seconds in IPOPT                               = 3.202\n\nEXIT: Optimal Solution Found. and plot the solution plot(sol, size=(600, 450))"},{"id":234,"pagetitle":"Basic example","title":"Basic example","ref":"/optimalcontrol/stable/#basic","content":" Basic example Let us consider a wagon moving along a rail, whom acceleration can be controlled by a force  $u$ . We denote by  $x = (x_1, x_2)$  the state of the wagon, that is its position  $x_1$  and its velocity  $x_2$ . We assume that the mass is constant and unitary and that there is no friction. The dynamics is thus given by \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t) \\in \\mathbb{R},\\] which is simply the  double integrator  system. Les us consider a transfer starting at time  $t_0 = 0$  and ending at time  $t_f = 1$ , for which we want to minimise the transfer energy \\[    \\frac{1}{2}\\int_{0}^{1} u^2(t) \\, \\mathrm{d}t\\] starting from the condition  $x(0) = (-1, 0)$  and with the goal to reach the target  $x(1) = (0, 0)$ . Solution and details See the page   Double integrator: energy minimisation   for the analytical solution and details about this problem. First, we need to import the  OptimalControl.jl  package: using OptimalControl Then, we can define the problem @def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R², state\n    u ∈ R, control\n    x(0) == [ -1, 0 ]\n    x(1) == [ 0, 0 ]\n    ẋ(t) == [ x₂(t), u(t) ]\n    ∫( 0.5u(t)^2 ) → min\nend\n Solve it sol = solve(ocp) Method = (:direct, :adnlp, :ipopt)\nThis is Ipopt version 3.14.13, running with linear solver MUMPS 5.6.0.\n\nNumber of nonzeros in equality constraint Jacobian...:     1205\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:      101\n\nTotal number of variables............................:      404\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      305\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  1.0000000e-01 1.10e+00 1.92e-14   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1 -5.0000000e-03 1.81e-01 1.78e-15 -11.0 6.04e+00    -  1.00e+00 1.00e+00h  1\n   2  6.0023829e+00 8.88e-16 1.78e-15 -11.0 6.01e+00    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 2\n\n                                   (scaled)                 (unscaled)\nObjective...............:   6.0023829460295719e+00    6.0023829460295719e+00\nDual infeasibility......:   1.7763568394002505e-15    1.7763568394002505e-15\nConstraint violation....:   8.8817841970012523e-16    8.8817841970012523e-16\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00\nOverall NLP error.......:   1.7763568394002505e-15    1.7763568394002505e-15\n\n\nNumber of objective function evaluations             = 3\nNumber of objective gradient evaluations             = 3\nNumber of equality constraint evaluations            = 3\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 3\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 2\nTotal seconds in IPOPT                               = 0.089\n\nEXIT: Optimal Solution Found. and plot the solution plot(sol, size=(600, 450))"},{"id":237,"pagetitle":"Repl","title":"Repl","ref":"/optimalcontrol/stable/#Repl","content":" Repl See  ct_repl  method."},{"id":240,"pagetitle":"Flows","title":"Flows","ref":"/optimalcontrol/stable/#Flows","content":" Flows See the page  CTFlows ."},{"id":243,"pagetitle":"Advanced example","title":"Advanced example","ref":"/optimalcontrol/stable/#goddard","content":" Advanced example"},{"id":244,"pagetitle":"Advanced example","title":"Introduction","ref":"/optimalcontrol/stable/#Introduction","content":" Introduction For this advanced example, we consider the well-known Goddard problem [1] [2]  which models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude  $r$ , speed  $v$  and mass  $m$  of the rocket during the flight, for a total dimension of 3. The rocket is subject to gravity  $g$ , thrust  $u$  and drag force  $D$  (function of speed and altitude). The final time  $t_f$  is free, and the objective is to reach a maximal altitude with a bounded fuel consumption. We thus want to solve the optimal control problem in Mayer form \\[    r(t_f) \\to \\max\\] subject to the controlled dynamics \\[    \\dot{r} = v, \\quad\n    \\dot{v} = \\frac{T_{\\max}\\,u - D(r,v)}{m} - g, \\quad\n    \\dot{m} = -u,\\] and subject to the control constraint  $u(t) \\in [0,1]$  and the state constraint  $v(t) \\leq v_{\\max}$ . The initial state is fixed while only the final mass is prescribed. Note The Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below)."},{"id":245,"pagetitle":"Advanced example","title":"Direct method","ref":"/optimalcontrol/stable/#Direct-method","content":" Direct method We import the  OptimalControl.jl  package: using OptimalControl We define the problem t0 = 0      # initial time\nr0 = 1      # initial altitude\nv0 = 0      # initial speed\nm0 = 1      # initial mass\nvmax = 0.1  # maximal authorized speed\nmf = 0.6    # final mass to target\n\n@def ocp begin # definition of the optimal control problem\n\n    tf, variable\n    t ∈ [ t0, tf ], time\n    x ∈ R³, state\n    u ∈ R, control\n\n    r = x₁\n    v = x₂\n    m = x₃\n\n    x(t0) == [ r0, v0, m0 ]\n    m(tf) == mf,         (1)\n    0 ≤ u(t) ≤ 1\n    r(t) ≥ r0\n    0 ≤ v(t) ≤ vmax\n\n    ẋ(t) == F0(x(t)) + u(t) * F1(x(t))\n\n    r(tf) → max\n\nend;\n\n# Dynamics\nconst Cd = 310\nconst Tmax = 3.5\nconst β = 500\nconst b = 2\n\nF0(x) = begin\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1)) # Drag force\n    return [ v, -D/m - 1/r^2, 0 ]\nend\n\nF1(x) = begin\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend We then solve it direct_sol = solve(ocp, grid_size=100) Method = (:direct, :adnlp, :ipopt)\nThis is Ipopt version 3.14.13, running with linear solver MUMPS 5.6.0.\n\nNumber of nonzeros in equality constraint Jacobian...:     1904\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:     1111\n\nTotal number of variables............................:      405\n                     variables with only lower bounds:      101\n                variables with lower and upper bounds:      202\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:      304\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0 -1.0100000e+00 9.00e-01 2.00e+00   0.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1 -1.0090670e+00 8.99e-01 6.67e+01   1.3 1.67e+02    -  3.64e-03 5.93e-04f  1\n   2 -1.0000907e+00 8.74e-01 1.83e+02   1.0 6.64e+00    -  3.63e-02 2.83e-02h  1\n   3 -1.0023670e+00 8.37e-01 1.34e+04   1.0 6.91e+00    -  2.11e-01 4.19e-02f  1\n   4 -1.0025025e+00 7.70e-01 9.45e+03   1.5 4.04e+00    -  1.00e+00 8.09e-02f  1\n   5 -1.0033626e+00 7.16e-01 1.48e+05   2.3 3.56e+00    -  3.73e-01 6.94e-02f  1\n   6 -1.0142503e+00 9.62e-03 3.99e+04   2.3 7.16e-01    -  4.49e-01 9.90e-01h  1\n   7 -1.0101264e+00 4.21e-03 4.24e+05   1.8 5.32e-01    -  5.03e-01 9.90e-01h  1\n   8 -1.0068427e+00 3.20e-04 2.87e+06   0.9 2.44e-01    -  6.73e-01 9.91e-01h  1\n   9 -1.0067336e+00 2.64e-06 2.30e+07   0.1 7.39e-02    -  7.07e-01 1.00e+00f  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  10 -1.0067340e+00 1.13e-10 6.50e+05  -5.0 2.90e-04    -  9.89e-01 1.00e+00h  1\n  11 -1.0067350e+00 2.81e-10 7.20e+03  -7.0 4.26e-04    -  9.89e-01 1.00e+00h  1\n  12 -1.0078967e+00 9.07e-04 5.95e+03  -3.0 7.61e-01    -  6.55e-01 7.21e-01f  1\n  13 -1.0081866e+00 3.67e-06 9.38e+03  -9.0 1.31e-02    -  8.60e-01 1.00e+00h  1\n  14 -1.0091814e+00 1.57e-04 1.79e+02  -4.6 2.18e-01    -  1.00e+00 9.28e-01h  1\n  15 -1.0105115e+00 2.55e-04 7.17e+02  -4.4 3.09e-01    -  1.00e+00 5.75e-01h  1\n  16 -1.0114149e+00 2.34e-05 7.98e-04  -5.1 4.29e-02    -  1.00e+00 1.00e+00h  1\n  17 -1.0122891e+00 7.90e-05 1.24e+02  -5.8 1.25e-01    -  9.98e-01 7.92e-01h  1\n  18 -1.0125091e+00 2.83e-05 4.85e-04  -6.1 1.06e-01    -  1.00e+00 1.00e+00h  1\n  19 -1.0125585e+00 1.21e-05 8.67e-05  -6.8 1.01e-01    -  1.00e+00 1.00e+00h  1\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n  20 -1.0125675e+00 4.40e-06 3.01e-05  -7.3 9.80e-02    -  1.00e+00 1.00e+00h  1\n  21 -1.0125707e+00 1.75e-06 3.70e-02  -8.0 1.14e-01    -  1.00e+00 9.91e-01h  1\n  22 -1.0125714e+00 9.50e-07 4.98e-03  -8.6 1.37e-01    -  1.00e+00 9.94e-01h  1\n  23 -1.0125716e+00 5.06e-08 6.91e-04  -9.3 2.57e-02    -  1.00e+00 9.96e-01h  1\n  24 -1.0125716e+00 1.25e-10 1.08e-09 -11.0 2.15e-03    -  1.00e+00 1.00e+00h  1\n\nNumber of Iterations....: 24\n\n                                   (scaled)                 (unscaled)\nObjective...............:  -1.0125716188789131e+00   -1.0125716188789131e+00\nDual infeasibility......:   1.0759941386357690e-09    1.0759941386357690e-09\nConstraint violation....:   1.5779155759787500e-11    1.2476877864209257e-10\nVariable bound violation:   6.1594570555101313e-09    6.1594570555101313e-09\nComplementarity.........:   1.5140175163848740e-11    1.5140175163848740e-11\nOverall NLP error.......:   1.5779155759787500e-11    1.0759941386357690e-09\n\n\nNumber of objective function evaluations             = 25\nNumber of objective gradient evaluations             = 25\nNumber of equality constraint evaluations            = 25\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 25\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 24\nTotal seconds in IPOPT                               = 3.218\n\nEXIT: Optimal Solution Found. and plot the solution plt = plot(direct_sol, size=(600, 600))"},{"id":246,"pagetitle":"Advanced example","title":"Indirect method","ref":"/optimalcontrol/stable/#Indirect-method","content":" Indirect method We first determine visually the structure of the optimal solution which is composed of a bang arc with maximal control, followed by a singular arc, then by a boundary arc and the final arc is with zero control. Note that the switching function vanishes along the singular and boundary arcs. t = direct_sol.times\nx = direct_sol.state\nu = direct_sol.control\np = direct_sol.costate\n\nH1 = Lift(F1)           # H1(x, p) = p' * F1(x)\nφ(t) = H1(x(t), p(t))   # switching function\ng(x) = vmax - x[2]      # state constraint v ≤ vmax\n\nu_plot  = plot(t, u,     label = \"u(t)\")\nH1_plot = plot(t, φ,     label = \"H₁(x(t), p(t))\")\ng_plot  = plot(t, g ∘ x, label = \"g(x(t))\")\n\nplot(u_plot, H1_plot, g_plot, layout=(3,1), size=(600,450)) We are now in position to solve the problem by an indirect shooting method. We first define the four control laws in feedback form and their associated flows. For this we need to compute some Lie derivatives, namely  Poisson brackets  of Hamiltonians (themselves obtained as lifts to the cotangent bundle of vector fields), or derivatives of functions along a vector field. For instance, the control along the  minimal order  singular arcs is obtained as the quotient \\[u_s = -\\frac{H_{001}}{H_{101}}\\] of length three Poisson brackets: \\[H_{001} = \\{H_0,\\{H_0,H_1\\}\\}, \\quad H_{101} = \\{H_1,\\{H_0,H_1\\}\\}\\] where, for two Hamiltonians  $H$  and  $G$ , \\[\\{H,G\\} := (\\nabla_p H|\\nabla_x G) - (\\nabla_x H|\\nabla_p G).\\] While the Lie derivative of a function  $f$ wrt.  a vector field  $X$  is simply obtained as \\[(X \\cdot f)(x) := f'(x) \\cdot X(x),\\] and is used to the compute the control along the boundary arc, \\[u_b(x) = -(F_0 \\cdot g)(x) / (F_1 \\cdot g)(x),\\] as well as the associated multiplier for the  order one  state constraint on the velocity: \\[\\mu(x, p) = H_{01}(x, p) / (F_1 \\cdot g)(x).\\] Note The Poisson bracket  $\\{H,G\\}$  is also given by the Lie derivative of  $G$  along the Hamiltonian vector field  $X_H = (\\nabla_p H, -\\nabla_x H)$  of  $H$ , that is \\[    \\{H,G\\} = X_H \\cdot G\\] which is the reason why we use the  @Lie  macro to compute Poisson brackets below. With the help of the  differential geometry primitives  from  CTBase.jl , these expressions are straightforwardly translated into Julia code: # Controls\nu0 = 0                                  # off control\nu1 = 1                                  # bang control\n\nH0 = Lift(F0)                           # H0(x, p) = p' * F0(x)\nH01  = @Lie { H0, H1 }\nH001 = @Lie { H0, H01 }\nH101 = @Lie { H1, H01 }\nus(x, p) = -H001(x, p) / H101(x, p)     # singular control\n\nub(x) = -(F0⋅g)(x) / (F1⋅g)(x)          # boundary control\nμ(x, p) = H01(x, p) / (F1⋅g)(x)         # multiplier associated to the state constraint g\n\n# Flows\nf0 = Flow(ocp, (x, p, tf) -> u0)\nf1 = Flow(ocp, (x, p, tf) -> u1)\nfs = Flow(ocp, (x, p, tf) -> us(x, p))\nfb = Flow(ocp, (x, p, tf) -> ub(x), (x, u, tf) -> g(x), (x, p, tf) -> μ(x, p)) Then, we define the shooting function according to the optimal structure we have determined, that is a concatenation of four arcs. x0 = [ r0, v0, m0 ] # initial state\n\nfunction shoot!(s, p0, t1, t2, t3, tf)\n\n    x1, p1 = f1(t0, x0, p0, t1)\n    x2, p2 = fs(t1, x1, p1, t2)\n    x3, p3 = fb(t2, x2, p2, t3)\n    xf, pf = f0(t3, x3, p3, tf)\n\n    s[1] = constraint(ocp, :eq1)(x0, xf, tf) - mf # final mass constraint (1)\n    s[2:3] = pf[1:2] - [ 1, 0 ]                   # transversality conditions\n    s[4] = H1(x1, p1)                             # H1 = H01 = 0\n    s[5] = H01(x1, p1)                            # at the entrance of the singular arc\n    s[6] = g(x2)                                  # g = 0 when entering the boundary arc\n    s[7] = H0(xf, pf)                             # since tf is free\n\nend To solve the problem by an indirect shooting method, we then need a good initial guess, that is a good approximation of the initial costate, the three switching times and the final time. η = 1e-3\nt13 = t[ abs.(φ.(t)) .≤ η ]\nt23 = t[ 0 .≤ (g ∘ x).(t) .≤ η ]\np0 = p(t0)\nt1 = min(t13...)\nt2 = min(t23...)\nt3 = max(t23...)\ntf = t[end]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\nusing LinearAlgebra: norm\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\") p0 = [3.9420913558122708, 0.14627140398405294, 0.05411785715966011]\nt1 = 0.01817850265880542\nt2 = 0.06059500886268473\nt3 = 0.07877351152149016\ntf = 0.20198336287561577\nNorm of the shooting function: ‖s‖ = 3.2498553744036016 Finally, we can solve the shooting equations thanks to the  MINPACK  solver. using MINPACK                                               # NLE solver\n\nnle = (s, ξ) -> shoot!(s, ξ[1:3], ξ[4], ξ[5], ξ[6], ξ[7])   # auxiliary function\n                                                            # with aggregated inputs\nξ = [ p0 ; t1 ; t2 ; t3 ; tf ]                              # initial guess\nfsolve(nle, ξ)\n\n# we retrieve the costate solution together with the times\np0 = indirect_sol.x[1:3]\nt1 = indirect_sol.x[4]\nt2 = indirect_sol.x[5]\nt3 = indirect_sol.x[6]\ntf = indirect_sol.x[7]\n\nprintln(\"p0 = \", p0)\nprintln(\"t1 = \", t1)\nprintln(\"t2 = \", t2)\nprintln(\"t3 = \", t3)\nprintln(\"tf = \", tf)\n\n# Norm of the shooting function at solution\ns = similar(p0, 7)\nshoot!(s, p0, t1, t2, t3, tf)\nprintln(\"Norm of the shooting function: ‖s‖ = \", norm(s), \"\\n\") p0 = [3.9457646577517123, 0.15039559614214312, 0.05371271288910641]\nt1 = 0.0235096840748443\nt2 = 0.0597373808209678\nt3 = 0.10157134843333115\ntf = 0.2020474405557245\nNorm of the shooting function: ‖s‖ = 3.4320625295698935e-9 We plot the solution of the indirect solution (in red) over the solution of the direct method (in blue). f = f1 * (t1, fs) * (t2, fb) * (t3, f0) # concatenation of the flows\nflow_sol = f((t0, tf), x0, p0)          # compute the solution: state, costate, control...\n\nplot!(plt, flow_sol)"},{"id":247,"pagetitle":"Advanced example","title":"References","ref":"/optimalcontrol/stable/#References","content":" References 1 R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919. 2 H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993."},{"id":250,"pagetitle":"Initialisation","title":"Initialisation","ref":"/optimalcontrol/stable/#Initialisation","content":" Initialisation See  solve  method."},{"id":253,"pagetitle":"Indirect simple shooting","title":"Indirect simple shooting","ref":"/optimalcontrol/stable/#Indirect-simple-shooting","content":" Indirect simple shooting In construction."},{"id":256,"pagetitle":"Modelling","title":"Modelling","ref":"/optimalcontrol/stable/#Modelling","content":" Modelling See  OptimalControlModel  type."},{"id":259,"pagetitle":"Plot solution","title":"Plot solution","ref":"/optimalcontrol/stable/#Plot-solution","content":" Plot solution See  plot  method."},{"id":262,"pagetitle":"Test problems","title":"Test problems","ref":"/optimalcontrol/stable/#Test-problems","content":" Test problems See the page  CTProblems ."},{"id":265,"pagetitle":"Solvers and options","title":"Solvers and options","ref":"/optimalcontrol/stable/#Solvers-and-options","content":" Solvers and options See  solve  method."},{"id":268,"pagetitle":"Callbacks","title":"Callbacks","ref":"/ctbase/stable/#Callbacks","content":" Callbacks"},{"id":269,"pagetitle":"Callbacks","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.CTCallback CTBase.CTCallbacks CTBase.PrintCallback CTBase.PrintCallback CTBase.StopCallback CTBase.StopCallback CTBase.get_priority_print_callbacks CTBase.get_priority_stop_callbacks"},{"id":270,"pagetitle":"Callbacks","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":271,"pagetitle":"Callbacks","title":"CTBase.CTCallback","ref":"/ctbase/stable/#CTBase.CTCallback","content":" CTBase.CTCallback  —  Type abstract type CTCallback Abstract type for callbacks. source"},{"id":272,"pagetitle":"Callbacks","title":"CTBase.CTCallbacks","ref":"/ctbase/stable/#CTBase.CTCallbacks","content":" CTBase.CTCallbacks  —  Type Tuple of callbacks source"},{"id":273,"pagetitle":"Callbacks","title":"CTBase.PrintCallback","ref":"/ctbase/stable/#CTBase.PrintCallback","content":" CTBase.PrintCallback  —  Type mutable struct PrintCallback <: CTCallback Callback for printing. source"},{"id":274,"pagetitle":"Callbacks","title":"CTBase.PrintCallback","ref":"/ctbase/stable/#CTBase.PrintCallback-Tuple","content":" CTBase.PrintCallback  —  Method Call the callback. source"},{"id":275,"pagetitle":"Callbacks","title":"CTBase.StopCallback","ref":"/ctbase/stable/#CTBase.StopCallback","content":" CTBase.StopCallback  —  Type Stopping callback. source"},{"id":276,"pagetitle":"Callbacks","title":"CTBase.StopCallback","ref":"/ctbase/stable/#CTBase.StopCallback-Tuple","content":" CTBase.StopCallback  —  Method Call the callback. source"},{"id":277,"pagetitle":"Callbacks","title":"CTBase.get_priority_print_callbacks","ref":"/ctbase/stable/#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_print_callbacks  —  Method get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority print callbacks. source"},{"id":278,"pagetitle":"Callbacks","title":"CTBase.get_priority_stop_callbacks","ref":"/ctbase/stable/#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_stop_callbacks  —  Method get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority stop callbacks. source"},{"id":281,"pagetitle":"Checkings","title":"Checkings","ref":"/ctbase/stable/#Checkings","content":" Checkings"},{"id":282,"pagetitle":"Checkings","title":"Index","ref":"/ctbase/stable/#Index","content":" Index"},{"id":283,"pagetitle":"Checkings","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":286,"pagetitle":"CTBase.jl","title":"CTBase.jl","ref":"/ctbase/stable/#CTBaseModule","content":" CTBase.jl"},{"id":287,"pagetitle":"CTBase.jl","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.CTBase CTBase.Control CTBase.Controls CTBase.Costate CTBase.Costates CTBase.DCostate CTBase.DState CTBase.Dimension CTBase.State CTBase.States CTBase.Time CTBase.Times CTBase.TimesDisc CTBase.Variable CTBase.ctNumber CTBase.ctVector"},{"id":288,"pagetitle":"CTBase.jl","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":289,"pagetitle":"CTBase.jl","title":"CTBase.CTBase","ref":"/ctbase/stable/#CTBase.CTBase","content":" CTBase.CTBase  —  Module CTBase  module. Lists all the imported modules and packages: Base Core DataStructures DocStringExtensions LinearAlgebra MLStyle Parameters Plots PrettyTables Printf ReplMaker Unicode List of all the exported names: AbstractHamiltonian AmbiguousDescription Autonomous BoundaryConstraint CTCallback CTCallbacks CTException Control ControlConstraint ControlLaw Controls Costate Costates DCostate DState Description Dimension Dynamics FeedbackControl Fixed Hamiltonian HamiltonianLift HamiltonianVectorField IncorrectArgument IncorrectMethod IncorrectOutput Index Lagrange @Lie Lie Lift Mayer MixedConstraint Model Multiplier NonAutonomous NonFixed NotImplemented OptimalControlModel OptimalControlSolution ParsingError Poisson PrintCallback State StateConstraint States StopCallback Time TimeDependence Times TimesDisc UnauthorizedCall Variable VariableConstraint VariableDependence VectorField add constraint constraint! constraint_type constraints_labels control! ctNumber ctVector ct_repl ctgradient ctindices ctinterpolate ctjacobian ctupperscripts @def dynamics! getFullDescription get_priority_print_callbacks get_priority_stop_callbacks is_max is_min is_time_dependent is_time_independent is_variable_dependent is_variable_independent nlp_constraints objective! plot plot! remove_constraint! replace_call state! time! variable! ∂ₜ ⋅ source"},{"id":290,"pagetitle":"CTBase.jl","title":"CTBase.Control","ref":"/ctbase/stable/#CTBase.Control","content":" CTBase.Control  —  Type Type alias for a control. source"},{"id":291,"pagetitle":"CTBase.jl","title":"CTBase.Costate","ref":"/ctbase/stable/#CTBase.Costate","content":" CTBase.Costate  —  Type Type alias for an costate. source"},{"id":292,"pagetitle":"CTBase.jl","title":"CTBase.DCostate","ref":"/ctbase/stable/#CTBase.DCostate","content":" CTBase.DCostate  —  Type Type alias for a tangent vector to the costate space. source"},{"id":293,"pagetitle":"CTBase.jl","title":"CTBase.DState","ref":"/ctbase/stable/#CTBase.DState","content":" CTBase.DState  —  Type Type alias for a tangent vector to the state space. source"},{"id":294,"pagetitle":"CTBase.jl","title":"CTBase.State","ref":"/ctbase/stable/#CTBase.State","content":" CTBase.State  —  Type Type alias for a state. source"},{"id":295,"pagetitle":"CTBase.jl","title":"CTBase.TimesDisc","ref":"/ctbase/stable/#CTBase.TimesDisc","content":" CTBase.TimesDisc  —  Type Type alias for a grid of times. source"},{"id":296,"pagetitle":"CTBase.jl","title":"CTBase.Variable","ref":"/ctbase/stable/#CTBase.Variable","content":" CTBase.Variable  —  Type Type alias for a variable. source"},{"id":297,"pagetitle":"CTBase.jl","title":"CTBase.ctVector","ref":"/ctbase/stable/#CTBase.ctVector","content":" CTBase.ctVector  —  Type Type alias for a vector of real numbers. source"},{"id":298,"pagetitle":"CTBase.jl","title":"CTBase.Controls","ref":"/ctbase/stable/#CTBase.Controls","content":" CTBase.Controls  —  Type Type alias for a vector of controls. source"},{"id":299,"pagetitle":"CTBase.jl","title":"CTBase.Costates","ref":"/ctbase/stable/#CTBase.Costates","content":" CTBase.Costates  —  Type Type alias for a vector of costates. source"},{"id":300,"pagetitle":"CTBase.jl","title":"CTBase.Dimension","ref":"/ctbase/stable/#CTBase.Dimension","content":" CTBase.Dimension  —  Type Type alias for a dimension. source"},{"id":301,"pagetitle":"CTBase.jl","title":"CTBase.States","ref":"/ctbase/stable/#CTBase.States","content":" CTBase.States  —  Type Type alias for a vector of states. source"},{"id":302,"pagetitle":"CTBase.jl","title":"CTBase.Time","ref":"/ctbase/stable/#CTBase.Time","content":" CTBase.Time  —  Type Type alias for a time. source"},{"id":303,"pagetitle":"CTBase.jl","title":"CTBase.Times","ref":"/ctbase/stable/#CTBase.Times","content":" CTBase.Times  —  Type Type alias for a vector of times. source"},{"id":304,"pagetitle":"CTBase.jl","title":"CTBase.ctNumber","ref":"/ctbase/stable/#CTBase.ctNumber","content":" CTBase.ctNumber  —  Type Type alias for a real number. source"},{"id":307,"pagetitle":"Repl","title":"Repl","ref":"/ctbase/stable/#Repl","content":" Repl"},{"id":308,"pagetitle":"Repl","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.ct_repl"},{"id":309,"pagetitle":"Repl","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":310,"pagetitle":"Repl","title":"CTBase.ct_repl","ref":"/ctbase/stable/#CTBase.ct_repl-Tuple{}","content":" CTBase.ct_repl  —  Method ct_repl(; debug, demo) -> Any\n Create a ct REPL. source"},{"id":313,"pagetitle":"Default","title":"Default","ref":"/ctbase/stable/#Default","content":" Default"},{"id":314,"pagetitle":"Default","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.__callbacks CTBase.__constraint_label CTBase.__control_components_names CTBase.__control_name CTBase.__criterion_type CTBase.__display CTBase.__fun_time_dependence CTBase.__fun_variable_dependence CTBase.__init_interpolation CTBase.__matrix_dimension_stock CTBase.__mu_strategy_ipopt CTBase.__ocp_time_dependence CTBase.__ocp_variable_dependence CTBase.__print_level_ipopt CTBase.__state_components_names CTBase.__state_name CTBase.__time_name CTBase.__variable_components_names CTBase.__variable_name"},{"id":315,"pagetitle":"Default","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":316,"pagetitle":"Default","title":"CTBase.__callbacks","ref":"/ctbase/stable/#CTBase.__callbacks-Tuple{}","content":" CTBase.__callbacks  —  Method __callbacks() -> Tuple{}\n Used to set the default value of the callbacks argument. The default value is  () , which means that no additional callback is given. source"},{"id":317,"pagetitle":"Default","title":"CTBase.__constraint_label","ref":"/ctbase/stable/#CTBase.__constraint_label-Tuple{}","content":" CTBase.__constraint_label  —  Method __constraint_label() -> Symbol\n Used to set the default value of the label of a constraint. A unique value is given to each constraint using the  gensym  function and prefixing by  :unamed . source"},{"id":318,"pagetitle":"Default","title":"CTBase.__control_components_names","ref":"/ctbase/stable/#CTBase.__control_components_names-Tuple{Integer, String}","content":" CTBase.__control_components_names  —  Method __control_components_names(m::Integer, name::String) -> Any\n Used to set the default value of the names of the controls. The default value is  [\"u\"]  for a one dimensional control, and  [\"u₁\", \"u₂\", ...]  for a multi dimensional control. source"},{"id":319,"pagetitle":"Default","title":"CTBase.__control_name","ref":"/ctbase/stable/#CTBase.__control_name-Tuple{}","content":" CTBase.__control_name  —  Method __control_name() -> String\n Used to set the default value of the names of the control. The default value is  \"u\" . source"},{"id":320,"pagetitle":"Default","title":"CTBase.__criterion_type","ref":"/ctbase/stable/#CTBase.__criterion_type-Tuple{}","content":" CTBase.__criterion_type  —  Method __criterion_type() -> Symbol\n Used to set the default value of the type of criterion. Either :min or :max. The default value is  :min . The other possible criterion type is  :max . source"},{"id":321,"pagetitle":"Default","title":"CTBase.__display","ref":"/ctbase/stable/#CTBase.__display-Tuple{}","content":" CTBase.__display  —  Method __display() -> Bool\n Used to set the default value of the display argument. The default value is  true , which means that the output is printed during resolution. source"},{"id":322,"pagetitle":"Default","title":"CTBase.__fun_time_dependence","ref":"/ctbase/stable/#CTBase.__fun_time_dependence-Tuple{}","content":" CTBase.__fun_time_dependence  —  Method __fun_time_dependence() -> Type{Autonomous}\n Used to set the default value of the time dependence of the functions. The default value is  Autonomous , which means that the functions are considered time independent. The other possible time dependence is  NonAutonomous , which means that the functions are considered time dependent. source"},{"id":323,"pagetitle":"Default","title":"CTBase.__fun_variable_dependence","ref":"/ctbase/stable/#CTBase.__fun_variable_dependence-Tuple{}","content":" CTBase.__fun_variable_dependence  —  Method __fun_variable_dependence() -> Type{Fixed}\n Used to set the default value of the variable dependence of the functions. The default value is  Fixed , which means that the functions are considered variable independent. The other possible variable dependence is  NonFixed , which means that the functions are considered variable dependent. source"},{"id":324,"pagetitle":"Default","title":"CTBase.__init_interpolation","ref":"/ctbase/stable/#CTBase.__init_interpolation-Tuple{}","content":" CTBase.__init_interpolation  —  Method __init_interpolation() -> CTBase.var\"#13#14\"\n Used to set the default interpolation function used for initialisation. The default value is  Interpolations.linear_interpolation , which means that the initial guess is linearly interpolated. source"},{"id":325,"pagetitle":"Default","title":"CTBase.__matrix_dimension_stock","ref":"/ctbase/stable/#CTBase.__matrix_dimension_stock-Tuple{}","content":" CTBase.__matrix_dimension_stock  —  Method __matrix_dimension_stock() -> Int64\n Used to set the default value of the stockage of elements in a matrix. The default value is  1 . source"},{"id":326,"pagetitle":"Default","title":"CTBase.__mu_strategy_ipopt","ref":"/ctbase/stable/#CTBase.__mu_strategy_ipopt-Tuple{}","content":" CTBase.__mu_strategy_ipopt  —  Method __mu_strategy_ipopt() -> String\n Used to set the default value of the μ strategy of ipopt for the direct method. The default value is  adaptive . source"},{"id":327,"pagetitle":"Default","title":"CTBase.__ocp_time_dependence","ref":"/ctbase/stable/#CTBase.__ocp_time_dependence-Tuple{}","content":" CTBase.__ocp_time_dependence  —  Method __ocp_time_dependence() -> Type{Autonomous}\n Used to set the default value of the time dependence of the Optimal Control Problem. The default value is  Autonomous , which means that the Optimal Control Problem is considered time independent. The other possible time dependence is  NonAutonomous , which means that all the functions used to define the  Optimal Control Problem are considered time dependent. source"},{"id":328,"pagetitle":"Default","title":"CTBase.__ocp_variable_dependence","ref":"/ctbase/stable/#CTBase.__ocp_variable_dependence-Tuple{}","content":" CTBase.__ocp_variable_dependence  —  Method __ocp_variable_dependence() -> Type{Fixed}\n Used to set the default value of the variable dependence of the Optimal Control Problem. The default value is  Fixed , which means that the Optimal Control Problem is considered variable independent. The other possible variable dependence is  NonFixed , which means that all the functions used to define the Optimal Control Problem are considered variable dependent. source"},{"id":329,"pagetitle":"Default","title":"CTBase.__print_level_ipopt","ref":"/ctbase/stable/#CTBase.__print_level_ipopt-Tuple{}","content":" CTBase.__print_level_ipopt  —  Method __print_level_ipopt() -> Int64\n Used to set the default value of the print level of ipopt for the direct method. The default value is  5 . source"},{"id":330,"pagetitle":"Default","title":"CTBase.__state_components_names","ref":"/ctbase/stable/#CTBase.__state_components_names-Tuple{Integer, String}","content":" CTBase.__state_components_names  —  Method __state_components_names(n::Integer, name::String) -> Any\n Used to set the default value of the names of the states. The default value is  [\"x\"]  for a one dimensional state, and  [\"x₁\", \"x₂\", ...]  for a multi dimensional state. source"},{"id":331,"pagetitle":"Default","title":"CTBase.__state_name","ref":"/ctbase/stable/#CTBase.__state_name-Tuple{}","content":" CTBase.__state_name  —  Method __state_name() -> String\n Used to set the default value of the name of the state. The default value is  \"x\" . source"},{"id":332,"pagetitle":"Default","title":"CTBase.__time_name","ref":"/ctbase/stable/#CTBase.__time_name-Tuple{}","content":" CTBase.__time_name  —  Method __time_name() -> String\n Used to set the default value of the name of the time. The default value is  t . source"},{"id":333,"pagetitle":"Default","title":"CTBase.__variable_components_names","ref":"/ctbase/stable/#CTBase.__variable_components_names-Tuple{Integer, String}","content":" CTBase.__variable_components_names  —  Method __variable_components_names(q::Integer, name::String) -> Any\n Used to set the default value of the names of the variables. The default value is  [\"v\"]  for a one dimensional variable, and  [\"v₁\", \"v₂\", ...]  for a multi dimensional variable. source"},{"id":334,"pagetitle":"Default","title":"CTBase.__variable_name","ref":"/ctbase/stable/#CTBase.__variable_name-Tuple{}","content":" CTBase.__variable_name  —  Method __variable_name() -> String\n Used to set the default value of the names of the variables. The default value is  \"v\" . source"},{"id":337,"pagetitle":"Description","title":"Description","ref":"/ctbase/stable/#Description","content":" Description"},{"id":338,"pagetitle":"Description","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.Description CTBase.add CTBase.add CTBase.getFullDescription"},{"id":339,"pagetitle":"Description","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":340,"pagetitle":"Description","title":"CTBase.Description","ref":"/ctbase/stable/#CTBase.Description","content":" CTBase.Description  —  Type A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}. source"},{"id":341,"pagetitle":"Description","title":"CTBase.add","ref":"/ctbase/stable/#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Concatenate the description  y  at the tuple of descriptions  x  if it is not already in the tuple  x . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,)) source"},{"id":342,"pagetitle":"Description","title":"CTBase.add","ref":"/ctbase/stable/#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Return a tuple containing only the description  y . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,) source"},{"id":343,"pagetitle":"Description","title":"CTBase.getFullDescription","ref":"/ctbase/stable/#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","content":" CTBase.getFullDescription  —  Method getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n Return a complete description from an incomplete description  desc  and  a list of complete descriptions  desc_list . If several complete descriptions are possible,  then the first one is returned. Example julia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b) source"},{"id":346,"pagetitle":"Developers","title":"Private functions","ref":"/ctbase/stable/#Private-functions","content":" Private functions"},{"id":347,"pagetitle":"Developers","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.CTCallback CTBase.CTCallbacks CTBase.PrintCallback CTBase.PrintCallback CTBase.StopCallback CTBase.StopCallback CTBase.get_priority_print_callbacks CTBase.get_priority_stop_callbacks"},{"id":348,"pagetitle":"Developers","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":349,"pagetitle":"Developers","title":"CTBase.DescVarArg","ref":"/ctbase/stable/#CTBase.DescVarArg","content":" CTBase.DescVarArg  —  Constant A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}. source"},{"id":350,"pagetitle":"Developers","title":"CTBase.RangeConstraint","ref":"/ctbase/stable/#CTBase.RangeConstraint","content":" CTBase.RangeConstraint  —  Type Type alias for an index or range. source"},{"id":351,"pagetitle":"Developers","title":"CTBase.AbstractCTFunction","ref":"/ctbase/stable/#CTBase.AbstractCTFunction","content":" CTBase.AbstractCTFunction  —  Type abstract type AbstractCTFunction <: Function Abstract type for functions. source"},{"id":352,"pagetitle":"Developers","title":"CTBase.AbstractOptimalControlModel","ref":"/ctbase/stable/#CTBase.AbstractOptimalControlModel","content":" CTBase.AbstractOptimalControlModel  —  Type abstract type AbstractOptimalControlModel source"},{"id":353,"pagetitle":"Developers","title":"CTBase.AbstractOptimalControlSolution","ref":"/ctbase/stable/#CTBase.AbstractOptimalControlSolution","content":" CTBase.AbstractOptimalControlSolution  —  Type abstract type AbstractOptimalControlSolution Abstract type for optimal control solutions. source"},{"id":354,"pagetitle":"Developers","title":"CTBase.AbstractPlotTreeElement","ref":"/ctbase/stable/#CTBase.AbstractPlotTreeElement","content":" CTBase.AbstractPlotTreeElement  —  Type abstract type AbstractPlotTreeElement Abstract node for plot. source"},{"id":355,"pagetitle":"Developers","title":"CTBase.AbstractVectorField","ref":"/ctbase/stable/#CTBase.AbstractVectorField","content":" CTBase.AbstractVectorField  —  Type abstract type AbstractVectorField{time_dependence, variable_dependence} Abstract type for vectorfields. source"},{"id":356,"pagetitle":"Developers","title":"CTBase.ParsingInfo","ref":"/ctbase/stable/#CTBase.ParsingInfo","content":" CTBase.ParsingInfo  —  Type mutable struct ParsingInfo Fields source"},{"id":357,"pagetitle":"Developers","title":"CTBase.PlotLeaf","ref":"/ctbase/stable/#CTBase.PlotLeaf","content":" CTBase.PlotLeaf  —  Type struct PlotLeaf <: CTBase.AbstractPlotTreeElement A leaf of a plot tree. source"},{"id":358,"pagetitle":"Developers","title":"CTBase.PlotNode","ref":"/ctbase/stable/#CTBase.PlotNode","content":" CTBase.PlotNode  —  Type struct PlotNode <: CTBase.AbstractPlotTreeElement A node of a plot tree. source"},{"id":359,"pagetitle":"Developers","title":"CTBase.PrintCallbacks","ref":"/ctbase/stable/#CTBase.PrintCallbacks","content":" CTBase.PrintCallbacks  —  Type Tuple of print callbacks. source"},{"id":360,"pagetitle":"Developers","title":"CTBase.StopCallbacks","ref":"/ctbase/stable/#CTBase.StopCallbacks","content":" CTBase.StopCallbacks  —  Type Tuple of stop callbacks. source"},{"id":361,"pagetitle":"Developers","title":"Base.:\\","ref":"/ctbase/stable/#Base.:\\\\-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Symbol}}}","content":" Base.:\\  —  Method \\(\n    x::Tuple{Vararg{Symbol}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Vararg{Symbol}}\n Return the difference between the description  x  and the description  y . Example julia> (:a, :b) \\ (:a,)\n(:b,) source"},{"id":362,"pagetitle":"Developers","title":"Base.show","ref":"/ctbase/stable/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlModel}","content":" Base.show  —  Method show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    ocp::OptimalControlModel\n)\n Print the optimal control problem. source"},{"id":363,"pagetitle":"Developers","title":"Base.show","ref":"/ctbase/stable/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, OptimalControlSolution}","content":" Base.show  —  Method show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    sol::OptimalControlSolution\n)\n Prints the solution. source"},{"id":364,"pagetitle":"Developers","title":"Base.show","ref":"/ctbase/stable/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","content":" Base.show  —  Method show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    descriptions::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n)\n Print a tuple of descriptions. source"},{"id":365,"pagetitle":"Developers","title":"Base.showerror","ref":"/ctbase/stable/#Base.showerror-Tuple{IO, AmbiguousDescription}","content":" Base.showerror  —  Method showerror(io::IO, e::AmbiguousDescription)\n Print the exception. source"},{"id":366,"pagetitle":"Developers","title":"Base.showerror","ref":"/ctbase/stable/#Base.showerror-Tuple{IO, IncorrectArgument}","content":" Base.showerror  —  Method showerror(io::IO, e::IncorrectArgument)\n Print the exception. source"},{"id":367,"pagetitle":"Developers","title":"Base.showerror","ref":"/ctbase/stable/#Base.showerror-Tuple{IO, IncorrectMethod}","content":" Base.showerror  —  Method showerror(io::IO, e::IncorrectMethod)\n Print the exception. source"},{"id":368,"pagetitle":"Developers","title":"Base.showerror","ref":"/ctbase/stable/#Base.showerror-Tuple{IO, IncorrectOutput}","content":" Base.showerror  —  Method showerror(io::IO, e::IncorrectOutput)\n Print the exception. source"},{"id":369,"pagetitle":"Developers","title":"Base.showerror","ref":"/ctbase/stable/#Base.showerror-Tuple{IO, NotImplemented}","content":" Base.showerror  —  Method showerror(io::IO, e::NotImplemented)\n Print the exception. source"},{"id":370,"pagetitle":"Developers","title":"Base.showerror","ref":"/ctbase/stable/#Base.showerror-Tuple{IO, ParsingError}","content":" Base.showerror  —  Method showerror(io::IO, e::ParsingError)\n Print the exception. source"},{"id":371,"pagetitle":"Developers","title":"Base.showerror","ref":"/ctbase/stable/#Base.showerror-Tuple{IO, UnauthorizedCall}","content":" Base.showerror  —  Method showerror(io::IO, e::UnauthorizedCall)\n Print the exception. source"},{"id":372,"pagetitle":"Developers","title":"CTBase.:⅋","ref":"/ctbase/stable/#CTBase.:⅋-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.:⅋  —  Method ⅋(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField{Autonomous}\n \"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, autonomous case Example julia> X = VectorField(x -> [x[2], -x[1]])\njulia> Y = VectorField(x -> [x[1], x[2]])\njulia> CTBase.:(⅋)(X, Y)([1, 2])\n[2, -1] source"},{"id":373,"pagetitle":"Developers","title":"CTBase.:⅋","ref":"/ctbase/stable/#CTBase.:⅋-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.:⅋  —  Method ⅋(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n \"Directional derivative\" of a vector field: internal and only used to compute efficiently the Lie bracket of two vector fields, nonautonomous case Example julia> X = VectorField((t, x, v) -> [t + v[1] + v[2] + x[2], -x[1]], NonFixed, NonAutonomous)\njulia> Y = VectorField((t, x, v) ->  [v[1] + v[2] + x[1], x[2]], NonFixed, NonAutonomous)\njulia> CTBase.:(⅋)(X, Y)(1, [1, 2], [2, 3])\n[8, -1] source"},{"id":374,"pagetitle":"Developers","title":"CTBase.__check_all_set","ref":"/ctbase/stable/#CTBase.__check_all_set-Tuple{OptimalControlModel}","content":" CTBase.__check_all_set  —  Method __check_all_set(\n    ocp::OptimalControlModel\n) -> Union{Nothing, Bool}\n Check if the parameters of an ocp are set. source"},{"id":375,"pagetitle":"Developers","title":"CTBase.__check_control_set","ref":"/ctbase/stable/#CTBase.__check_control_set-Tuple{OptimalControlModel}","content":" CTBase.__check_control_set  —  Method __check_control_set(ocp::OptimalControlModel) -> Bool\n Throw  UnauthorizedCall  exception if the control of an ocp is not set. source"},{"id":376,"pagetitle":"Developers","title":"CTBase.__check_dependencies","ref":"/ctbase/stable/#CTBase.__check_dependencies-Tuple{Tuple{Vararg{DataType}}}","content":" CTBase.__check_dependencies  —  Method __check_dependencies(\n    dependencies::Tuple{Vararg{DataType}}\n) -> Bool\n Throw  IncorrectArgument  exception if dependencies arguments are incorrect. source"},{"id":377,"pagetitle":"Developers","title":"CTBase.__check_is_time_set","ref":"/ctbase/stable/#CTBase.__check_is_time_set-Tuple{OptimalControlModel}","content":" CTBase.__check_is_time_set  —  Method __check_is_time_set(ocp::OptimalControlModel) -> Bool\n Throw  UnauthorizedCall  exception if the time of an ocp is not set. source"},{"id":378,"pagetitle":"Developers","title":"CTBase.__check_state_set","ref":"/ctbase/stable/#CTBase.__check_state_set-Tuple{OptimalControlModel}","content":" CTBase.__check_state_set  —  Method __check_state_set(ocp::OptimalControlModel) -> Bool\n Throw  UnauthorizedCall  exception if the state of an ocp is not set. source"},{"id":379,"pagetitle":"Developers","title":"CTBase.__check_variable_set","ref":"/ctbase/stable/#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, Fixed}}","content":" CTBase.__check_variable_set  —  Method __check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, Fixed}\n)\n Do nothing, no variable for fixed ocp. source"},{"id":380,"pagetitle":"Developers","title":"CTBase.__check_variable_set","ref":"/ctbase/stable/#CTBase.__check_variable_set-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","content":" CTBase.__check_variable_set  —  Method __check_variable_set(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n Throw  UnauthorizedCall  exception if the variable of an ocp is not set. source"},{"id":381,"pagetitle":"Developers","title":"CTBase.__get_data_plot","ref":"/ctbase/stable/#CTBase.__get_data_plot-Tuple{OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}}","content":" CTBase.__get_data_plot  —  Method __get_data_plot(\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Any\n Get the data for plotting. source"},{"id":382,"pagetitle":"Developers","title":"CTBase.__initial_plot","ref":"/ctbase/stable/#CTBase.__initial_plot-Tuple{OptimalControlSolution}","content":" CTBase.__initial_plot  —  Method __initial_plot(\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    kwargs...\n) -> Any\n Initial plot. source"},{"id":383,"pagetitle":"Developers","title":"CTBase.__plot_time!","ref":"/ctbase/stable/#CTBase.__plot_time!-Tuple{Union{Plots.Plot, Plots.Subplot}, OptimalControlSolution, Integer, Symbol}","content":" CTBase.__plot_time!  —  Method __plot_time!(\n    p::Union{Plots.Plot, Plots.Subplot},\n    sol::OptimalControlSolution,\n    d::Integer,\n    s::Symbol;\n    t_label,\n    labels,\n    title,\n    kwargs...\n)\n Update the plot  p  with a vectorial function of time  f(t) ∈ Rᵈ  where  f  is given by the symbol  s . The argument  s  can be  :state ,  :control  or  :costate . source"},{"id":384,"pagetitle":"Developers","title":"CTBase.__plot_time!","ref":"/ctbase/stable/#CTBase.__plot_time!-Tuple{Union{Plots.Plot, Plots.Subplot}, OptimalControlSolution, Symbol, Integer}","content":" CTBase.__plot_time!  —  Method __plot_time!(\n    p::Union{Plots.Plot, Plots.Subplot},\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n Update the plot  p  with the i-th component of a vectorial function of time  f(t) ∈ Rᵈ  where  f  is given by the symbol  s . The argument  s  can be  :state ,  :control  or  :costate . source"},{"id":385,"pagetitle":"Developers","title":"CTBase.__plot_time","ref":"/ctbase/stable/#CTBase.__plot_time-Tuple{OptimalControlSolution, Integer, Symbol}","content":" CTBase.__plot_time  —  Method __plot_time(\n    sol::OptimalControlSolution,\n    d::Integer,\n    s::Symbol;\n    t_label,\n    labels,\n    title,\n    kwargs...\n)\n Plot a vectorial function of time  f(t) ∈ Rᵈ  where  f  is given by the symbol  s . The argument  s  can be  :state ,  :control  or  :costate . source"},{"id":386,"pagetitle":"Developers","title":"CTBase.__plot_time","ref":"/ctbase/stable/#CTBase.__plot_time-Tuple{OptimalControlSolution, Symbol, Integer}","content":" CTBase.__plot_time  —  Method __plot_time(\n    sol::OptimalControlSolution,\n    s::Symbol,\n    i::Integer;\n    t_label,\n    label,\n    kwargs...\n)\n Plot the i-th component of a vectorial function of time  f(t) ∈ Rᵈ  where  f  is given by the symbol  s . The argument  s  can be  :state ,  :control  or  :costate . source"},{"id":387,"pagetitle":"Developers","title":"CTBase.__plot_tree","ref":"/ctbase/stable/#CTBase.__plot_tree","content":" CTBase.__plot_tree  —  Function __plot_tree(node::CTBase.PlotNode) -> Any\n__plot_tree(\n    node::CTBase.PlotNode,\n    depth::Integer;\n    kwargs...\n) -> Any\n Plot a node. source"},{"id":388,"pagetitle":"Developers","title":"CTBase.__plot_tree","ref":"/ctbase/stable/#CTBase.__plot_tree-Tuple{CTBase.PlotLeaf, Integer}","content":" CTBase.__plot_tree  —  Method __plot_tree(\n    leaf::CTBase.PlotLeaf,\n    depth::Integer;\n    kwargs...\n) -> Plots.Plot\n Plot a leaf. source"},{"id":389,"pagetitle":"Developers","title":"CTBase.__width","ref":"/ctbase/stable/#CTBase.__width-Tuple{Real}","content":" CTBase.__width  —  Method __width(r::Real) -> Expr\n Generate a{r*h} where  r  is a real number and  h  is the height of the plot. source"},{"id":390,"pagetitle":"Developers","title":"CTBase.ctindice","ref":"/ctbase/stable/#CTBase.ctindice-Tuple{Integer}","content":" CTBase.ctindice  —  Method ctindice(i::Integer) -> Char\n Return  i  ∈ [0, 9] as a subscript. source"},{"id":391,"pagetitle":"Developers","title":"CTBase.ctupperscript","ref":"/ctbase/stable/#CTBase.ctupperscript-Tuple{Integer}","content":" CTBase.ctupperscript  —  Method ctupperscript(i::Integer) -> Char\n Return  i  ∈ [0, 9] as an upperscript. source"},{"id":392,"pagetitle":"Developers","title":"CTBase.expand","ref":"/ctbase/stable/#CTBase.expand-Tuple{Matrix{<:Real}}","content":" CTBase.expand  —  Method expand(x::Matrix{<:Real}) -> Vector{<:Real}\n Return  expand(matrix2vec(x, 1)) source"},{"id":393,"pagetitle":"Developers","title":"CTBase.expand","ref":"/ctbase/stable/#CTBase.expand-Tuple{Vector{<:Real}}","content":" CTBase.expand  —  Method expand(x::Vector{<:Real}) -> Vector{<:Real}\n Return  x . source"},{"id":394,"pagetitle":"Developers","title":"CTBase.expand","ref":"/ctbase/stable/#CTBase.expand-Tuple{Vector{<:Vector{<:Real}}}","content":" CTBase.expand  —  Method expand(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n Equivalent to  vec2vec(x) source"},{"id":395,"pagetitle":"Developers","title":"CTBase.expr_it","ref":"/ctbase/stable/#CTBase.expr_it-Tuple{Any, Any, Any}","content":" CTBase.expr_it  —  Method expr_it(e, _Expr, f) -> Any\n Expr iterator: apply  _Expr  to nodes and  f  to leaves of the AST. Example julia> id(e) = expr_it(e, Expr, x -> x) source"},{"id":396,"pagetitle":"Developers","title":"CTBase.has","ref":"/ctbase/stable/#CTBase.has-Tuple{Any, Any, Any}","content":" CTBase.has  —  Method has(e, x, t) -> Union{Missing, Bool}\n Return true if e contains an  (...x...)(t)  call. Example julia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, :x, :t)\ntrue\n\njulia> has(e, :u, :t)\ntrue source"},{"id":397,"pagetitle":"Developers","title":"CTBase.has","ref":"/ctbase/stable/#CTBase.has-Tuple{Any, Any}","content":" CTBase.has  —  Method has(e, e1) -> Union{Missing, Bool}\n Return true if e contains e1. Example julia> e = :( ∫( x[1](t)^2 + 2*u(t) ) → min )\n:(∫((x[1])(t) ^ 2 + 2 * u(t)) → min)\n\njulia> has(e, 2)\ntrue\n\njulia> has(e, :x)\ntrue\n\njulia> has(e, :min)\ntrue\n\njulia> has(e, :( x[1](t)^2 ))\ntrue\n\njulia> !has(e, :( x[1](t)^3 ))\ntrue\n\njulia> !has(e, 3)\ntrue\n\njulia> !has(e, :max)\ntrue\n\njulia> has(:x, :x)\ntrue\n\njulia> !has(:x, 2)\ntrue\n\njulia> !has(:x, :y)\ntrue source"},{"id":398,"pagetitle":"Developers","title":"CTBase.matrix2vec","ref":"/ctbase/stable/#CTBase.matrix2vec","content":" CTBase.matrix2vec  —  Function matrix2vec(x::Matrix{<:Real}) -> Vector{<:Vector{<:Real}}\nmatrix2vec(\n    x::Matrix{<:Real},\n    dim::Integer\n) -> Vector{<:Vector{<:Real}}\n Transforms  x  to a Vector{<:Vector{<:ctNumber}}. Note. dim  ∈ {1, 2} is the dimension along which the matrix is transformed. source"},{"id":399,"pagetitle":"Developers","title":"CTBase.parse!","ref":"/ctbase/stable/#CTBase.parse!-Tuple{Any, Any, Any}","content":" CTBase.parse!  —  Method parse!(p, ocp, e; log) -> Union{Expr, LineNumberNode}\n Foo Example Foo source"},{"id":400,"pagetitle":"Developers","title":"CTBase.subs","ref":"/ctbase/stable/#CTBase.subs-Tuple{Any, Union{Real, Symbol}, Any}","content":" CTBase.subs  —  Method subs(e, e1::Union{Real, Symbol}, e2) -> Any\n Substitute expression  e1  by expression  e2  in expression  e . Examples julia> e = :( ∫( r(t)^2 + 2u₁(t)) → min )\n:(∫(r(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> subs(e, :r, :( x[1] ))\n:(∫((x[1])(t) ^ 2 + 2 * u₁(t)) → min)\n\njulia> e = :( ∫( u₁(t)^2 + 2u₂(t)) → min )\n:(∫(u₁(t) ^ 2 + 2 * u₂(t)) → min)\n\njulia> for i ∈ 1:2\n       e = subs(e, Symbol(:u, Char(8320+i)), :( u[$i] ))\n       end; e\n:(∫((u[1])(t) ^ 2 + 2 * (u[2])(t)) → min)\n\njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); subs(e, :( $x[1]($(t0)) ), :( $x0[1] ))\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2 * x(0))) source"},{"id":401,"pagetitle":"Developers","title":"CTBase.vec2vec","ref":"/ctbase/stable/#CTBase.vec2vec-Tuple{Vector{<:Real}, Integer}","content":" CTBase.vec2vec  —  Method vec2vec(\n    x::Vector{<:Real},\n    n::Integer\n) -> Vector{<:Vector{<:Real}}\n Transforms  x  to a Vector{<:Vector{<:ctNumber}}. source"},{"id":402,"pagetitle":"Developers","title":"CTBase.vec2vec","ref":"/ctbase/stable/#CTBase.vec2vec-Tuple{Vector{<:Vector{<:Real}}}","content":" CTBase.vec2vec  —  Method vec2vec(x::Vector{<:Vector{<:Real}}) -> Vector{<:Real}\n Transforms  x  to a Vector{<:ctNumber}. source"},{"id":403,"pagetitle":"Developers","title":"RecipesBase.apply_recipe","ref":"/ctbase/stable/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol, Any}, OptimalControlSolution, Union{Symbol, Tuple{Symbol, Integer}}, Union{Symbol, Tuple{Symbol, Integer}}}","content":" RecipesBase.apply_recipe  —  Method apply_recipe(\n    plotattributes::AbstractDict{Symbol, Any},\n    sol::OptimalControlSolution,\n    xx::Union{Symbol, Tuple{Symbol, Integer}},\n    yy::Union{Symbol, Tuple{Symbol, Integer}}\n) -> Vector{RecipesBase.RecipeData}\n Return  x  and  y  for the plot of the optimal control solution  sol   corresponding respectively to the argument  xx  and the argument  yy . Notes. The argument  xx  can be  :time ,  :state ,  :control  or  :costate . If  xx  is  :time , then, a label is added to the plot. The argument  yy  can be  :state ,  :control  or  :costate . source"},{"id":406,"pagetitle":"Differential geometry","title":"Differential geometry","ref":"/ctbase/stable/#Differential-geometry","content":" Differential geometry"},{"id":407,"pagetitle":"Differential geometry","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.:⋅ CTBase.:⋅ CTBase.:⋅ CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lift CTBase.Lift CTBase.Lift CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.∂ₜ CTBase.@Lie"},{"id":408,"pagetitle":"Differential geometry","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":409,"pagetitle":"Differential geometry","title":"CTBase.:⋅","ref":"/ctbase/stable/#CTBase.:⋅-Tuple{Function, Function}","content":" CTBase.:⋅  —  Method ⋅(X::Function, f::Function) -> Function\n Lie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError source"},{"id":410,"pagetitle":"Differential geometry","title":"CTBase.:⋅","ref":"/ctbase/stable/#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#105#107\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0 source"},{"id":411,"pagetitle":"Differential geometry","title":"CTBase.:⋅","ref":"/ctbase/stable/#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#109#111\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case Example julia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10 source"},{"id":412,"pagetitle":"Differential geometry","title":"CTBase.Lie","ref":"/ctbase/stable/#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n Lie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10 source"},{"id":413,"pagetitle":"Differential geometry","title":"CTBase.Lie","ref":"/ctbase/stable/#CTBase.Lie-Tuple{Function, Function}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n Lie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10 source"},{"id":414,"pagetitle":"Differential geometry","title":"CTBase.Lie","ref":"/ctbase/stable/#CTBase.Lie-Tuple{VectorField, Function}","content":" CTBase.Lie  —  Method Lie(X::VectorField, f::Function) -> Function\n Lie derivative of a scalar function along a vector field. Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10 source"},{"id":415,"pagetitle":"Differential geometry","title":"CTBase.Lie","ref":"/ctbase/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField{Autonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case Example julia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14] source"},{"id":416,"pagetitle":"Differential geometry","title":"CTBase.Lie","ref":"/ctbase/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case Example julia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12] source"},{"id":417,"pagetitle":"Differential geometry","title":"CTBase.Lift","ref":"/ctbase/stable/#CTBase.Lift-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lift  —  Method Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2 source"},{"id":418,"pagetitle":"Differential geometry","title":"CTBase.Lift","ref":"/ctbase/stable/#CTBase.Lift-Tuple{Function}","content":" CTBase.Lift  —  Method Lift(X::Function; autonomous, variable) -> HamiltonianLift\n Return the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2 source"},{"id":419,"pagetitle":"Differential geometry","title":"CTBase.Lift","ref":"/ctbase/stable/#CTBase.Lift-Tuple{VectorField}","content":" CTBase.Lift  —  Method Lift(X::VectorField) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField. Example julia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2 source"},{"id":420,"pagetitle":"Differential geometry","title":"CTBase.Poisson","ref":"/ctbase/stable/#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76 source"},{"id":421,"pagetitle":"Differential geometry","title":"CTBase.Poisson","ref":"/ctbase/stable/#CTBase.Poisson-Tuple{Function, Function}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76 source"},{"id":422,"pagetitle":"Differential geometry","title":"CTBase.Poisson","ref":"/ctbase/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift{Autonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20 source"},{"id":423,"pagetitle":"Differential geometry","title":"CTBase.Poisson","ref":"/ctbase/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift{NonAutonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case Example julia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76 source"},{"id":424,"pagetitle":"Differential geometry","title":"CTBase.Poisson","ref":"/ctbase/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n Poisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76 source"},{"id":425,"pagetitle":"Differential geometry","title":"CTBase.Poisson","ref":"/ctbase/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n Poisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g) Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76 source"},{"id":426,"pagetitle":"Differential geometry","title":"CTBase.Poisson","ref":"/ctbase/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n Poisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g) Example julia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100 source"},{"id":427,"pagetitle":"Differential geometry","title":"CTBase.∂ₜ","ref":"/ctbase/stable/#CTBase.∂ₜ-Tuple{Any}","content":" CTBase.∂ₜ  —  Method ∂ₜ(f) -> CTBase.var\"#114#116\"\n Partial derivative wrt time of a function. Example julia> ∂ₜ((t,x) -> t*x)(0,8)\n8 source"},{"id":428,"pagetitle":"Differential geometry","title":"CTBase.@Lie","ref":"/ctbase/stable/#CTBase.@Lie-Tuple{Expr}","content":" CTBase.@Lie  —  Macro Macros for Lie and Poisson brackets Example julia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1,0,7])\n3.0 source"},{"id":431,"pagetitle":"Exceptions","title":"Exceptions","ref":"/ctbase/stable/#api-exceptions","content":" Exceptions"},{"id":432,"pagetitle":"Exceptions","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.AmbiguousDescription CTBase.CTException CTBase.IncorrectArgument CTBase.IncorrectMethod CTBase.IncorrectOutput CTBase.NotImplemented CTBase.ParsingError CTBase.UnauthorizedCall"},{"id":433,"pagetitle":"Exceptions","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":434,"pagetitle":"Exceptions","title":"CTBase.AmbiguousDescription","ref":"/ctbase/stable/#CTBase.AmbiguousDescription","content":" CTBase.AmbiguousDescription  —  Type struct AmbiguousDescription <: CTException Exception thrown when the description is ambiguous / incorrect. Fields var::Tuple{Vararg{Symbol}} source"},{"id":435,"pagetitle":"Exceptions","title":"CTBase.CTException","ref":"/ctbase/stable/#CTBase.CTException","content":" CTBase.CTException  —  Type abstract type CTException <: Exception Abstract type for exceptions. source"},{"id":436,"pagetitle":"Exceptions","title":"CTBase.IncorrectArgument","ref":"/ctbase/stable/#CTBase.IncorrectArgument","content":" CTBase.IncorrectArgument  —  Type struct IncorrectArgument <: CTException Exception thrown when an argument is inconsistent. Fields var::String source"},{"id":437,"pagetitle":"Exceptions","title":"CTBase.IncorrectMethod","ref":"/ctbase/stable/#CTBase.IncorrectMethod","content":" CTBase.IncorrectMethod  —  Type struct IncorrectMethod <: CTException Exception thrown when a method is incorrect. Fields var::Symbol source"},{"id":438,"pagetitle":"Exceptions","title":"CTBase.IncorrectOutput","ref":"/ctbase/stable/#CTBase.IncorrectOutput","content":" CTBase.IncorrectOutput  —  Type struct IncorrectOutput <: CTException Exception thrown when the output is incorrect. Fields var::String source"},{"id":439,"pagetitle":"Exceptions","title":"CTBase.NotImplemented","ref":"/ctbase/stable/#CTBase.NotImplemented","content":" CTBase.NotImplemented  —  Type struct NotImplemented <: CTException Exception thrown when a method is not implemented. Fields var::String source"},{"id":440,"pagetitle":"Exceptions","title":"CTBase.ParsingError","ref":"/ctbase/stable/#CTBase.ParsingError","content":" CTBase.ParsingError  —  Type struct ParsingError <: CTException Exception thrown for syntax error during abstract parsing. Fields var::String source"},{"id":441,"pagetitle":"Exceptions","title":"CTBase.UnauthorizedCall","ref":"/ctbase/stable/#CTBase.UnauthorizedCall","content":" CTBase.UnauthorizedCall  —  Type struct UnauthorizedCall <: CTException Exception thrown when a call to a function is not authorized. Fields var::String source"},{"id":444,"pagetitle":"Functions","title":"Functions","ref":"/ctbase/stable/#Functions","content":" Functions"},{"id":445,"pagetitle":"Functions","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlLaw CTBase.ControlLaw CTBase.ControlLaw CTBase.Dynamics CTBase.Dynamics CTBase.Dynamics CTBase.FeedbackControl CTBase.FeedbackControl CTBase.FeedbackControl CTBase.Hamiltonian CTBase.Hamiltonian CTBase.Hamiltonian CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.Lagrange CTBase.Lagrange CTBase.Lagrange CTBase.Mayer CTBase.Mayer CTBase.Mayer CTBase.MixedConstraint CTBase.MixedConstraint CTBase.MixedConstraint CTBase.Multiplier CTBase.Multiplier CTBase.Multiplier CTBase.StateConstraint CTBase.StateConstraint CTBase.StateConstraint CTBase.VariableConstraint CTBase.VectorField CTBase.VectorField CTBase.VectorField"},{"id":446,"pagetitle":"Functions","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":447,"pagetitle":"Functions","title":"CTBase.BoundaryConstraint","ref":"/ctbase/stable/#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.BoundaryConstraint  —  Method BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> BoundaryConstraint{Fixed}\n Return a  BoundaryConstraint  of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed) source"},{"id":448,"pagetitle":"Functions","title":"CTBase.BoundaryConstraint","ref":"/ctbase/stable/#CTBase.BoundaryConstraint-Tuple{Function}","content":" CTBase.BoundaryConstraint  —  Method BoundaryConstraint(\n    f::Function;\n    variable\n) -> BoundaryConstraint{Fixed}\n Return a  BoundaryConstraint  of a function. Dependencies are specified with a boolean, variable, false by default. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true) source"},{"id":449,"pagetitle":"Functions","title":"CTBase.BoundaryConstraint","ref":"/ctbase/stable/#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.BoundaryConstraint  —  Method Return the evaluation of the BoundaryConstraint. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1] source"},{"id":450,"pagetitle":"Functions","title":"CTBase.ControlConstraint","ref":"/ctbase/stable/#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed) source"},{"id":451,"pagetitle":"Functions","title":"CTBase.ControlConstraint","ref":"/ctbase/stable/#CTBase.ControlConstraint-Tuple{Function}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  ControlConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true) source"},{"id":452,"pagetitle":"Functions","title":"CTBase.ControlConstraint","ref":"/ctbase/stable/#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlConstraint  —  Method Return the value of the ControlConstraint function. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1] source"},{"id":453,"pagetitle":"Functions","title":"CTBase.ControlLaw","ref":"/ctbase/stable/#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed) source"},{"id":454,"pagetitle":"Functions","title":"CTBase.ControlLaw","ref":"/ctbase/stable/#CTBase.ControlLaw-Tuple{Function}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) source"},{"id":455,"pagetitle":"Functions","title":"CTBase.ControlLaw","ref":"/ctbase/stable/#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlLaw  —  Method Return the value of the ControlLaw function. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7 source"},{"id":456,"pagetitle":"Functions","title":"CTBase.Dynamics","ref":"/ctbase/stable/#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed) source"},{"id":457,"pagetitle":"Functions","title":"CTBase.Dynamics","ref":"/ctbase/stable/#CTBase.Dynamics-Tuple{Function}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) source"},{"id":458,"pagetitle":"Functions","title":"CTBase.Dynamics","ref":"/ctbase/stable/#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Dynamics  —  Method Return the value of the Dynamics function. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1] source"},{"id":459,"pagetitle":"Functions","title":"CTBase.FeedbackControl","ref":"/ctbase/stable/#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed) source"},{"id":460,"pagetitle":"Functions","title":"CTBase.FeedbackControl","ref":"/ctbase/stable/#CTBase.FeedbackControl-Tuple{Function}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true) source"},{"id":461,"pagetitle":"Functions","title":"CTBase.FeedbackControl","ref":"/ctbase/stable/#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.FeedbackControl  —  Method Return the value of the FeedbackControl function. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5 source"},{"id":462,"pagetitle":"Functions","title":"CTBase.Hamiltonian","ref":"/ctbase/stable/#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed) source"},{"id":463,"pagetitle":"Functions","title":"CTBase.Hamiltonian","ref":"/ctbase/stable/#CTBase.Hamiltonian-Tuple{Function}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true) source"},{"id":464,"pagetitle":"Functions","title":"CTBase.Hamiltonian","ref":"/ctbase/stable/#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Hamiltonian  —  Method Return the value of the Hamiltonian. julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7 source"},{"id":465,"pagetitle":"Functions","title":"CTBase.HamiltonianLift","ref":"/ctbase/stable/#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed) source"},{"id":466,"pagetitle":"Functions","title":"CTBase.HamiltonianLift","ref":"/ctbase/stable/#CTBase.HamiltonianLift-Tuple{Function}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true) source"},{"id":467,"pagetitle":"Functions","title":"CTBase.HamiltonianLift","ref":"/ctbase/stable/#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianLift  —  Method Return the value of the HamiltonianLift. Examples julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3 source"},{"id":468,"pagetitle":"Functions","title":"CTBase.HamiltonianVectorField","ref":"/ctbase/stable/#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed) source"},{"id":469,"pagetitle":"Functions","title":"CTBase.HamiltonianVectorField","ref":"/ctbase/stable/#CTBase.HamiltonianVectorField-Tuple{Function}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true) source"},{"id":470,"pagetitle":"Functions","title":"CTBase.HamiltonianVectorField","ref":"/ctbase/stable/#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianVectorField  —  Method Return the value of the HamiltonianVectorField. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3] source"},{"id":471,"pagetitle":"Functions","title":"CTBase.Lagrange","ref":"/ctbase/stable/#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n source"},{"id":472,"pagetitle":"Functions","title":"CTBase.Lagrange","ref":"/ctbase/stable/#CTBase.Lagrange-Tuple{Function}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n source"},{"id":473,"pagetitle":"Functions","title":"CTBase.Lagrange","ref":"/ctbase/stable/#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Lagrange  —  Method Return the value of the Lagrange function. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3 source"},{"id":474,"pagetitle":"Functions","title":"CTBase.Mayer","ref":"/ctbase/stable/#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","content":" CTBase.Mayer  —  Method Mayer(\n    f::Function,\n    dependencies::DataType...\n) -> Mayer{Fixed}\n Return a  Mayer  cost of a function. Dependencies are specified with a DataType, NonFixed/Fixed, Fixed by default. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed) source"},{"id":475,"pagetitle":"Functions","title":"CTBase.Mayer","ref":"/ctbase/stable/#CTBase.Mayer-Tuple{Function}","content":" CTBase.Mayer  —  Method Mayer(f::Function; variable) -> Mayer{Fixed}\n Return a  Mayer  cost of a function. Dependencies are specified with a boolean, variable, false by default. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true) source"},{"id":476,"pagetitle":"Functions","title":"CTBase.Mayer","ref":"/ctbase/stable/#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Mayer  —  Method Return the evaluation of the Mayer cost. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1], Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4 source"},{"id":477,"pagetitle":"Functions","title":"CTBase.MixedConstraint","ref":"/ctbase/stable/#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed) source"},{"id":478,"pagetitle":"Functions","title":"CTBase.MixedConstraint","ref":"/ctbase/stable/#CTBase.MixedConstraint-Tuple{Function}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) source"},{"id":479,"pagetitle":"Functions","title":"CTBase.MixedConstraint","ref":"/ctbase/stable/#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.MixedConstraint  —  Method Return the value of the MixedConstraint function. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1] source"},{"id":480,"pagetitle":"Functions","title":"CTBase.Multiplier","ref":"/ctbase/stable/#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed) source"},{"id":481,"pagetitle":"Functions","title":"CTBase.Multiplier","ref":"/ctbase/stable/#CTBase.Multiplier-Tuple{Function}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) source"},{"id":482,"pagetitle":"Functions","title":"CTBase.Multiplier","ref":"/ctbase/stable/#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Multiplier  —  Method Return the value of the Multiplier function. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7 source"},{"id":483,"pagetitle":"Functions","title":"CTBase.StateConstraint","ref":"/ctbase/stable/#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed) source"},{"id":484,"pagetitle":"Functions","title":"CTBase.StateConstraint","ref":"/ctbase/stable/#CTBase.StateConstraint-Tuple{Function}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true) source"},{"id":485,"pagetitle":"Functions","title":"CTBase.StateConstraint","ref":"/ctbase/stable/#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.StateConstraint  —  Method Return the value of the StateConstraint function. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1] source"},{"id":486,"pagetitle":"Functions","title":"CTBase.VariableConstraint","ref":"/ctbase/stable/#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VariableConstraint  —  Method Return the value of the VariableConstraint function. julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2] source"},{"id":487,"pagetitle":"Functions","title":"CTBase.VectorField","ref":"/ctbase/stable/#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed) source"},{"id":488,"pagetitle":"Functions","title":"CTBase.VectorField","ref":"/ctbase/stable/#CTBase.VectorField-Tuple{Function}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true) source"},{"id":489,"pagetitle":"Functions","title":"CTBase.VectorField","ref":"/ctbase/stable/#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VectorField  —  Method Return the value of the VectorField. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1] source"},{"id":492,"pagetitle":"Model","title":"Model","ref":"/ctbase/stable/#Model","content":" Model"},{"id":493,"pagetitle":"Model","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.Model CTBase.Model CTBase.constraint CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraints_labels CTBase.control! CTBase.dynamics! CTBase.is_max CTBase.is_min CTBase.is_time_dependent CTBase.is_time_independent CTBase.is_variable_dependent CTBase.is_variable_independent CTBase.nlp_constraints CTBase.objective! CTBase.objective! CTBase.remove_constraint! CTBase.state! CTBase.time! CTBase.time! CTBase.time! CTBase.time! CTBase.time! CTBase.variable!"},{"id":494,"pagetitle":"Model","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":495,"pagetitle":"Model","title":"CTBase.Model","ref":"/ctbase/stable/#CTBase.Model-Tuple{Vararg{DataType}}","content":" CTBase.Model  —  Method Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following argument: dependencies : either  Autonomous  or  NonAutonomous . Default is  Autonomous . And either  NonFixed  or  Fixed . Default is  Fixed . Examples julia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control. source"},{"id":496,"pagetitle":"Model","title":"CTBase.Model","ref":"/ctbase/stable/#CTBase.Model-Tuple{}","content":" CTBase.Model  —  Method Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following optional keyword argument: autonomous : either  true  or  false . Default is  true . variable : either  true  or  false . Default is  false . Examples julia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control. source"},{"id":497,"pagetitle":"Model","title":"CTBase.constraint!","ref":"/ctbase/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  value functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[2], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u+v[1], 0)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u-t*v[2], 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t+v[1], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]-u*v[1], 0) source"},{"id":498,"pagetitle":"Model","title":"CTBase.constraint!","ref":"/ctbase/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on a range of the state, or a value constraint on a range of the  :variable . Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\njulia> constraint!(ocp, :variable, 2:3, [ 0, 3 ]) source"},{"id":499,"pagetitle":"Model","title":"CTBase.constraint!","ref":"/ctbase/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on the state, or a  :variable  value. Can also be used with  :state  and  :control . Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0 ])\njulia> constraint!(ocp, :final, 2) # if the state is of dimension 1\njulia> constraint!(ocp, :variable, [ 3, 0, 1 ]) source"},{"id":500,"pagetitle":"Model","title":"CTBase.constraint!","ref":"/ctbase/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint (whole range). Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 0, 1) # the variable here is of dimension 1 source"},{"id":501,"pagetitle":"Model","title":"CTBase.constraint!","ref":"/ctbase/stable/#CTBase.constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol;\n    rg,\n    f,\n    val,\n    lb,\n    ub,\n    label\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :control, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :state, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial, rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ]) source"},{"id":502,"pagetitle":"Model","title":"CTBase.constraint!","ref":"/ctbase/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where V<:VariableDependence","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 1:2, [ 0, 0 ], [ 1, 2 ]) source"},{"id":503,"pagetitle":"Model","title":"CTBase.constraint!","ref":"/ctbase/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where {T, V}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  box functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0, 1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0, 1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 0, 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u, v) -> x[1]-v[2]*u, 0, 1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u+v[2], 0, 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t*v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]*v[2]-u, 0, 1) source"},{"id":504,"pagetitle":"Model","title":"CTBase.constraint","ref":"/ctbase/stable/#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.constraint  —  Method constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n Retrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds). Example julia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1 source"},{"id":505,"pagetitle":"Model","title":"CTBase.constraints_labels","ref":"/ctbase/stable/#CTBase.constraints_labels-Tuple{OptimalControlModel}","content":" CTBase.constraints_labels  —  Method constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n Return the labels of the constraints as a  Base.keys . Example julia> constraints_labels(ocp) source"},{"id":506,"pagetitle":"Model","title":"CTBase.control!","ref":"/ctbase/stable/#CTBase.control!","content":" CTBase.control!  —  Function control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the control dimension and possibly the names of each coordinate. Note You must use control! only once to set the control dimension. Examples julia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"] source"},{"id":507,"pagetitle":"Model","title":"CTBase.dynamics!","ref":"/ctbase/stable/#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.dynamics!  —  Method dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n Set the dynamics. Note You can use dynamics! only once to define the dynamics. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> dynamics!(ocp, f) source"},{"id":508,"pagetitle":"Model","title":"CTBase.is_max","ref":"/ctbase/stable/#CTBase.is_max-Tuple{OptimalControlModel}","content":" CTBase.is_max  —  Method is_max(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :max . source"},{"id":509,"pagetitle":"Model","title":"CTBase.is_min","ref":"/ctbase/stable/#CTBase.is_min-Tuple{OptimalControlModel}","content":" CTBase.is_min  —  Method is_min(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :min . source"},{"id":510,"pagetitle":"Model","title":"CTBase.is_time_dependent","ref":"/ctbase/stable/#CTBase.is_time_dependent-Tuple{OptimalControlModel{NonAutonomous}}","content":" CTBase.is_time_dependent  —  Method is_time_dependent(\n    ocp::OptimalControlModel{NonAutonomous}\n) -> Bool\n Return  true  if the model has been defined as time dependent. source"},{"id":511,"pagetitle":"Model","title":"CTBase.is_time_independent","ref":"/ctbase/stable/#CTBase.is_time_independent-Tuple{OptimalControlModel}","content":" CTBase.is_time_independent  —  Method is_time_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as time independent. source"},{"id":512,"pagetitle":"Model","title":"CTBase.is_variable_dependent","ref":"/ctbase/stable/#CTBase.is_variable_dependent-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","content":" CTBase.is_variable_dependent  —  Method is_variable_dependent(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n Return  true  if the model has been defined as variable dependent. source"},{"id":513,"pagetitle":"Model","title":"CTBase.is_variable_independent","ref":"/ctbase/stable/#CTBase.is_variable_independent-Tuple{OptimalControlModel}","content":" CTBase.is_variable_independent  —  Method is_variable_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as variable independent. source"},{"id":514,"pagetitle":"Model","title":"CTBase.nlp_constraints","ref":"/ctbase/stable/#CTBase.nlp_constraints-Tuple{OptimalControlModel}","content":" CTBase.nlp_constraints  —  Method nlp_constraints(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#99\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#100\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#101\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#102\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#θ#103\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n Return a 6-tuple of tuples: (ξl, ξ, ξu)  are control constraints (ηl, η, ηu)  are state constraints (ψl, ψ, ψu)  are mixed constraints (ϕl, ϕ, ϕu)  are boundary constraints (θl, θ, θu)  are variable constraints (ul, uind, uu)  are control linear constraints of a subset of indices (xl, xind, xu)  are state linear constraints of a subset of indices (vl, vind, vu)  are variable linear constraints of a subset of indices Note The dimensions of the state and control must be set before calling  nlp_constraints . Example julia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints(ocp) source"},{"id":515,"pagetitle":"Model","title":"CTBase.objective!","ref":"/ctbase/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  g  and  f⁰ . Type can be  :bolza . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1 source"},{"id":516,"pagetitle":"Model","title":"CTBase.objective!","ref":"/ctbase/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  f . Type can be  :mayer  or  :lagrange . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1 Warning If you set twice the objective, only the last one will be taken into account. source"},{"id":517,"pagetitle":"Model","title":"CTBase.remove_constraint!","ref":"/ctbase/stable/#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.remove_constraint!  —  Method remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n Remove a labeled constraint. Example julia> remove_constraint!(ocp, :con) source"},{"id":518,"pagetitle":"Model","title":"CTBase.state!","ref":"/ctbase/stable/#CTBase.state!","content":" CTBase.state!  —  Function state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the state dimension and possibly the names of each component. Note You must use state! only once to set the state dimension. Examples julia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"] source"},{"id":519,"pagetitle":"Model","title":"CTBase.time!","ref":"/ctbase/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real,\n    name::String\n)\n Fix final time, initial time is free and given by the variable at the provided index. Examples julia> time!(ocp, Index(2), 1, \"t\") source"},{"id":520,"pagetitle":"Model","title":"CTBase.time!","ref":"/ctbase/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index,\n    name::String\n)\n Initial and final times are free and given by the variable at the provided indices. Examples julia> time!(ocp, Index(2), Index(3), \"t\") source"},{"id":521,"pagetitle":"Model","title":"CTBase.time!","ref":"/ctbase/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(ocp::OptimalControlModel, t0::Real, tf::Real)\ntime!(\n    ocp::OptimalControlModel,\n    t0::Real,\n    tf::Real,\n    name::String\n)\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, 0, 1)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, 0, 1, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, 0, 1, :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\" source"},{"id":522,"pagetitle":"Model","title":"CTBase.time!","ref":"/ctbase/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> Any\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> Any\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, [ 0, 1 ])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [ 0, 1 ], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [ 0, 1 ], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\" source"},{"id":523,"pagetitle":"Model","title":"CTBase.time!","ref":"/ctbase/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index,\n    name::String\n)\n Fix initial time, final time is free and given by the variable at the provided index. Note You must use time! only once to set either the initial or the final time, or both. Examples julia> time!(ocp, 0, Index(2), \"t\") source"},{"id":524,"pagetitle":"Model","title":"CTBase.variable!","ref":"/ctbase/stable/#CTBase.variable!","content":" CTBase.variable!  —  Function variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the variable dimension and possibly the names of each component. Note You can use variable! once to set the variable dimension when the model is  NonFixed . Examples julia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ]) source"},{"id":527,"pagetitle":"Parser","title":"Parser","ref":"/ctbase/stable/#Parser","content":" Parser"},{"id":528,"pagetitle":"Parser","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.constraint_type CTBase.replace_call CTBase.replace_call CTBase.@def"},{"id":529,"pagetitle":"Parser","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":530,"pagetitle":"Parser","title":"CTBase.constraint_type","ref":"/ctbase/stable/#CTBase.constraint_type-NTuple{7, Any}","content":" CTBase.constraint_type  —  Method constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n Return the type constraint among  :initial ,  :final ,  :boundary ,  :control_range ,  :control_fun ,  :state_range ,  :state_fun ,  :mixed ,  :variable_range ,  :variable_fun  ( :other  otherwise), together with the appropriate value (range, updated expression...) Example julia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, Index(1))\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, Index(1))\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, Index(2))\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v ^ 2 + 1))\n\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v[2] ^ 2 + 1)) source"},{"id":531,"pagetitle":"Parser","title":"CTBase.replace_call","ref":"/ctbase/stable/#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Symbol, t, y) -> Any\n Replace calls in e of the form  (...x...)(t)  by  (...y...) . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2) source"},{"id":532,"pagetitle":"Parser","title":"CTBase.replace_call","ref":"/ctbase/stable/#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Vector{Symbol}, t, y) -> Any\n Replace calls in e of the form  (...x1...x2...)(t)  by  (...y1...y2...)  for all symbols  x1 ,  x2 ... in the vector  x . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1]) source"},{"id":533,"pagetitle":"Parser","title":"CTBase.@def","ref":"/ctbase/stable/#CTBase.@def","content":" CTBase.@def  —  Macro Define an optimal control problem. One pass parsing of the definition. Example @def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend source"},{"id":536,"pagetitle":"Plot","title":"Plot","ref":"/ctbase/stable/#Plot","content":" Plot"},{"id":537,"pagetitle":"Plot","title":"RecipesBase.plot!","ref":"/ctbase/stable/#RecipesBase.plot!-Tuple{Plots.Plot, OptimalControlSolution}","content":" RecipesBase.plot!  —  Method plot!(\n    p::Plots.Plot,\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Plots.Plot\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate. source"},{"id":538,"pagetitle":"Plot","title":"RecipesBase.plot","ref":"/ctbase/stable/#RecipesBase.plot-Tuple{OptimalControlSolution}","content":" RecipesBase.plot  —  Method plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Any\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate. source"},{"id":539,"pagetitle":"Plot","title":"Examples","ref":"/ctbase/stable/#Examples","content":" Examples Let us consider we have defined an optimal control problem ocp = Model()\n... and solve it sol = solve(ocp) We can plot the solution with the default layout  :split . plot(sol, layout=:split, size=(800, 600)) Or with the layout  :group . plot(sol, layout=:group, size=(800, 300)) You can specify some styles: plot_sol = plot(sol,\n    state_style=(color=:blue,),\n    costate_style=(color=:black, linestyle=:dash),\n    control_style=(color=:red, linewidth=2),\n    size=(800, 600)) You can also add additional plots with the command  plot! . plot!(plot_sol, sol2,\n    state_style=(color=:purple,),\n    costate_style=(color=:grey, linestyle=:dash),\n    control_style=(color=:pink, linewidth=2),\n    size=(800, 600))"},{"id":542,"pagetitle":"Print","title":"Print","ref":"/ctbase/stable/#Print","content":" Print"},{"id":543,"pagetitle":"Print","title":"Examples","ref":"/ctbase/stable/#Examples","content":" Examples An optimal control problem can be described as minimising the cost functional \\[g(t_0, x(t_0), t_f, x(t_f)) + \\int_{t_0}^{t_f} f^{0}(t, x(t), u(t))~\\mathrm{d}t\\] where the state  $x$  and the control  $u$  are functions subject, for  $t \\in [t_0, t_f]$ , to the differential constraint \\[   \\dot{x}(t) = f(t, x(t), u(t))\\] and other constraints such as \\[\\begin{array}{llcll}\n~\\xi_l  &\\le& \\xi(t, u(t))        &\\le& \\xi_u, \\\\\n\\eta_l &\\le& \\eta(t, x(t))       &\\le& \\eta_u, \\\\\n\\psi_l &\\le& \\psi(t, x(t), u(t)) &\\le& \\psi_u, \\\\\n\\phi_l &\\le& \\phi(t_0, x(t_0), t_f, x(t_f)) &\\le& \\phi_u.\n\\end{array}\\] Let us define the following optimal control problem. using CTBase\n\nocp = Model()\n\nstate!(ocp, 2, \"x\", [\"r\", \"v\"]) # dimension of the state with the names of the components\ncontrol!(ocp, 1)           # dimension of the control\ntime!(ocp, [0, 1], \"s\")    # initial and final time, with the name of the variable time\n\nconstraint!(ocp, :initial, [-1, 0])\nconstraint!(ocp, :final  , [ 0, 0])\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ]\ndynamics!(ocp, (x, u) -> A*x + B*u)\n\nobjective!(ocp, :lagrange, (x, u) -> 0.5u^2) Then, we can print the form of this optimal control problem: ocp Optimal control problem of the form:\n\n    minimize  J(x, u) = ∫ f⁰(x(s), u(s)) ds, over [0, 1]\n\n    subject to\n\n        ẋ(s) = f(x(s), u(s)), s in [0, 1] a.e.,\n\n        ϕl ≤ ϕ(x(0), x(1)) ≤ ϕu, \n\n    where x(s) = (r(s), v(s)) ∈ R² and u(s) ∈ R.\n You can also define the optimal control problem in an abstract form: using CTBase\n\n@def ocp begin\n    t ∈ [ 0, 1 ], time\n    x ∈ R^2, state\n    u ∈ R, control\n    x(0) == [ -1, 0 ], (1)\n    x(1) == [  0, 0 ]\n    ẋ(t) == A * x(t) + B * u(t)\n    ∫( 0.5u(t)^2 ) → min\nend\nA = [ 0 1\n      0 0 ]\nB = [ 0\n      1 ] Then, you can print this optimal control problem: ocp t ∈ [0, 1], time\nx ∈ R ^ 2, state\nu ∈ R, control\nx(0) == [-1, 0], 1\nx(1) == [0, 0]\nẋ(t) == A * x(t) + B * u(t)\n∫(0.5 * u(t) ^ 2) → min\n"},{"id":546,"pagetitle":"Types and functions","title":"Types and functions","ref":"/ctbase/stable/#api-types","content":" Types and functions"},{"id":547,"pagetitle":"Types and functions","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.AbstractHamiltonian CTBase.Autonomous CTBase.BoundaryConstraint CTBase.ControlConstraint CTBase.ControlLaw CTBase.Dynamics CTBase.FeedbackControl CTBase.Fixed CTBase.Hamiltonian CTBase.HamiltonianLift CTBase.HamiltonianVectorField CTBase.Index CTBase.Lagrange CTBase.Mayer CTBase.MixedConstraint CTBase.Multiplier CTBase.NonAutonomous CTBase.NonFixed CTBase.OptimalControlModel CTBase.OptimalControlSolution CTBase.StateConstraint CTBase.TimeDependence CTBase.VariableConstraint CTBase.VariableDependence CTBase.VectorField"},{"id":548,"pagetitle":"Types and functions","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":549,"pagetitle":"Types and functions","title":"CTBase.AbstractHamiltonian","ref":"/ctbase/stable/#CTBase.AbstractHamiltonian","content":" CTBase.AbstractHamiltonian  —  Type abstract type AbstractHamiltonian{time_dependence, variable_dependence} Abstract type for hamiltonians. source"},{"id":550,"pagetitle":"Types and functions","title":"CTBase.Autonomous","ref":"/ctbase/stable/#CTBase.Autonomous","content":" CTBase.Autonomous  —  Type abstract type Autonomous <: TimeDependence source"},{"id":551,"pagetitle":"Types and functions","title":"CTBase.BoundaryConstraint","ref":"/ctbase/stable/#CTBase.BoundaryConstraint","content":" CTBase.BoundaryConstraint  —  Type struct BoundaryConstraint{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  BoundaryConstraint  returns a  BoundaryConstraint  of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. When the constraint is dimension 1, return a scalar. Call The call returns the evaluation of the  BoundaryConstraint  for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1] source"},{"id":552,"pagetitle":"Types and functions","title":"CTBase.ControlConstraint","ref":"/ctbase/stable/#CTBase.ControlConstraint","content":" CTBase.ControlConstraint  —  Type struct ControlConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlConstraint  returns a  ControlConstraint  of a function. The function must take 1 to 3 arguments,  u  to  (t, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true) Warning When the control is of dimension 1, consider  u  as a scalar. Call The call returns the evaluation of the  ControlConstraint  for given values. Examples julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1] source"},{"id":553,"pagetitle":"Types and functions","title":"CTBase.ControlLaw","ref":"/ctbase/stable/#CTBase.ControlLaw","content":" CTBase.ControlLaw  —  Type struct ControlLaw{time_dependence, variable_dependence} Fields f::Function Similar to  Hamiltonian  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlLaw  returns a  ControlLaw  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  ControlLaw  for given values. Examples julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7 source"},{"id":554,"pagetitle":"Types and functions","title":"CTBase.Dynamics","ref":"/ctbase/stable/#CTBase.Dynamics","content":" CTBase.Dynamics  —  Type struct Dynamics{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Dynamics  returns a  Dynamics  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Dynamics  for given values. Examples julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1] source"},{"id":555,"pagetitle":"Types and functions","title":"CTBase.FeedbackControl","ref":"/ctbase/stable/#CTBase.FeedbackControl","content":" CTBase.FeedbackControl  —  Type struct FeedbackControl{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  FeedbackControl  returns a  FeedbackControl  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  FeedbackControl  for given values. Examples julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5 source"},{"id":556,"pagetitle":"Types and functions","title":"CTBase.Fixed","ref":"/ctbase/stable/#CTBase.Fixed","content":" CTBase.Fixed  —  Type abstract type Fixed <: VariableDependence source"},{"id":557,"pagetitle":"Types and functions","title":"CTBase.Hamiltonian","ref":"/ctbase/stable/#CTBase.Hamiltonian","content":" CTBase.Hamiltonian  —  Type struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Hamiltonian  returns a  Hamiltonian  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Hamiltonian  for given values. Examples julia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7 source"},{"id":558,"pagetitle":"Types and functions","title":"CTBase.HamiltonianLift","ref":"/ctbase/stable/#CTBase.HamiltonianLift","content":" CTBase.HamiltonianLift  —  Type struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Lifts X::VectorField The values for  time_dependence  and  variable_dependence  are deternimed by the values of those for the VectorField. Constructor The constructor  HamiltonianLift  returns a  HamiltonianLift  of a  VectorField . Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianLift  for given values. Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3 Alternatively, it is possible to construct the  HamiltonianLift  from a  Function  being the  VectorField . julia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue source"},{"id":559,"pagetitle":"Types and functions","title":"CTBase.HamiltonianVectorField","ref":"/ctbase/stable/#CTBase.HamiltonianVectorField","content":" CTBase.HamiltonianVectorField  —  Type struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  HamiltonianVectorField  returns a  HamiltonianVectorField  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianVectorField  for given values. Examples julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3] source"},{"id":560,"pagetitle":"Types and functions","title":"CTBase.Index","ref":"/ctbase/stable/#CTBase.Index","content":" CTBase.Index  —  Type mutable struct Index Fields val::Integer source"},{"id":561,"pagetitle":"Types and functions","title":"CTBase.Lagrange","ref":"/ctbase/stable/#CTBase.Lagrange","content":" CTBase.Lagrange  —  Type struct Lagrange{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Lagrange  returns a  Lagrange  cost of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Lagrange  cost for given values. Examples julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3 source"},{"id":562,"pagetitle":"Types and functions","title":"CTBase.Mayer","ref":"/ctbase/stable/#CTBase.Mayer","content":" CTBase.Mayer  —  Type struct Mayer{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  Mayer  returns a  Mayer  cost of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. Call The call returns the evaluation of the  Mayer  cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4 source"},{"id":563,"pagetitle":"Types and functions","title":"CTBase.MixedConstraint","ref":"/ctbase/stable/#CTBase.MixedConstraint","content":" CTBase.MixedConstraint  —  Type struct MixedConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  Lagrange  in the usage, but the dimension of the output of the function  f  is arbitrary. The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  MixedConstraint  returns a  MixedConstraint  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  MixedConstraint  for given values. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1] source"},{"id":564,"pagetitle":"Types and functions","title":"CTBase.Multiplier","ref":"/ctbase/stable/#CTBase.Multiplier","content":" CTBase.Multiplier  —  Type struct Multiplier{time_dependence, variable_dependence} Fields f::Function Similar to  ControlLaw  in the usage. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Multiplier  returns a  Multiplier  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Multiplier  for given values. Examples julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7 source"},{"id":565,"pagetitle":"Types and functions","title":"CTBase.NonAutonomous","ref":"/ctbase/stable/#CTBase.NonAutonomous","content":" CTBase.NonAutonomous  —  Type abstract type NonAutonomous <: TimeDependence source"},{"id":566,"pagetitle":"Types and functions","title":"CTBase.NonFixed","ref":"/ctbase/stable/#CTBase.NonFixed","content":" CTBase.NonFixed  —  Type abstract type NonFixed <: VariableDependence source"},{"id":567,"pagetitle":"Types and functions","title":"CTBase.OptimalControlModel","ref":"/ctbase/stable/#CTBase.OptimalControlModel","content":" CTBase.OptimalControlModel  —  Type mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel Fields model_expression::Union{Nothing, Expr} : Default: nothing initial_time::Union{Nothing, Index, Real} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time::Union{Nothing, Index, Real} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing lagrange::Union{Nothing, Lagrange} : Default: nothing mayer::Union{Nothing, Mayer} : Default: nothing criterion::Union{Nothing, Symbol} : Default: nothing dynamics::Union{Nothing, Dynamics} : Default: nothing constraints::Dict{Symbol, Tuple} : Default: Dict{Symbol, Tuple{Vararg{Any}}}() source"},{"id":568,"pagetitle":"Types and functions","title":"CTBase.OptimalControlSolution","ref":"/ctbase/stable/#CTBase.OptimalControlSolution","content":" CTBase.OptimalControlSolution  —  Type mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution Type of an optimal control solution. Fields times::Union{Nothing, StepRangeLen, AbstractVector{<:Real}} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing control::Union{Nothing, Function} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing state::Union{Nothing, Function} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing variable::Union{Nothing, Real, AbstractVector{<:Real}} : Default: nothing costate::Union{Nothing, Function} : Default: nothing objective::Union{Nothing, Real} : Default: nothing iterations::Union{Nothing, Integer} : Default: nothing stopping::Union{Nothing, Symbol} : Default: nothing message::Union{Nothing, String} : Default: nothing success::Union{Nothing, Bool} : Default: nothing infos::Dict{Symbol, Any} : Default: Dict{Symbol, Any}() source"},{"id":569,"pagetitle":"Types and functions","title":"CTBase.StateConstraint","ref":"/ctbase/stable/#CTBase.StateConstraint","content":" CTBase.StateConstraint  —  Type struct StateConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  StateConstraint  returns a  StateConstraint  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  StateConstraint  for given values. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1] source"},{"id":570,"pagetitle":"Types and functions","title":"CTBase.TimeDependence","ref":"/ctbase/stable/#CTBase.TimeDependence","content":" CTBase.TimeDependence  —  Type abstract type TimeDependence source"},{"id":571,"pagetitle":"Types and functions","title":"CTBase.VariableConstraint","ref":"/ctbase/stable/#CTBase.VariableConstraint","content":" CTBase.VariableConstraint  —  Type struct VariableConstraint Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VariableConstraint  returns a  VariableConstraint  of a function. The function must take 1 argument,  v . Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]]) Warning When the variable is of dimension 1, consider  v  as a scalar. Call The call returns the evaluation of the  VariableConstraint  for given values. Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2] source"},{"id":572,"pagetitle":"Types and functions","title":"CTBase.VariableDependence","ref":"/ctbase/stable/#CTBase.VariableDependence","content":" CTBase.VariableDependence  —  Type abstract type VariableDependence source"},{"id":573,"pagetitle":"Types and functions","title":"CTBase.VectorField","ref":"/ctbase/stable/#CTBase.VectorField","content":" CTBase.VectorField  —  Type struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VectorField  returns a  VectorField  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  VectorField  for given values. Examples julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1] source"},{"id":576,"pagetitle":"Utils","title":"Utils","ref":"/ctbase/stable/#Utils","content":" Utils"},{"id":577,"pagetitle":"Utils","title":"Index","ref":"/ctbase/stable/#Index","content":" Index CTBase.ctgradient CTBase.ctgradient CTBase.ctgradient CTBase.ctindices CTBase.ctinterpolate CTBase.ctjacobian CTBase.ctjacobian CTBase.ctjacobian CTBase.ctupperscripts"},{"id":578,"pagetitle":"Utils","title":"Documentation","ref":"/ctbase/stable/#Documentation","content":" Documentation"},{"id":579,"pagetitle":"Utils","title":"CTBase.ctgradient","ref":"/ctbase/stable/#CTBase.ctgradient-Tuple{Function, Any}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x) -> Any\n Return the gradient of  f  at  x . source"},{"id":580,"pagetitle":"Utils","title":"CTBase.ctgradient","ref":"/ctbase/stable/#CTBase.ctgradient-Tuple{Function, Real}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x::Real) -> Any\n Return the gradient of  f  at  x . source"},{"id":581,"pagetitle":"Utils","title":"CTBase.ctgradient","ref":"/ctbase/stable/#CTBase.ctgradient-Tuple{VectorField, Any}","content":" CTBase.ctgradient  —  Method ctgradient(X::VectorField, x) -> Any\n Return the gradient of  X  at  x . source"},{"id":582,"pagetitle":"Utils","title":"CTBase.ctindices","ref":"/ctbase/stable/#CTBase.ctindices-Tuple{Integer}","content":" CTBase.ctindices  —  Method ctindices(i::Integer) -> String\n Return  i  > 0 as a subscript. source"},{"id":583,"pagetitle":"Utils","title":"CTBase.ctinterpolate","ref":"/ctbase/stable/#CTBase.ctinterpolate-Tuple{Any, Any}","content":" CTBase.ctinterpolate  —  Method ctinterpolate(x, f) -> Any\n Return the interpolation of  f  at  x . source"},{"id":584,"pagetitle":"Utils","title":"CTBase.ctjacobian","ref":"/ctbase/stable/#CTBase.ctjacobian-Tuple{Function, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x) -> Any\n Return the Jacobian of  f  at  x . source"},{"id":585,"pagetitle":"Utils","title":"CTBase.ctjacobian","ref":"/ctbase/stable/#CTBase.ctjacobian-Tuple{Function, Real}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x::Real) -> Any\n Return the Jacobian of  f  at  x . source"},{"id":586,"pagetitle":"Utils","title":"CTBase.ctjacobian","ref":"/ctbase/stable/#CTBase.ctjacobian-Tuple{VectorField, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(X::VectorField, x) -> Any\n Return the Jacobian of  X  at  x . source"},{"id":587,"pagetitle":"Utils","title":"CTBase.ctupperscripts","ref":"/ctbase/stable/#CTBase.ctupperscripts-Tuple{Integer}","content":" CTBase.ctupperscripts  —  Method ctupperscripts(i::Integer) -> String\n Return  i  > 0 as an upperscript. source"},{"id":590,"pagetitle":"Introduction","title":"CTBase.jl","ref":"/ctbase/stable/#CTBase.jl","content":" CTBase.jl The  CTBase.jl  package is part of the  control-toolbox ecosystem . Install To install a package from the control-toolbox ecosystem,  please visit the  installation page . You may find in this package, some tools to: modelise an optimal control problem (see  OptimalControlModel ) from an abstract point of view (see  @def  from  Parser ) or from a functional point of view (see  Model ). print an optimal control problem: see  Print . plot a solution (see  OptimalControlSolution ) of an optimal control problem: see  Plot . compute  Lie brackets ,  Poisson brackets  and some other tools from  differential geometry : see  Differential geometry . manipulate tuples of symbols: see  Description . You may find the  imported modules and exported names  but also the different types of  exceptions  and  functions  specific to the control-toolbox ecosystem."},{"id":595,"pagetitle":"CTBase API","title":"CTBase API","ref":"/ctdirect/stable/#CTBase-API","content":" CTBase API This is just a dump of CTBase API documentation. For more details about  CTBase.jl  package, see the  documentation ."},{"id":596,"pagetitle":"CTBase API","title":"Index","ref":"/ctdirect/stable/#Index","content":" Index CTBase.CTBase CTBase.AbstractHamiltonian CTBase.AmbiguousDescription CTBase.Autonomous CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.BoundaryConstraint CTBase.CTCallback CTBase.CTCallbacks CTBase.CTException CTBase.Control CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlConstraint CTBase.ControlLaw CTBase.ControlLaw CTBase.ControlLaw CTBase.ControlLaw CTBase.Controls CTBase.Costate CTBase.Costates CTBase.DCostate CTBase.DState CTBase.Description CTBase.Dimension CTBase.Dynamics CTBase.Dynamics CTBase.Dynamics CTBase.Dynamics CTBase.FeedbackControl CTBase.FeedbackControl CTBase.FeedbackControl CTBase.FeedbackControl CTBase.Fixed CTBase.Hamiltonian CTBase.Hamiltonian CTBase.Hamiltonian CTBase.Hamiltonian CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianLift CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.HamiltonianVectorField CTBase.IncorrectArgument CTBase.IncorrectMethod CTBase.IncorrectOutput CTBase.Index CTBase.Lagrange CTBase.Lagrange CTBase.Lagrange CTBase.Lagrange CTBase.Mayer CTBase.Mayer CTBase.Mayer CTBase.Mayer CTBase.MixedConstraint CTBase.MixedConstraint CTBase.MixedConstraint CTBase.MixedConstraint CTBase.Multiplier CTBase.Multiplier CTBase.Multiplier CTBase.Multiplier CTBase.NonAutonomous CTBase.NonFixed CTBase.NotImplemented CTBase.OptimalControlModel CTBase.OptimalControlSolution CTBase.ParsingError CTBase.PrintCallback CTBase.PrintCallback CTBase.State CTBase.StateConstraint CTBase.StateConstraint CTBase.StateConstraint CTBase.StateConstraint CTBase.States CTBase.StopCallback CTBase.StopCallback CTBase.Time CTBase.TimeDependence CTBase.Times CTBase.TimesDisc CTBase.UnauthorizedCall CTBase.Variable CTBase.VariableConstraint CTBase.VariableConstraint CTBase.VariableDependence CTBase.VectorField CTBase.VectorField CTBase.VectorField CTBase.VectorField CTBase.ctNumber CTBase.ctVector CTBase.:⋅ CTBase.:⋅ CTBase.:⋅ CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lie CTBase.Lift CTBase.Lift CTBase.Lift CTBase.Model CTBase.Model CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.Poisson CTBase.add CTBase.add CTBase.constraint CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint! CTBase.constraint_type CTBase.constraints_labels CTBase.control! CTBase.ct_repl CTBase.ctgradient CTBase.ctgradient CTBase.ctgradient CTBase.ctindices CTBase.ctinterpolate CTBase.ctjacobian CTBase.ctjacobian CTBase.ctjacobian CTBase.ctupperscripts CTBase.dynamics! CTBase.getFullDescription CTBase.get_priority_print_callbacks CTBase.get_priority_stop_callbacks CTBase.is_max CTBase.is_min CTBase.is_time_dependent CTBase.is_time_independent CTBase.is_variable_dependent CTBase.is_variable_independent CTBase.nlp_constraints CTBase.objective! CTBase.objective! CTBase.remove_constraint! CTBase.replace_call CTBase.replace_call CTBase.state! CTBase.time! CTBase.time! CTBase.time! CTBase.time! CTBase.time! CTBase.variable! CTBase.∂ₜ CTBase.@Lie CTBase.@def"},{"id":597,"pagetitle":"CTBase API","title":"Documentation","ref":"/ctdirect/stable/#Documentation","content":" Documentation"},{"id":598,"pagetitle":"CTBase API","title":"CTBase.CTBase","ref":"/ctdirect/stable/#CTBase.CTBase","content":" CTBase.CTBase  —  Module CTBase  module. Lists all the imported modules and packages: Base Core DataStructures DocStringExtensions LinearAlgebra MLStyle Parameters Plots PrettyTables Printf ReplMaker Unicode List of all the exported names: AbstractHamiltonian AmbiguousDescription Autonomous BoundaryConstraint CTCallback CTCallbacks CTException Control ControlConstraint ControlLaw Controls Costate Costates DCostate DState Description Dimension Dynamics FeedbackControl Fixed Hamiltonian HamiltonianLift HamiltonianVectorField IncorrectArgument IncorrectMethod IncorrectOutput Index Lagrange @Lie Lie Lift Mayer MixedConstraint Model Multiplier NonAutonomous NonFixed NotImplemented OptimalControlModel OptimalControlSolution ParsingError Poisson PrintCallback State StateConstraint States StopCallback Time TimeDependence Times TimesDisc UnauthorizedCall Variable VariableConstraint VariableDependence VectorField add constraint constraint! constraint_type constraints_labels control! ctNumber ctVector ct_repl ctgradient ctindices ctinterpolate ctjacobian ctupperscripts @def dynamics! getFullDescription get_priority_print_callbacks get_priority_stop_callbacks is_max is_min is_time_dependent is_time_independent is_variable_dependent is_variable_independent nlp_constraints objective! plot plot! remove_constraint! replace_call state! time! variable! ∂ₜ ⋅"},{"id":599,"pagetitle":"CTBase API","title":"CTBase.Control","ref":"/ctdirect/stable/#CTBase.Control","content":" CTBase.Control  —  Type Type alias for a control."},{"id":600,"pagetitle":"CTBase API","title":"CTBase.Costate","ref":"/ctdirect/stable/#CTBase.Costate","content":" CTBase.Costate  —  Type Type alias for an costate."},{"id":601,"pagetitle":"CTBase API","title":"CTBase.DCostate","ref":"/ctdirect/stable/#CTBase.DCostate","content":" CTBase.DCostate  —  Type Type alias for a tangent vector to the costate space."},{"id":602,"pagetitle":"CTBase API","title":"CTBase.DState","ref":"/ctdirect/stable/#CTBase.DState","content":" CTBase.DState  —  Type Type alias for a tangent vector to the state space."},{"id":603,"pagetitle":"CTBase API","title":"CTBase.State","ref":"/ctdirect/stable/#CTBase.State","content":" CTBase.State  —  Type Type alias for a state."},{"id":604,"pagetitle":"CTBase API","title":"CTBase.TimesDisc","ref":"/ctdirect/stable/#CTBase.TimesDisc","content":" CTBase.TimesDisc  —  Type Type alias for a grid of times."},{"id":605,"pagetitle":"CTBase API","title":"CTBase.Variable","ref":"/ctdirect/stable/#CTBase.Variable","content":" CTBase.Variable  —  Type Type alias for a variable."},{"id":606,"pagetitle":"CTBase API","title":"CTBase.ctVector","ref":"/ctdirect/stable/#CTBase.ctVector","content":" CTBase.ctVector  —  Type Type alias for a vector of real numbers."},{"id":607,"pagetitle":"CTBase API","title":"CTBase.AbstractHamiltonian","ref":"/ctdirect/stable/#CTBase.AbstractHamiltonian","content":" CTBase.AbstractHamiltonian  —  Type abstract type AbstractHamiltonian{time_dependence, variable_dependence} Abstract type for hamiltonians."},{"id":608,"pagetitle":"CTBase API","title":"CTBase.AmbiguousDescription","ref":"/ctdirect/stable/#CTBase.AmbiguousDescription","content":" CTBase.AmbiguousDescription  —  Type struct AmbiguousDescription <: CTException Exception thrown when the description is ambiguous / incorrect. Fields var::Tuple{Vararg{Symbol}}"},{"id":609,"pagetitle":"CTBase API","title":"CTBase.Autonomous","ref":"/ctdirect/stable/#CTBase.Autonomous","content":" CTBase.Autonomous  —  Type abstract type Autonomous <: TimeDependence"},{"id":610,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctdirect/stable/#CTBase.BoundaryConstraint","content":" CTBase.BoundaryConstraint  —  Type struct BoundaryConstraint{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  BoundaryConstraint  returns a  BoundaryConstraint  of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. When the constraint is dimension 1, return a scalar. Call The call returns the evaluation of the  BoundaryConstraint  for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]"},{"id":611,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctdirect/stable/#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.BoundaryConstraint  —  Method BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...;\n    variable\n) -> BoundaryConstraint\n Return a  BoundaryConstraint  of a function. Dependencies are specified with a DataType: NonFixed/Fixed or with a boolean, variable, false by default. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2], Fixed)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)"},{"id":612,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctdirect/stable/#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.BoundaryConstraint  —  Method Return the evaluation of the BoundaryConstraint at  x0 ,  xf ,  v . julia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]"},{"id":613,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctdirect/stable/#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.BoundaryConstraint  —  Method Return the evaluation of the BoundaryConstraint at  x0 ,  xf . julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]"},{"id":614,"pagetitle":"CTBase API","title":"CTBase.CTCallback","ref":"/ctdirect/stable/#CTBase.CTCallback","content":" CTBase.CTCallback  —  Type abstract type CTCallback Abstract type for callbacks."},{"id":615,"pagetitle":"CTBase API","title":"CTBase.CTCallbacks","ref":"/ctdirect/stable/#CTBase.CTCallbacks","content":" CTBase.CTCallbacks  —  Type Tuple of callbacks"},{"id":616,"pagetitle":"CTBase API","title":"CTBase.CTException","ref":"/ctdirect/stable/#CTBase.CTException","content":" CTBase.CTException  —  Type abstract type CTException <: Exception Abstract type for exceptions."},{"id":617,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctdirect/stable/#CTBase.ControlConstraint","content":" CTBase.ControlConstraint  —  Type struct ControlConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlConstraint  returns a  ControlConstraint  of a function. The function must take 1 to 3 arguments,  u  to  (t, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true) Warning When the control is of dimension 1, consider  u  as a scalar. Call The call returns the evaluation of the  ControlConstraint  for given values. Examples julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":618,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctdirect/stable/#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)"},{"id":619,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctdirect/stable/#CTBase.ControlConstraint-Tuple{Function}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  ControlConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)"},{"id":620,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctdirect/stable/#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlConstraint  —  Method Return the value of the ControlConstraint function. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":621,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctdirect/stable/#CTBase.ControlLaw","content":" CTBase.ControlLaw  —  Type struct ControlLaw{time_dependence, variable_dependence} Fields f::Function Similar to  Hamiltonian  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlLaw  returns a  ControlLaw  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  ControlLaw  for given values. Examples julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":622,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctdirect/stable/#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)"},{"id":623,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctdirect/stable/#CTBase.ControlLaw-Tuple{Function}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)"},{"id":624,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctdirect/stable/#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlLaw  —  Method Return the value of the ControlLaw function. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":625,"pagetitle":"CTBase API","title":"CTBase.Controls","ref":"/ctdirect/stable/#CTBase.Controls","content":" CTBase.Controls  —  Type Type alias for a vector of controls."},{"id":626,"pagetitle":"CTBase API","title":"CTBase.Costates","ref":"/ctdirect/stable/#CTBase.Costates","content":" CTBase.Costates  —  Type Type alias for a vector of costates."},{"id":627,"pagetitle":"CTBase API","title":"CTBase.Description","ref":"/ctdirect/stable/#CTBase.Description","content":" CTBase.Description  —  Type A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}."},{"id":628,"pagetitle":"CTBase API","title":"CTBase.Dimension","ref":"/ctdirect/stable/#CTBase.Dimension","content":" CTBase.Dimension  —  Type Type alias for a dimension."},{"id":629,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctdirect/stable/#CTBase.Dynamics","content":" CTBase.Dynamics  —  Type struct Dynamics{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Dynamics  returns a  Dynamics  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Dynamics  for given values. Examples julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":630,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctdirect/stable/#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)"},{"id":631,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctdirect/stable/#CTBase.Dynamics-Tuple{Function}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)"},{"id":632,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctdirect/stable/#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Dynamics  —  Method Return the value of the Dynamics function. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":633,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctdirect/stable/#CTBase.FeedbackControl","content":" CTBase.FeedbackControl  —  Type struct FeedbackControl{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  FeedbackControl  returns a  FeedbackControl  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  FeedbackControl  for given values. Examples julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5"},{"id":634,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctdirect/stable/#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)"},{"id":635,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctdirect/stable/#CTBase.FeedbackControl-Tuple{Function}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)"},{"id":636,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctdirect/stable/#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.FeedbackControl  —  Method Return the value of the FeedbackControl function. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5"},{"id":637,"pagetitle":"CTBase API","title":"CTBase.Fixed","ref":"/ctdirect/stable/#CTBase.Fixed","content":" CTBase.Fixed  —  Type abstract type Fixed <: VariableDependence"},{"id":638,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctdirect/stable/#CTBase.Hamiltonian","content":" CTBase.Hamiltonian  —  Type struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Hamiltonian  returns a  Hamiltonian  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Hamiltonian  for given values. Examples julia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":639,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctdirect/stable/#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)"},{"id":640,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctdirect/stable/#CTBase.Hamiltonian-Tuple{Function}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)"},{"id":641,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctdirect/stable/#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Hamiltonian  —  Method Return the value of the Hamiltonian. julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":642,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctdirect/stable/#CTBase.HamiltonianLift","content":" CTBase.HamiltonianLift  —  Type struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Lifts X::VectorField The values for  time_dependence  and  variable_dependence  are deternimed by the values of those for the VectorField. Constructor The constructor  HamiltonianLift  returns a  HamiltonianLift  of a  VectorField . Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianLift  for given values. Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3 Alternatively, it is possible to construct the  HamiltonianLift  from a  Function  being the  VectorField . julia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue"},{"id":643,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctdirect/stable/#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)"},{"id":644,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctdirect/stable/#CTBase.HamiltonianLift-Tuple{Function}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)"},{"id":645,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctdirect/stable/#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianLift  —  Method Return the value of the HamiltonianLift. Examples julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3"},{"id":646,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctdirect/stable/#CTBase.HamiltonianVectorField","content":" CTBase.HamiltonianVectorField  —  Type struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  HamiltonianVectorField  returns a  HamiltonianVectorField  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianVectorField  for given values. Examples julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]"},{"id":647,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctdirect/stable/#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)"},{"id":648,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctdirect/stable/#CTBase.HamiltonianVectorField-Tuple{Function}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)"},{"id":649,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctdirect/stable/#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianVectorField  —  Method Return the value of the HamiltonianVectorField. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]"},{"id":650,"pagetitle":"CTBase API","title":"CTBase.IncorrectArgument","ref":"/ctdirect/stable/#CTBase.IncorrectArgument","content":" CTBase.IncorrectArgument  —  Type struct IncorrectArgument <: CTException Exception thrown when an argument is inconsistent. Fields var::String"},{"id":651,"pagetitle":"CTBase API","title":"CTBase.IncorrectMethod","ref":"/ctdirect/stable/#CTBase.IncorrectMethod","content":" CTBase.IncorrectMethod  —  Type struct IncorrectMethod <: CTException Exception thrown when a method is incorrect. Fields var::Symbol"},{"id":652,"pagetitle":"CTBase API","title":"CTBase.IncorrectOutput","ref":"/ctdirect/stable/#CTBase.IncorrectOutput","content":" CTBase.IncorrectOutput  —  Type struct IncorrectOutput <: CTException Exception thrown when the output is incorrect. Fields var::String"},{"id":653,"pagetitle":"CTBase API","title":"CTBase.Index","ref":"/ctdirect/stable/#CTBase.Index","content":" CTBase.Index  —  Type mutable struct Index Fields val::Integer"},{"id":654,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctdirect/stable/#CTBase.Lagrange","content":" CTBase.Lagrange  —  Type struct Lagrange{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Lagrange  returns a  Lagrange  cost of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Lagrange  cost for given values. Examples julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3"},{"id":655,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctdirect/stable/#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n"},{"id":656,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctdirect/stable/#CTBase.Lagrange-Tuple{Function}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n"},{"id":657,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctdirect/stable/#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Lagrange  —  Method Return the value of the Lagrange function. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3"},{"id":658,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctdirect/stable/#CTBase.Mayer","content":" CTBase.Mayer  —  Type struct Mayer{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  Mayer  returns a  Mayer  cost of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. Call The call returns the evaluation of the  Mayer  cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4"},{"id":659,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctdirect/stable/#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","content":" CTBase.Mayer  —  Method Mayer(\n    f::Function,\n    dependencies::DataType...;\n    variable\n) -> Mayer\n Return a  Mayer  cost of a function. Dependencies are specified with a DataType: NonFixed/Fixed, or with a boolean, variable, false by default. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1], Fixed)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)"},{"id":660,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctdirect/stable/#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Mayer  —  Method Return the evaluation of the Mayer cost at  x0 ,  xf ,  v . julia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4"},{"id":661,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctdirect/stable/#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Mayer  —  Method Return the evaluation of the Mayer cost at  x0 ,  xf . julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1"},{"id":662,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctdirect/stable/#CTBase.MixedConstraint","content":" CTBase.MixedConstraint  —  Type struct MixedConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  Lagrange  in the usage, but the dimension of the output of the function  f  is arbitrary. The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  MixedConstraint  returns a  MixedConstraint  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  MixedConstraint  for given values. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":663,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctdirect/stable/#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)"},{"id":664,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctdirect/stable/#CTBase.MixedConstraint-Tuple{Function}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)"},{"id":665,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctdirect/stable/#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.MixedConstraint  —  Method Return the value of the MixedConstraint function. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":666,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctdirect/stable/#CTBase.Multiplier","content":" CTBase.Multiplier  —  Type struct Multiplier{time_dependence, variable_dependence} Fields f::Function Similar to  ControlLaw  in the usage. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Multiplier  returns a  Multiplier  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Multiplier  for given values. Examples julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":667,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctdirect/stable/#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)"},{"id":668,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctdirect/stable/#CTBase.Multiplier-Tuple{Function}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)"},{"id":669,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctdirect/stable/#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Multiplier  —  Method Return the value of the Multiplier function. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":670,"pagetitle":"CTBase API","title":"CTBase.NonAutonomous","ref":"/ctdirect/stable/#CTBase.NonAutonomous","content":" CTBase.NonAutonomous  —  Type abstract type NonAutonomous <: TimeDependence"},{"id":671,"pagetitle":"CTBase API","title":"CTBase.NonFixed","ref":"/ctdirect/stable/#CTBase.NonFixed","content":" CTBase.NonFixed  —  Type abstract type NonFixed <: VariableDependence"},{"id":672,"pagetitle":"CTBase API","title":"CTBase.NotImplemented","ref":"/ctdirect/stable/#CTBase.NotImplemented","content":" CTBase.NotImplemented  —  Type struct NotImplemented <: CTException Exception thrown when a method is not implemented. Fields var::String"},{"id":673,"pagetitle":"CTBase API","title":"CTBase.OptimalControlModel","ref":"/ctdirect/stable/#CTBase.OptimalControlModel","content":" CTBase.OptimalControlModel  —  Type mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel Fields model_expression::Union{Nothing, Expr} : Default: nothing initial_time::Union{Nothing, Index, Real} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time::Union{Nothing, Index, Real} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing lagrange::Union{Nothing, Lagrange} : Default: nothing mayer::Union{Nothing, Mayer} : Default: nothing criterion::Union{Nothing, Symbol} : Default: nothing dynamics::Union{Nothing, Dynamics} : Default: nothing constraints::Dict{Symbol, Tuple} : Default: Dict{Symbol, Tuple{Vararg{Any}}}()"},{"id":674,"pagetitle":"CTBase API","title":"CTBase.OptimalControlSolution","ref":"/ctdirect/stable/#CTBase.OptimalControlSolution","content":" CTBase.OptimalControlSolution  —  Type mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution Type of an optimal control solution. Fields times::Union{Nothing, StepRangeLen, AbstractVector{<:Real}} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing control::Union{Nothing, Function} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing state::Union{Nothing, Function} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing variable::Union{Nothing, Real, AbstractVector{<:Real}} : Default: nothing costate::Union{Nothing, Function} : Default: nothing objective::Union{Nothing, Real} : Default: nothing iterations::Union{Nothing, Integer} : Default: nothing stopping::Union{Nothing, Symbol} : Default: nothing message::Union{Nothing, String} : Default: nothing success::Union{Nothing, Bool} : Default: nothing infos::Dict{Symbol, Any} : Default: Dict{Symbol, Any}()"},{"id":675,"pagetitle":"CTBase API","title":"CTBase.ParsingError","ref":"/ctdirect/stable/#CTBase.ParsingError","content":" CTBase.ParsingError  —  Type struct ParsingError <: CTException Exception thrown for syntax error during abstract parsing. Fields var::String"},{"id":676,"pagetitle":"CTBase API","title":"CTBase.PrintCallback","ref":"/ctdirect/stable/#CTBase.PrintCallback","content":" CTBase.PrintCallback  —  Type mutable struct PrintCallback <: CTCallback Callback for printing."},{"id":677,"pagetitle":"CTBase API","title":"CTBase.PrintCallback","ref":"/ctdirect/stable/#CTBase.PrintCallback-Tuple","content":" CTBase.PrintCallback  —  Method Call the callback."},{"id":678,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctdirect/stable/#CTBase.StateConstraint","content":" CTBase.StateConstraint  —  Type struct StateConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  StateConstraint  returns a  StateConstraint  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  StateConstraint  for given values. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":679,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctdirect/stable/#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)"},{"id":680,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctdirect/stable/#CTBase.StateConstraint-Tuple{Function}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)"},{"id":681,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctdirect/stable/#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.StateConstraint  —  Method Return the value of the StateConstraint function. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":682,"pagetitle":"CTBase API","title":"CTBase.States","ref":"/ctdirect/stable/#CTBase.States","content":" CTBase.States  —  Type Type alias for a vector of states."},{"id":683,"pagetitle":"CTBase API","title":"CTBase.StopCallback","ref":"/ctdirect/stable/#CTBase.StopCallback","content":" CTBase.StopCallback  —  Type Stopping callback."},{"id":684,"pagetitle":"CTBase API","title":"CTBase.StopCallback","ref":"/ctdirect/stable/#CTBase.StopCallback-Tuple","content":" CTBase.StopCallback  —  Method Call the callback."},{"id":685,"pagetitle":"CTBase API","title":"CTBase.Time","ref":"/ctdirect/stable/#CTBase.Time","content":" CTBase.Time  —  Type Type alias for a time."},{"id":686,"pagetitle":"CTBase API","title":"CTBase.TimeDependence","ref":"/ctdirect/stable/#CTBase.TimeDependence","content":" CTBase.TimeDependence  —  Type abstract type TimeDependence"},{"id":687,"pagetitle":"CTBase API","title":"CTBase.Times","ref":"/ctdirect/stable/#CTBase.Times","content":" CTBase.Times  —  Type Type alias for a vector of times."},{"id":688,"pagetitle":"CTBase API","title":"CTBase.UnauthorizedCall","ref":"/ctdirect/stable/#CTBase.UnauthorizedCall","content":" CTBase.UnauthorizedCall  —  Type struct UnauthorizedCall <: CTException Exception thrown when a call to a function is not authorized. Fields var::String"},{"id":689,"pagetitle":"CTBase API","title":"CTBase.VariableConstraint","ref":"/ctdirect/stable/#CTBase.VariableConstraint","content":" CTBase.VariableConstraint  —  Type struct VariableConstraint Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VariableConstraint  returns a  VariableConstraint  of a function. The function must take 1 argument,  v . Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]]) Warning When the variable is of dimension 1, consider  v  as a scalar. Call The call returns the evaluation of the  VariableConstraint  for given values. Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]"},{"id":690,"pagetitle":"CTBase API","title":"CTBase.VariableConstraint","ref":"/ctdirect/stable/#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VariableConstraint  —  Method Return the value of the VariableConstraint function. julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]"},{"id":691,"pagetitle":"CTBase API","title":"CTBase.VariableDependence","ref":"/ctdirect/stable/#CTBase.VariableDependence","content":" CTBase.VariableDependence  —  Type abstract type VariableDependence"},{"id":692,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctdirect/stable/#CTBase.VectorField","content":" CTBase.VectorField  —  Type struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VectorField  returns a  VectorField  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  VectorField  for given values. Examples julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":693,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctdirect/stable/#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)"},{"id":694,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctdirect/stable/#CTBase.VectorField-Tuple{Function}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)"},{"id":695,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctdirect/stable/#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VectorField  —  Method Return the value of the VectorField. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":696,"pagetitle":"CTBase API","title":"CTBase.ctNumber","ref":"/ctdirect/stable/#CTBase.ctNumber","content":" CTBase.ctNumber  —  Type Type alias for a real number."},{"id":697,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/ctdirect/stable/#CTBase.:⋅-Tuple{Function, Function}","content":" CTBase.:⋅  —  Method ⋅(X::Function, f::Function) -> Function\n Lie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError"},{"id":698,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/ctdirect/stable/#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#105#107\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0"},{"id":699,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/ctdirect/stable/#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#109#111\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case Example julia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10"},{"id":700,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctdirect/stable/#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n Lie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10"},{"id":701,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctdirect/stable/#CTBase.Lie-Tuple{Function, Function}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n Lie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10"},{"id":702,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctdirect/stable/#CTBase.Lie-Tuple{VectorField, Function}","content":" CTBase.Lie  —  Method Lie(X::VectorField, f::Function) -> Function\n Lie derivative of a scalar function along a vector field. Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10"},{"id":703,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctdirect/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField{Autonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case Example julia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]"},{"id":704,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctdirect/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case Example julia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]"},{"id":705,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/ctdirect/stable/#CTBase.Lift-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lift  —  Method Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2"},{"id":706,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/ctdirect/stable/#CTBase.Lift-Tuple{Function}","content":" CTBase.Lift  —  Method Lift(X::Function; autonomous, variable) -> HamiltonianLift\n Return the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2"},{"id":707,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/ctdirect/stable/#CTBase.Lift-Tuple{VectorField}","content":" CTBase.Lift  —  Method Lift(X::VectorField) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField. Example julia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2"},{"id":708,"pagetitle":"CTBase API","title":"CTBase.Model","ref":"/ctdirect/stable/#CTBase.Model-Tuple{Vararg{DataType}}","content":" CTBase.Model  —  Method Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following argument: dependencies : either  Autonomous  or  NonAutonomous . Default is  Autonomous . And either  NonFixed  or  Fixed . Default is  Fixed . Examples julia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control."},{"id":709,"pagetitle":"CTBase API","title":"CTBase.Model","ref":"/ctdirect/stable/#CTBase.Model-Tuple{}","content":" CTBase.Model  —  Method Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following optional keyword argument: autonomous : either  true  or  false . Default is  true . variable : either  true  or  false . Default is  false . Examples julia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control."},{"id":710,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctdirect/stable/#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":711,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctdirect/stable/#CTBase.Poisson-Tuple{Function, Function}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":712,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctdirect/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift{Autonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20"},{"id":713,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctdirect/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift{NonAutonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case Example julia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":714,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctdirect/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n Poisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":715,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctdirect/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n Poisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g) Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":716,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctdirect/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n Poisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g) Example julia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100"},{"id":717,"pagetitle":"CTBase API","title":"CTBase.add","ref":"/ctdirect/stable/#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Concatenate the description  y  at the tuple of descriptions  x  if it is not already in the tuple  x . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))"},{"id":718,"pagetitle":"CTBase API","title":"CTBase.add","ref":"/ctdirect/stable/#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Return a tuple containing only the description  y . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)"},{"id":719,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctdirect/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on a range of the state, or a value constraint on a range of the  :variable . Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\njulia> constraint!(ocp, :variable, 2:3, [ 0, 3 ])"},{"id":720,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctdirect/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint (whole range). Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 0, 1) # the variable here is of dimension 1"},{"id":721,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctdirect/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  value functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[2], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u+v[1], 0)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u-t*v[2], 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t+v[1], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]-u*v[1], 0)"},{"id":722,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctdirect/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on the state, or a  :variable  value. Can also be used with  :state  and  :control . Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0 ])\njulia> constraint!(ocp, :final, 2) # if the state is of dimension 1\njulia> constraint!(ocp, :variable, [ 3, 0, 1 ])"},{"id":723,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctdirect/stable/#CTBase.constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol;\n    rg,\n    f,\n    val,\n    lb,\n    ub,\n    label\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :control, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :state, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial, rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])"},{"id":724,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctdirect/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where V<:VariableDependence","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 1:2, [ 0, 0 ], [ 1, 2 ])"},{"id":725,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctdirect/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where {T, V}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  box functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0, 1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0, 1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 0, 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u, v) -> x[1]-v[2]*u, 0, 1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u+v[2], 0, 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t*v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]*v[2]-u, 0, 1)"},{"id":726,"pagetitle":"CTBase API","title":"CTBase.constraint","ref":"/ctdirect/stable/#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.constraint  —  Method constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n Retrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds). Example julia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1"},{"id":727,"pagetitle":"CTBase API","title":"CTBase.constraint_type","ref":"/ctdirect/stable/#CTBase.constraint_type-NTuple{7, Any}","content":" CTBase.constraint_type  —  Method constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n Return the type constraint among  :initial ,  :final ,  :boundary ,  :control_range ,  :control_fun ,  :state_range ,  :state_fun ,  :mixed ,  :variable_range ,  :variable_fun  ( :other  otherwise), together with the appropriate value (range, updated expression...) Example julia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, Index(1))\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, Index(1))\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, Index(2))\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v ^ 2 + 1))\n\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v[2] ^ 2 + 1))"},{"id":728,"pagetitle":"CTBase API","title":"CTBase.constraints_labels","ref":"/ctdirect/stable/#CTBase.constraints_labels-Tuple{OptimalControlModel}","content":" CTBase.constraints_labels  —  Method constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n Return the labels of the constraints as a  Base.keys . Example julia> constraints_labels(ocp)"},{"id":729,"pagetitle":"CTBase API","title":"CTBase.control!","ref":"/ctdirect/stable/#CTBase.control!","content":" CTBase.control!  —  Function control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the control dimension and possibly the names of each coordinate. Note You must use control! only once to set the control dimension. Examples julia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]"},{"id":730,"pagetitle":"CTBase API","title":"CTBase.ct_repl","ref":"/ctdirect/stable/#CTBase.ct_repl-Tuple{}","content":" CTBase.ct_repl  —  Method ct_repl(; debug, demo) -> Any\n Create a ct REPL."},{"id":731,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/ctdirect/stable/#CTBase.ctgradient-Tuple{Function, Any}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x) -> Any\n Return the gradient of  f  at  x ."},{"id":732,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/ctdirect/stable/#CTBase.ctgradient-Tuple{Function, Real}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x::Real) -> Any\n Return the gradient of  f  at  x ."},{"id":733,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/ctdirect/stable/#CTBase.ctgradient-Tuple{VectorField, Any}","content":" CTBase.ctgradient  —  Method ctgradient(X::VectorField, x) -> Any\n Return the gradient of  X  at  x ."},{"id":734,"pagetitle":"CTBase API","title":"CTBase.ctindices","ref":"/ctdirect/stable/#CTBase.ctindices-Tuple{Integer}","content":" CTBase.ctindices  —  Method ctindices(i::Integer) -> String\n Return  i  > 0 as a subscript."},{"id":735,"pagetitle":"CTBase API","title":"CTBase.ctinterpolate","ref":"/ctdirect/stable/#CTBase.ctinterpolate-Tuple{Any, Any}","content":" CTBase.ctinterpolate  —  Method ctinterpolate(x, f) -> Any\n Return the interpolation of  f  at  x ."},{"id":736,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/ctdirect/stable/#CTBase.ctjacobian-Tuple{Function, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x) -> Any\n Return the Jacobian of  f  at  x ."},{"id":737,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/ctdirect/stable/#CTBase.ctjacobian-Tuple{Function, Real}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x::Real) -> Any\n Return the Jacobian of  f  at  x ."},{"id":738,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/ctdirect/stable/#CTBase.ctjacobian-Tuple{VectorField, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(X::VectorField, x) -> Any\n Return the Jacobian of  X  at  x ."},{"id":739,"pagetitle":"CTBase API","title":"CTBase.ctupperscripts","ref":"/ctdirect/stable/#CTBase.ctupperscripts-Tuple{Integer}","content":" CTBase.ctupperscripts  —  Method ctupperscripts(i::Integer) -> String\n Return  i  > 0 as an upperscript."},{"id":740,"pagetitle":"CTBase API","title":"CTBase.dynamics!","ref":"/ctdirect/stable/#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.dynamics!  —  Method dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n Set the dynamics. Note You can use dynamics! only once to define the dynamics. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> dynamics!(ocp, f)"},{"id":741,"pagetitle":"CTBase API","title":"CTBase.getFullDescription","ref":"/ctdirect/stable/#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","content":" CTBase.getFullDescription  —  Method getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n Return a complete description from an incomplete description  desc  and  a list of complete descriptions  desc_list . If several complete descriptions are possible,  then the first one is returned. Example julia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)"},{"id":742,"pagetitle":"CTBase API","title":"CTBase.get_priority_print_callbacks","ref":"/ctdirect/stable/#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_print_callbacks  —  Method get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority print callbacks."},{"id":743,"pagetitle":"CTBase API","title":"CTBase.get_priority_stop_callbacks","ref":"/ctdirect/stable/#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_stop_callbacks  —  Method get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority stop callbacks."},{"id":744,"pagetitle":"CTBase API","title":"CTBase.is_max","ref":"/ctdirect/stable/#CTBase.is_max-Tuple{OptimalControlModel}","content":" CTBase.is_max  —  Method is_max(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :max ."},{"id":745,"pagetitle":"CTBase API","title":"CTBase.is_min","ref":"/ctdirect/stable/#CTBase.is_min-Tuple{OptimalControlModel}","content":" CTBase.is_min  —  Method is_min(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :min ."},{"id":746,"pagetitle":"CTBase API","title":"CTBase.is_time_dependent","ref":"/ctdirect/stable/#CTBase.is_time_dependent-Tuple{OptimalControlModel{NonAutonomous}}","content":" CTBase.is_time_dependent  —  Method is_time_dependent(\n    ocp::OptimalControlModel{NonAutonomous}\n) -> Bool\n Return  true  if the model has been defined as time dependent."},{"id":747,"pagetitle":"CTBase API","title":"CTBase.is_time_independent","ref":"/ctdirect/stable/#CTBase.is_time_independent-Tuple{OptimalControlModel}","content":" CTBase.is_time_independent  —  Method is_time_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as time independent."},{"id":748,"pagetitle":"CTBase API","title":"CTBase.is_variable_dependent","ref":"/ctdirect/stable/#CTBase.is_variable_dependent-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","content":" CTBase.is_variable_dependent  —  Method is_variable_dependent(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n Return  true  if the model has been defined as variable dependent."},{"id":749,"pagetitle":"CTBase API","title":"CTBase.is_variable_independent","ref":"/ctdirect/stable/#CTBase.is_variable_independent-Tuple{OptimalControlModel}","content":" CTBase.is_variable_independent  —  Method is_variable_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as variable independent."},{"id":750,"pagetitle":"CTBase API","title":"CTBase.nlp_constraints","ref":"/ctdirect/stable/#CTBase.nlp_constraints-Tuple{OptimalControlModel}","content":" CTBase.nlp_constraints  —  Method nlp_constraints(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#99\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#100\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#101\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#102\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#θ#103\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n Return a 6-tuple of tuples: (ξl, ξ, ξu)  are control constraints (ηl, η, ηu)  are state constraints (ψl, ψ, ψu)  are mixed constraints (ϕl, ϕ, ϕu)  are boundary constraints (θl, θ, θu)  are variable constraints (ul, uind, uu)  are control linear constraints of a subset of indices (xl, xind, xu)  are state linear constraints of a subset of indices (vl, vind, vu)  are variable linear constraints of a subset of indices Note The dimensions of the state and control must be set before calling  nlp_constraints . Example julia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints(ocp)"},{"id":751,"pagetitle":"CTBase API","title":"CTBase.objective!","ref":"/ctdirect/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  g  and  f⁰ . Type can be  :bolza . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1"},{"id":752,"pagetitle":"CTBase API","title":"CTBase.objective!","ref":"/ctdirect/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  f . Type can be  :mayer  or  :lagrange . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1 Warning If you set twice the objective, only the last one will be taken into account."},{"id":753,"pagetitle":"CTBase API","title":"CTBase.remove_constraint!","ref":"/ctdirect/stable/#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.remove_constraint!  —  Method remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n Remove a labeled constraint. Example julia> remove_constraint!(ocp, :con)"},{"id":754,"pagetitle":"CTBase API","title":"CTBase.replace_call","ref":"/ctdirect/stable/#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Symbol, t, y) -> Any\n Replace calls in e of the form  (...x...)(t)  by  (...y...) . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)"},{"id":755,"pagetitle":"CTBase API","title":"CTBase.replace_call","ref":"/ctdirect/stable/#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Vector{Symbol}, t, y) -> Any\n Replace calls in e of the form  (...x1...x2...)(t)  by  (...y1...y2...)  for all symbols  x1 ,  x2 ... in the vector  x . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])"},{"id":756,"pagetitle":"CTBase API","title":"CTBase.state!","ref":"/ctdirect/stable/#CTBase.state!","content":" CTBase.state!  —  Function state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the state dimension and possibly the names of each component. Note You must use state! only once to set the state dimension. Examples julia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]"},{"id":757,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctdirect/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(ocp::OptimalControlModel, t0::Real, tf::Real)\ntime!(\n    ocp::OptimalControlModel,\n    t0::Real,\n    tf::Real,\n    name::String\n)\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, 0, 1)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, 0, 1, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, 0, 1, :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\""},{"id":758,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctdirect/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index,\n    name::String\n)\n Fix initial time, final time is free and given by the variable at the provided index. Note You must use time! only once to set either the initial or the final time, or both. Examples julia> time!(ocp, 0, Index(2), \"t\")"},{"id":759,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctdirect/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index,\n    name::String\n)\n Initial and final times are free and given by the variable at the provided indices. Examples julia> time!(ocp, Index(2), Index(3), \"t\")"},{"id":760,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctdirect/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> Any\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> Any\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, [ 0, 1 ])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [ 0, 1 ], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [ 0, 1 ], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\""},{"id":761,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctdirect/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real,\n    name::String\n)\n Fix final time, initial time is free and given by the variable at the provided index. Examples julia> time!(ocp, Index(2), 1, \"t\")"},{"id":762,"pagetitle":"CTBase API","title":"CTBase.variable!","ref":"/ctdirect/stable/#CTBase.variable!","content":" CTBase.variable!  —  Function variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the variable dimension and possibly the names of each component. Note You can use variable! once to set the variable dimension when the model is  NonFixed . Examples julia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])"},{"id":763,"pagetitle":"CTBase API","title":"CTBase.∂ₜ","ref":"/ctdirect/stable/#CTBase.∂ₜ-Tuple{Any}","content":" CTBase.∂ₜ  —  Method ∂ₜ(f) -> CTBase.var\"#114#116\"\n Partial derivative wrt time of a function. Example julia> ∂ₜ((t,x) -> t*x)(0,8)\n8"},{"id":764,"pagetitle":"CTBase API","title":"RecipesBase.plot!","ref":"/ctdirect/stable/#RecipesBase.plot!-Tuple{Plots.Plot, OptimalControlSolution}","content":" RecipesBase.plot!  —  Method plot!(\n    p::Plots.Plot,\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Plots.Plot\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate."},{"id":765,"pagetitle":"CTBase API","title":"RecipesBase.plot","ref":"/ctdirect/stable/#RecipesBase.plot-Tuple{OptimalControlSolution}","content":" RecipesBase.plot  —  Method plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Any\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate."},{"id":766,"pagetitle":"CTBase API","title":"CTBase.@Lie","ref":"/ctdirect/stable/#CTBase.@Lie-Tuple{Expr}","content":" CTBase.@Lie  —  Macro Macros for Lie and Poisson brackets Example julia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1,0,7])\n3.0"},{"id":767,"pagetitle":"CTBase API","title":"CTBase.@def","ref":"/ctdirect/stable/#CTBase.@def","content":" CTBase.@def  —  Macro Define an optimal control problem. One pass parsing of the definition. Example @def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend"},{"id":770,"pagetitle":"API","title":"CTDirect API","ref":"/ctdirect/stable/#CTDirect-API","content":" CTDirect API"},{"id":771,"pagetitle":"API","title":"Index","ref":"/ctdirect/stable/#Index","content":" Index CTDirect.OptimalControlInit CTDirect.available_methods CTDirect.is_solvable CTDirect.solve"},{"id":772,"pagetitle":"API","title":"Available methods","ref":"/ctdirect/stable/#Available-methods","content":" Available methods using CTDirect\navailable_methods() (:adnlp, :ipopt)\n"},{"id":773,"pagetitle":"API","title":"Documentation","ref":"/ctdirect/stable/#Documentation","content":" Documentation"},{"id":774,"pagetitle":"API","title":"CTDirect.OptimalControlInit","ref":"/ctdirect/stable/#CTDirect.OptimalControlInit","content":" CTDirect.OptimalControlInit  —  Type Initialization of the optimal control problem solution for the NLP problem. Constructors: OptimalControlInit() : default initialization OptimalControlInit(x_init, u_init, v_init) : constant vector or function handles OptimalControlInit(sol) : from existing solution Examples julia> init = OptimalControlInit()\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=0.3, v_init=0.5)\njulia> init = OptimalControlInit(x_init=[0.1, 0.2], u_init=t->sin(t), v_init=0.5)\njulia> init = OptimalControlInit(sol) source"},{"id":775,"pagetitle":"API","title":"CTDirect.available_methods","ref":"/ctdirect/stable/#CTDirect.available_methods-Tuple{}","content":" CTDirect.available_methods  —  Method available_methods() -> Tuple{Tuple{Vararg{Symbol}}}\n Return the list of available methods to solve the optimal control problem. source"},{"id":776,"pagetitle":"API","title":"CTDirect.is_solvable","ref":"/ctdirect/stable/#CTDirect.is_solvable-Tuple{Any}","content":" CTDirect.is_solvable  —  Method is_solvable(ocp) -> Bool\n Return if the optimal control problem  ocp  is solvable or not by the method  solve . source"},{"id":777,"pagetitle":"API","title":"CTDirect.solve","ref":"/ctdirect/stable/#CTDirect.solve-Tuple{OptimalControlModel, Vararg{Any}}","content":" CTDirect.solve  —  Method solve(\n    ocp::OptimalControlModel,\n    description...;\n    display,\n    init,\n    grid_size,\n    print_level,\n    mu_strategy,\n    kwargs...\n) -> OptimalControlSolution\n Solve the the optimal control problem  ocp  by the method given by the (optional) description. Return an   OptimalControlSolution  from  CTBase  package, that is an approximation of  the optimal solution if the method has converged correctly. The (optional) description You can pass a partial description. If you give a partial description, then, if several complete descriptions contains the partial one,  then, the method with the highest priority is chosen. The higher in the list, the higher is the priority. Keyword arguments: display : print or not information during the resolution init : an initial condition for the solver grid_size : number of time steps for the discretization print_level : print level for the  Ipopt  solver mu_strategy : mu strategy for the  Ipopt  solver Warning There is only one available method for the moment: the direct method transforms the optimal control problem into a nonlinear programming problem (NLP) solved by  Ipopt , thanks to the package   ADNLPModels . Tip To see the list of available methods, simply call  available_methods() . You can pass any other option by a pair  keyword=value  according to the chosen method. See for instance,  Ipopt  options . The default values for the keyword arguments are given  here . julia> solve(ocp)\njulia> solve(ocp, :adnlp)\njulia> solve(ocp, :adnlp, :ipopt)\njulia> solve(ocp, display=false, init=OptimalControlInit(), grid_size=100, print_level=0, mu_strategy=\"adaptive\") source"},{"id":780,"pagetitle":"Internal functions","title":"Internal functions","ref":"/ctdirect/stable/#Internal-functions","content":" Internal functions"},{"id":783,"pagetitle":"Introduction","title":"CTDirect.jl","ref":"/ctdirect/stable/#CTDirect.jl","content":" CTDirect.jl The  CTDirect.jl  package is part of the  control-toolbox ecosystem . Install To install a package from the control-toolbox ecosystem,  please visit the  installation page . An optimal control problem with fixed initial and final times, denoted (OCP), can be described as minimising the cost functional \\[g(x(t_0), x(t_f)) + \\int_{t_0}^{t_f} f^{0}(t, x(t), u(t))~\\mathrm{d}t\\] where the state  $x$  and the control  $u$  are functions subject, for  $t \\in [t_0, t_f]$ , to the differential constraint \\[   \\dot{x}(t) = f(t, x(t), u(t))\\] and other constraints such as \\[\\begin{array}{llcll}\n~\\xi_l  &\\le& \\xi(t, u(t))        &\\le& \\xi_u, \\\\\n\\eta_l &\\le& \\eta(t, x(t))       &\\le& \\eta_u, \\\\\n\\psi_l &\\le& \\psi(t, x(t), u(t)) &\\le& \\psi_u, \\\\\n\\phi_l &\\le& \\phi(t_0, x(t_0), t_f, x(t_f)) &\\le& \\phi_u.\n\\end{array}\\] The so-called direct approach transforms the infinite dimensional optimal control problem (OCP) into a finite dimensional optimization problem (NLP). This is done by a discretization in time by Runge-Kutta methods applied to the state and control variables, as well as the dynamics equation. These methods are usually less precise than indirect methods based on  Pontryagin’s Maximum Principle , but more robust with respect to the initialization. Also, they are more straightforward to apply, hence their wide use in industrial applications. We refer the reader to for instance [1]  and  [2]  for more details on direct transcription methods and NLP algorithms. Example of the time discretization by the trapezoidal rule: \\[\\begin{array}{lcl}\nt \\in [t_0,t_f]   & \\to & \\{t_0, \\ldots, t_N=t_f\\}\\\\[0.2em]\nx(\\cdot),\\, u(\\cdot) & \\to & X=\\{x_0, \\ldots, x_N, u_0, \\ldots, u_N\\} \\\\[1em]\n\\hline\n\\\\\n\\text{step} & \\to & h = (t_f-t_0)/N\\\\[0.2em]\n\\text{criterion} & \\to & \\min\\ g(x_0, x_N) \\\\[0.2em]\n\\text{dynamics}  & \\to & x_{i+i} = x_i + (h/2)\\, (f(t_i, x_i, u_i) + f(t_{i+1}, x_{i+1}, u_{i+1})) \\\\[0.2em]\n\\text{control constraints} &\\to& \\xi_l  \\le  \\xi(t_i, u_i)   \\le \\xi_u \\\\[0.2em]\n\\text{path constraints} &\\to& \\eta_l \\le \\eta(t_i, x_i)        \\le \\eta_u \\\\[0.2em]\n\\text{mixed constraints} &\\to& \\psi_l \\le \\psi(t_i, x_i, u_i) \\le \\psi_u \\\\[0.2em]\n\\text{limit conditions} &\\to& \\phi_l \\le \\phi(x_0, x_N) \\le \\phi_u\n\\end{array}\\] We therefore obtain a nonlinear programming problem on the discretized state and control variables of the general form: \\[(NLP)\\quad \\left\\{\n\\begin{array}{lr}\n\\min \\ F(X) \\\\\nLB \\le C(X) \\le UB\n\\end{array}\n\\right.\\] We use packages from  JuliaSmoothOptimizers  to solve the (NLP) problem. As input of this package we use an  OptimalControlModel  structure from CTBase. Current limitations For the moment we have only implemented trapezoidal rule for the discretization Ipopt  for the optimization software Related packages This package is equivalent to the  bocop  software. 1 J. T. Betts. Practical methods for optimal control using nonlinear programming. Society for Industrial and Applied Mathematics (SIAM), Philadelphia, PA, 2001. 2 J. Nocedal and S.J. Wright. Numerical optimization. Springer-Verlag, New York, 1999.****"},{"id":786,"pagetitle":"Optimization","title":"Optimization","ref":"/ctdirect/stable/#Optimization","content":" Optimization For the moment we have implemented only Ipopt for the optimization soltware"},{"id":789,"pagetitle":"Runge Kutta method","title":"Runge Kutta method","ref":"/ctdirect/stable/#Runge-Kutta-method","content":" Runge Kutta method For the moment we have implemented only the trapeze method for the discretization"},{"id":794,"pagetitle":"solve options","title":"solve options","ref":"/ctdirect/stable/#solve-options","content":" solve options See  solve  method."},{"id":797,"pagetitle":"API","title":"API","ref":"/ctflows/stable/#API","content":" API"},{"id":798,"pagetitle":"API","title":"CTFlows.Flow","ref":"/ctflows/stable/#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{CTBase.OptimalControlModel{T, V}, Union{CTBase.ControlLaw{T, V}, CTBase.FeedbackControl{T, V}, Function}, Union{CTBase.MixedConstraint{T, V}, CTBase.StateConstraint{T, V}, Function}, Union{CTBase.Multiplier{T, V}, Function}}} where {T, V}","content":" CTFlows.Flow  —  Method Flow(\n    ocp::CTBase.OptimalControlModel{T, V},\n    u_::Union{CTBase.ControlLaw{T, V}, CTBase.FeedbackControl{T, V}, Function},\n    g_::Union{CTBase.MixedConstraint{T, V}, CTBase.StateConstraint{T, V}, Function},\n    μ_::Union{CTBase.Multiplier{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n Flow from an optimal control problem, a control function in feedback form, a state constraint and its  associated multiplier in feedback form. Example julia> ocp = Model(autonomous=false)\njulia> f = Flow(ocp, (t, x, p) -> p[1], (t, x, u) -> x[1] - 1, (t, x, p) -> x[1]+p[1]) Warning The time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem. source"},{"id":799,"pagetitle":"API","title":"CTFlows.Flow","ref":"/ctflows/stable/#CTFlows.Flow-Union{Tuple{V}, Tuple{T}, Tuple{CTBase.OptimalControlModel{T, V}, Union{CTBase.ControlLaw{T, V}, Function}}} where {T, V}","content":" CTFlows.Flow  —  Method Flow(\n    ocp::CTBase.OptimalControlModel{T, V},\n    u_::Union{CTBase.ControlLaw{T, V}, Function};\n    alg,\n    abstol,\n    reltol,\n    saveat,\n    kwargs_Flow...\n) -> CTFlows.OptimalControlFlow\n Flow from an optimal control problem and a control function in feedback form. Example julia> f = Flow(ocp, (x, p) -> p) Warning The time dependence of the control function must be consistent with the time dependence of the optimal control problem. The dimension of the output of the control function must be consistent with the dimension usage of the control of the optimal control problem. source"},{"id":802,"pagetitle":"Developers","title":"Internal functions","ref":"/ctflows/stable/#Internal-functions","content":" Internal functions"},{"id":803,"pagetitle":"Developers","title":"CTBase.OptimalControlSolution","ref":"/ctflows/stable/#CTBase.OptimalControlSolution-Tuple{CTFlows.OptimalControlFlowSolution}","content":" CTBase.OptimalControlSolution  —  Method OptimalControlSolution(\n    ocfs::CTFlows.OptimalControlFlowSolution\n) -> CTBase.OptimalControlSolution\n Construct an  OptimalControlSolution  from an  OptimalControlFlowSolution . source"},{"id":804,"pagetitle":"Developers","title":"CTFlows.OptimalControlFlowSolution","ref":"/ctflows/stable/#CTFlows.OptimalControlFlowSolution","content":" CTFlows.OptimalControlFlowSolution  —  Type struct OptimalControlFlowSolution Type of an optimal control flow solution. Fields ode_sol::Any feedback_control::CTBase.ControlLaw ocp::CTBase.OptimalControlModel variable::Union{Real, AbstractVector{<:Real}} source"},{"id":805,"pagetitle":"Developers","title":"CTFlows.__abstol","ref":"/ctflows/stable/#CTFlows.__abstol-Tuple{}","content":" CTFlows.__abstol  —  Method __abstol() -> Float64\n Default absolute tolerance for ODE solvers. See  abstol  from  OrdinaryDiffEq . source"},{"id":806,"pagetitle":"Developers","title":"CTFlows.__alg","ref":"/ctflows/stable/#CTFlows.__alg-Tuple{}","content":" CTFlows.__alg  —  Method __alg(\n\n) -> OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}\n Default algorithm for ODE solvers. See  alg  from  OrdinaryDiffEq . source"},{"id":807,"pagetitle":"Developers","title":"CTFlows.__callback","ref":"/ctflows/stable/#CTFlows.__callback-Tuple{}","content":" CTFlows.__callback  —  Method __callback()\n See  callback  from  OrdinaryDiffEq . source"},{"id":808,"pagetitle":"Developers","title":"CTFlows.__reltol","ref":"/ctflows/stable/#CTFlows.__reltol-Tuple{}","content":" CTFlows.__reltol  —  Method __reltol() -> Float64\n Default relative tolerance for ODE solvers. See  reltol  from  OrdinaryDiffEq . source"},{"id":809,"pagetitle":"Developers","title":"CTFlows.__saveat","ref":"/ctflows/stable/#CTFlows.__saveat-Tuple{}","content":" CTFlows.__saveat  —  Method __saveat() -> Vector{Any}\n See  saveat  from  OrdinaryDiffEq . source"},{"id":810,"pagetitle":"Developers","title":"CTFlows.__tstops","ref":"/ctflows/stable/#CTFlows.__tstops-Tuple{}","content":" CTFlows.__tstops  —  Method __tstops() -> Vector{Real}\n See  tstops  from  OrdinaryDiffEq . source"},{"id":811,"pagetitle":"Developers","title":"CTFlows.hamiltonian_usage","ref":"/ctflows/stable/#CTFlows.hamiltonian_usage-NTuple{4, Any}","content":" CTFlows.hamiltonian_usage  —  Method hamiltonian_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat;\n    kwargs_Flow...\n) -> Any\n Returns a function that solves ODE problem associated to Hamiltonian vector field. source"},{"id":812,"pagetitle":"Developers","title":"CTFlows.makeH","ref":"/ctflows/stable/#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.Lagrange, Real, Real, CTBase.MixedConstraint, CTBase.Multiplier}","content":" CTFlows.makeH  —  Method makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    f⁰::CTBase.Lagrange,\n    p⁰::Real,\n    s::Real,\n    g::CTBase.MixedConstraint,\n    μ::CTBase.Multiplier\n) -> CTFlows.var\"#H#68\"\n Constructs the Hamiltonian:  H(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p)) source"},{"id":813,"pagetitle":"Developers","title":"CTFlows.makeH","ref":"/ctflows/stable/#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.Lagrange, Real, Real}","content":" CTFlows.makeH  —  Method makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    f⁰::CTBase.Lagrange,\n    p⁰::Real,\n    s::Real\n) -> CTFlows.var\"#H#66\"\n Constructs the Hamiltonian:  H(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + s p⁰ f⁰(t, x, u(t, x, p)) source"},{"id":814,"pagetitle":"Developers","title":"CTFlows.makeH","ref":"/ctflows/stable/#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw, CTBase.MixedConstraint, CTBase.Multiplier}","content":" CTFlows.makeH  —  Method makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw,\n    g::CTBase.MixedConstraint,\n    μ::CTBase.Multiplier\n) -> CTFlows.var\"#H#67\"\n Constructs the Hamiltonian:  H(t, x, p) = p ⋅ f(t, x, u(t, x, p)) + μ(t, x, p) ⋅ g(t, x, u(t, x, p)) source"},{"id":815,"pagetitle":"Developers","title":"CTFlows.makeH","ref":"/ctflows/stable/#CTFlows.makeH-Tuple{CTBase.Dynamics, CTBase.ControlLaw}","content":" CTFlows.makeH  —  Method makeH(\n    f::CTBase.Dynamics,\n    u::CTBase.ControlLaw\n) -> CTFlows.var\"#64#65\"\n Constructs the Hamiltonian:  H(t, x, p) = p f(t, x, u(t, x, p)) source"},{"id":816,"pagetitle":"Developers","title":"CTFlows.ode_usage","ref":"/ctflows/stable/#CTFlows.ode_usage-NTuple{4, Any}","content":" CTFlows.ode_usage  —  Method ode_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat;\n    kwargs_Flow...\n) -> Any\n Returns a function that solves any ODE problem with OrdinaryDiffEq. source"},{"id":817,"pagetitle":"Developers","title":"CTFlows.rhs","ref":"/ctflows/stable/#CTFlows.rhs-Tuple{CTBase.AbstractHamiltonian}","content":" CTFlows.rhs  —  Method rhs(h::CTBase.AbstractHamiltonian) -> CTFlows.var\"#rhs!#24\"\n The right and side from a Hamiltonian. source"},{"id":818,"pagetitle":"Developers","title":"CTFlows.vector_field_usage","ref":"/ctflows/stable/#CTFlows.vector_field_usage-NTuple{4, Any}","content":" CTFlows.vector_field_usage  —  Method vector_field_usage(\n    alg,\n    abstol,\n    reltol,\n    saveat;\n    kwargs_Flow...\n) -> Any\n Returns a function that solves ODE problem associated to classical vector field. source"},{"id":821,"pagetitle":"Introduction","title":"CTFlows.jl","ref":"/ctflows/stable/#CTFlows.jl","content":" CTFlows.jl The  CTFlows.jl  package is part of the  control-toolbox ecosystem . Install To install a package from the control-toolbox ecosystem,  please visit the  installation page . It aims to provide tools to solve  mathematical flows  of vector fields, and in particular  Hamiltonian vector fields  directly from the definition of the Hamiltonian, using automatic differentiation to construct the assiocated Hamiltonian vector field. The flow is then computed thanks to  DifferentialEquations.jl  package."},{"id":826,"pagetitle":"API","title":"API","ref":"/ctproblems/stable/#API","content":" API"},{"id":827,"pagetitle":"API","title":"CTProblems.CTProblems","ref":"/ctproblems/stable/#CTProblems.CTProblems","content":" CTProblems.CTProblems  —  Module CTProblems  module. Lists all the imported modules and packages: Base CTBase CTFlows Core DocStringExtensions ForwardDiff LinearAlgebra MINPACK OrdinaryDiffEq List of all the exported names: Problem @Problems Problems @ProblemsDescriptions ProblemsDescriptions plot source"},{"id":828,"pagetitle":"API","title":"CTProblems.Problem","ref":"/ctproblems/stable/#CTProblems.Problem-Tuple{Vararg{Symbol}}","content":" CTProblems.Problem  —  Method Problem(\n    description::Symbol...\n) -> CTProblems.OptimalControlProblem\n Return the optimal control problem described by  description . If you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority. Example julia> Problem(:integrator, :energy) source"},{"id":829,"pagetitle":"API","title":"CTProblems.Problems","ref":"/ctproblems/stable/#CTProblems.Problems-Tuple{Vararg{Symbol}}","content":" CTProblems.Problems  —  Method Problems(\n    description::Symbol...\n) -> Tuple{Vararg{CTProblems.OptimalControlProblem}}\n Return the list of optimal control problems consistent with the description. If you give a partial description, then, if several complete descriptions contains the partial one, then,  only the problem with the highest priority is returned. The higher in the list, the higher is the priority. Example julia> Problems(:integrator, :energy) source"},{"id":830,"pagetitle":"API","title":"CTProblems.ProblemsDescriptions","ref":"/ctproblems/stable/#CTProblems.ProblemsDescriptions-Tuple{Vararg{Symbol}}","content":" CTProblems.ProblemsDescriptions  —  Method ProblemsDescriptions(\n    description::Symbol...\n) -> Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n Return the list of problems descriptions consistent with the description, as a Tuple of Description.  Example julia> ProblemsDescriptions(:integrator, :energy) source"},{"id":831,"pagetitle":"API","title":"CTProblems.@Problems","ref":"/ctproblems/stable/#CTProblems.@Problems","content":" CTProblems.@Problems  —  Macro Return the list of problems consistent with the description. Example julia> @Problems :integrator & :energy Note You have to define a logical condition with the combination of symbols and the three  operators:  ! ,  |  and  & , respectively for the negation, the disjunction and the conjunction. source"},{"id":832,"pagetitle":"API","title":"CTProblems.@ProblemsDescriptions","ref":"/ctproblems/stable/#CTProblems.@ProblemsDescriptions","content":" CTProblems.@ProblemsDescriptions  —  Macro Return the list of problems descriptions consistent with the expression. Example julia> @ProblemsDescriptions :integrator & :energy Note You have to define a logical condition with the combination of symbols and the three  operators:  ! ,  |  and  & , respectively for the negation, the disjunction and the conjunction. source"},{"id":835,"pagetitle":"CTBase API","title":"CTBase API","ref":"/ctproblems/stable/#CTBase-API","content":" CTBase API This is just a dump of CTBase API documentation. For more details about  CTBase.jl  package, see the  documentation ."},{"id":836,"pagetitle":"CTBase API","title":"Index","ref":"/ctproblems/stable/#Index","content":" Index"},{"id":837,"pagetitle":"CTBase API","title":"Documentation","ref":"/ctproblems/stable/#Documentation","content":" Documentation"},{"id":838,"pagetitle":"CTBase API","title":"CTBase.CTBase","ref":"/ctproblems/stable/#CTBase.CTBase","content":" CTBase.CTBase  —  Module CTBase  module. Lists all the imported modules and packages: Base Core DataStructures DocStringExtensions LinearAlgebra MLStyle Parameters Plots PrettyTables Printf ReplMaker Unicode List of all the exported names: AbstractHamiltonian AmbiguousDescription Autonomous BoundaryConstraint CTCallback CTCallbacks CTException Control ControlConstraint ControlLaw Controls Costate Costates DCostate DState Description Dimension Dynamics FeedbackControl Fixed Hamiltonian HamiltonianLift HamiltonianVectorField IncorrectArgument IncorrectMethod IncorrectOutput Index Lagrange @Lie Lie Lift Mayer MixedConstraint Model Multiplier NonAutonomous NonFixed NotImplemented OptimalControlModel OptimalControlSolution ParsingError Poisson PrintCallback State StateConstraint States StopCallback Time TimeDependence Times TimesDisc UnauthorizedCall Variable VariableConstraint VariableDependence VectorField add constraint constraint! constraint_type constraints_labels control! ctNumber ctVector ct_repl ctgradient ctindices ctinterpolate ctjacobian ctupperscripts @def dynamics! getFullDescription get_priority_print_callbacks get_priority_stop_callbacks is_max is_min is_time_dependent is_time_independent is_variable_dependent is_variable_independent nlp_constraints objective! plot plot! remove_constraint! replace_call state! time! variable! ∂ₜ ⋅"},{"id":839,"pagetitle":"CTBase API","title":"CTBase.Control","ref":"/ctproblems/stable/#CTBase.Control","content":" CTBase.Control  —  Type Type alias for a control."},{"id":840,"pagetitle":"CTBase API","title":"CTBase.Costate","ref":"/ctproblems/stable/#CTBase.Costate","content":" CTBase.Costate  —  Type Type alias for an costate."},{"id":841,"pagetitle":"CTBase API","title":"CTBase.DCostate","ref":"/ctproblems/stable/#CTBase.DCostate","content":" CTBase.DCostate  —  Type Type alias for a tangent vector to the costate space."},{"id":842,"pagetitle":"CTBase API","title":"CTBase.DState","ref":"/ctproblems/stable/#CTBase.DState","content":" CTBase.DState  —  Type Type alias for a tangent vector to the state space."},{"id":843,"pagetitle":"CTBase API","title":"CTBase.State","ref":"/ctproblems/stable/#CTBase.State","content":" CTBase.State  —  Type Type alias for a state."},{"id":844,"pagetitle":"CTBase API","title":"CTBase.TimesDisc","ref":"/ctproblems/stable/#CTBase.TimesDisc","content":" CTBase.TimesDisc  —  Type Type alias for a grid of times."},{"id":845,"pagetitle":"CTBase API","title":"CTBase.Variable","ref":"/ctproblems/stable/#CTBase.Variable","content":" CTBase.Variable  —  Type Type alias for a variable."},{"id":846,"pagetitle":"CTBase API","title":"CTBase.ctVector","ref":"/ctproblems/stable/#CTBase.ctVector","content":" CTBase.ctVector  —  Type Type alias for a vector of real numbers."},{"id":847,"pagetitle":"CTBase API","title":"CTBase.AbstractHamiltonian","ref":"/ctproblems/stable/#CTBase.AbstractHamiltonian","content":" CTBase.AbstractHamiltonian  —  Type abstract type AbstractHamiltonian{time_dependence, variable_dependence} Abstract type for hamiltonians."},{"id":848,"pagetitle":"CTBase API","title":"CTBase.AmbiguousDescription","ref":"/ctproblems/stable/#CTBase.AmbiguousDescription","content":" CTBase.AmbiguousDescription  —  Type struct AmbiguousDescription <: CTException Exception thrown when the description is ambiguous / incorrect. Fields var::Tuple{Vararg{Symbol}}"},{"id":849,"pagetitle":"CTBase API","title":"CTBase.Autonomous","ref":"/ctproblems/stable/#CTBase.Autonomous","content":" CTBase.Autonomous  —  Type abstract type Autonomous <: TimeDependence"},{"id":850,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctproblems/stable/#CTBase.BoundaryConstraint","content":" CTBase.BoundaryConstraint  —  Type struct BoundaryConstraint{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  BoundaryConstraint  returns a  BoundaryConstraint  of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. When the constraint is dimension 1, return a scalar. Call The call returns the evaluation of the  BoundaryConstraint  for given values. If a variable is given for a non variable dependent boundary constraint, it will be ignored. Examples julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1],Real[])\n[1, 2]\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]"},{"id":851,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctproblems/stable/#CTBase.BoundaryConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.BoundaryConstraint  —  Method BoundaryConstraint(\n    f::Function,\n    dependencies::DataType...;\n    variable\n) -> BoundaryConstraint\n Return a  BoundaryConstraint  of a function. Dependencies are specified with a DataType: NonFixed/Fixed or with a boolean, variable, false by default. julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2], Fixed)\njulia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], NonFixed)"},{"id":852,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctproblems/stable/#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.BoundaryConstraint  —  Method Return the evaluation of the BoundaryConstraint at  x0 ,  xf ,  v . julia> B = BoundaryConstraint((x0, xf, v) -> [v[3]+xf[2]-x0[1], v[1]-v[2]+2xf[1]+x0[2]^2], variable=true)\njulia> B([0, 0], [1, 1], [1, 2, 3])\n[4, 1]"},{"id":853,"pagetitle":"CTBase API","title":"CTBase.BoundaryConstraint","ref":"/ctproblems/stable/#CTBase.BoundaryConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.BoundaryConstraint  —  Method Return the evaluation of the BoundaryConstraint at  x0 ,  xf . julia> B = BoundaryConstraint((x0, xf) -> [xf[2]-x0[1], 2xf[1]+x0[2]^2])\njulia> B([0, 0], [1, 1])\n[1, 2]"},{"id":854,"pagetitle":"CTBase API","title":"CTBase.CTCallback","ref":"/ctproblems/stable/#CTBase.CTCallback","content":" CTBase.CTCallback  —  Type abstract type CTCallback Abstract type for callbacks."},{"id":855,"pagetitle":"CTBase API","title":"CTBase.CTCallbacks","ref":"/ctproblems/stable/#CTBase.CTCallbacks","content":" CTBase.CTCallbacks  —  Type Tuple of callbacks"},{"id":856,"pagetitle":"CTBase API","title":"CTBase.CTException","ref":"/ctproblems/stable/#CTBase.CTException","content":" CTBase.CTException  —  Type abstract type CTException <: Exception Abstract type for exceptions."},{"id":857,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctproblems/stable/#CTBase.ControlConstraint","content":" CTBase.ControlConstraint  —  Type struct ControlConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlConstraint  returns a  ControlConstraint  of a function. The function must take 1 to 3 arguments,  u  to  (t, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true) Warning When the control is of dimension 1, consider  u  as a scalar. Call The call returns the evaluation of the  ControlConstraint  for given values. Examples julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":858,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctproblems/stable/#CTBase.ControlConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], Autonomous, Fixed)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], Autonomous, NonFixed)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], NonAutonomous, Fixed)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], NonAutonomous, NonFixed)"},{"id":859,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctproblems/stable/#CTBase.ControlConstraint-Tuple{Function}","content":" CTBase.ControlConstraint  —  Method ControlConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlConstraint{Autonomous, Fixed}\n Return the  ControlConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)"},{"id":860,"pagetitle":"CTBase API","title":"CTBase.ControlConstraint","ref":"/ctproblems/stable/#CTBase.ControlConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlConstraint  —  Method Return the value of the ControlConstraint function. julia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> IncorrectArgument ControlConstraint(u -> [u[1]^2, 2u[2]], Int64)\njulia> C = ControlConstraint(u -> [u[1]^2, 2u[2]], autonomous=true, variable=false)\njulia> C([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> C(t, [1, -1], v)\n[1, -2]\njulia> C = ControlConstraint((u, v) -> [u[1]^2, 2u[2]+v[3]], autonomous=true, variable=true)\njulia> C([1, -1], [1, 2, 3])\n[1, 1]\njulia> C(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> C = ControlConstraint((t, u) -> [t+u[1]^2, 2u[2]], autonomous=false, variable=false)\njulia> C(1, [1, -1])\n[2, -2]\njulia> C(1, [1, -1], v)\n[2, -2]\njulia> C = ControlConstraint((t, u, v) -> [t+u[1]^2, 2u[2]+v[3]], autonomous=false, variable=true)\njulia> C(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":861,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctproblems/stable/#CTBase.ControlLaw","content":" CTBase.ControlLaw  —  Type struct ControlLaw{time_dependence, variable_dependence} Fields f::Function Similar to  Hamiltonian  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  ControlLaw  returns a  ControlLaw  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  ControlLaw  for given values. Examples julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":862,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctproblems/stable/#CTBase.ControlLaw-Tuple{Function, Vararg{DataType}}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function,\n    dependencies::DataType...\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)"},{"id":863,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctproblems/stable/#CTBase.ControlLaw-Tuple{Function}","content":" CTBase.ControlLaw  —  Method ControlLaw(\n    f::Function;\n    autonomous,\n    variable\n) -> ControlLaw{Autonomous, Fixed}\n Return the  ControlLaw  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)"},{"id":864,"pagetitle":"CTBase API","title":"CTBase.ControlLaw","ref":"/ctproblems/stable/#CTBase.ControlLaw-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.ControlLaw  —  Method Return the value of the ControlLaw function. julia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> ControlLaw((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> u = ControlLaw((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> u([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0], [0, 1])\nMethodError\njulia> u([1, 0], [0, 1], v)\nMethodError\njulia> u(t, [1, 0], [0, 1], v)\n3\njulia> u = ControlLaw((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [0, 1], [1, 2, 3])\n6\njulia> u(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> u = ControlLaw((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> u(1, [1, 0], [0, 1])\n4\njulia> u(1, [1, 0], [0, 1], v)\n4\njulia> u = ControlLaw((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":865,"pagetitle":"CTBase API","title":"CTBase.Controls","ref":"/ctproblems/stable/#CTBase.Controls","content":" CTBase.Controls  —  Type Type alias for a vector of controls."},{"id":866,"pagetitle":"CTBase API","title":"CTBase.Costates","ref":"/ctproblems/stable/#CTBase.Costates","content":" CTBase.Costates  —  Type Type alias for a vector of costates."},{"id":867,"pagetitle":"CTBase API","title":"CTBase.Description","ref":"/ctproblems/stable/#CTBase.Description","content":" CTBase.Description  —  Type A description is a tuple of symbols, that is a Tuple{Vararg{Symbol}}."},{"id":868,"pagetitle":"CTBase API","title":"CTBase.Dimension","ref":"/ctproblems/stable/#CTBase.Dimension","content":" CTBase.Dimension  —  Type Type alias for a dimension."},{"id":869,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctproblems/stable/#CTBase.Dynamics","content":" CTBase.Dynamics  —  Type struct Dynamics{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Dynamics  returns a  Dynamics  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Dynamics  for given values. Examples julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":870,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctproblems/stable/#CTBase.Dynamics-Tuple{Function, Vararg{DataType}}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function,\n    dependencies::DataType...\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> Dynamics((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)"},{"id":871,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctproblems/stable/#CTBase.Dynamics-Tuple{Function}","content":" CTBase.Dynamics  —  Method Dynamics(\n    f::Function;\n    autonomous,\n    variable\n) -> Dynamics{Autonomous, Fixed}\n Return the  Dynamics  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)"},{"id":872,"pagetitle":"CTBase API","title":"CTBase.Dynamics","ref":"/ctproblems/stable/#CTBase.Dynamics-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Dynamics  —  Method Return the value of the Dynamics function. julia> D = Dynamics((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> D([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> D(t, [1, 0], 1, v)\n[-1, 1]\njulia> D = Dynamics((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> D([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> D = Dynamics((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> D(1, [1, 0], 1)\n[0, 1]\njulia> D(1, [1, 0], 1, v)\n[0, 1]\njulia> D = Dynamics((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> D(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":873,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctproblems/stable/#CTBase.FeedbackControl","content":" CTBase.FeedbackControl  —  Type struct FeedbackControl{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  FeedbackControl  returns a  FeedbackControl  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  FeedbackControl  for given values. Examples julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5"},{"id":874,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctproblems/stable/#CTBase.FeedbackControl-Tuple{Function, Vararg{DataType}}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function,\n    dependencies::DataType...\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], Autonomous, Fixed)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], Autonomous, NonFixed)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], NonAutonomous, Fixed)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], NonAutonomous, NonFixed)"},{"id":875,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctproblems/stable/#CTBase.FeedbackControl-Tuple{Function}","content":" CTBase.FeedbackControl  —  Method FeedbackControl(\n    f::Function;\n    autonomous,\n    variable\n) -> FeedbackControl{Autonomous, Fixed}\n Return the  FeedbackControl  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)"},{"id":876,"pagetitle":"CTBase API","title":"CTBase.FeedbackControl","ref":"/ctproblems/stable/#CTBase.FeedbackControl-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.FeedbackControl  —  Method Return the value of the FeedbackControl function. julia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> FeedbackControl(x -> x[1]^2+2x[2], Int64)\nIncorrectArgument\njulia> u = FeedbackControl(x -> x[1]^2+2x[2], autonomous=true, variable=false)\njulia> u([1, 0])\n1\njulia> t = 1\njulia> v = Real[]\njulia> u(t, [1, 0])\nMethodError\njulia> u([1, 0], v)\nMethodError\njulia> u(t, [1, 0], v)\n1\njulia> u = FeedbackControl((x, v) -> x[1]^2+2x[2]+v[3], autonomous=true, variable=true)\njulia> u([1, 0], [1, 2, 3])\n4\njulia> u(t, [1, 0], [1, 2, 3])\n4\njulia> u = FeedbackControl((t, x) -> t+x[1]^2+2x[2], autonomous=false, variable=false)\njulia> u(1, [1, 0])\n2\njulia> u(1, [1, 0], v)\n2\njulia> u = FeedbackControl((t, x, v) -> t+x[1]^2+2x[2]+v[3], autonomous=false, variable=true)\njulia> u(1, [1, 0], [1, 2, 3])\n5"},{"id":877,"pagetitle":"CTBase API","title":"CTBase.Fixed","ref":"/ctproblems/stable/#CTBase.Fixed","content":" CTBase.Fixed  —  Type abstract type Fixed <: VariableDependence"},{"id":878,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctproblems/stable/#CTBase.Hamiltonian","content":" CTBase.Hamiltonian  —  Type struct Hamiltonian{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Hamiltonian  returns a  Hamiltonian  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Hamiltonian  for given values. Examples julia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":879,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctproblems/stable/#CTBase.Hamiltonian-Tuple{Function, Vararg{DataType}}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function,\n    dependencies::DataType...\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], NonAutonomous, NonFixed)"},{"id":880,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctproblems/stable/#CTBase.Hamiltonian-Tuple{Function}","content":" CTBase.Hamiltonian  —  Method Hamiltonian(\n    f::Function;\n    autonomous,\n    variable\n) -> Hamiltonian{Autonomous, Fixed}\n Return an  Hamiltonian  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H = Hamiltonian((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3]], autonomous=false, variable=true)"},{"id":881,"pagetitle":"CTBase API","title":"CTBase.Hamiltonian","ref":"/ctproblems/stable/#CTBase.Hamiltonian-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Hamiltonian  —  Method Return the value of the Hamiltonian. julia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument \njulia> Hamiltonian((x, p) -> x + p, Int64)\nIncorrectArgument\njulia> H = Hamiltonian((x, p) -> [x[1]^2+2p[2]]) # autonomous=true, variable=false\njulia> H([1, 0], [0, 1])\nMethodError # H must return a scalar\njulia> H = Hamiltonian((x, p) -> x[1]^2+2p[2])\njulia> H([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n3\njulia> H = Hamiltonian((x, p, v) -> x[1]^2+2p[2]+v[3], variable=true)\njulia> H([1, 0], [0, 1], [1, 2, 3])\n6\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> H = Hamiltonian((t, x, p) -> t+x[1]^2+2p[2], autonomous=false)\njulia> H(1, [1, 0], [0, 1])\n4\njulia> H(1, [1, 0], [0, 1], v)\n4\njulia> H = Hamiltonian((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":882,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctproblems/stable/#CTBase.HamiltonianLift","content":" CTBase.HamiltonianLift  —  Type struct HamiltonianLift{time_dependence, variable_dependence} <: AbstractHamiltonian{time_dependence, variable_dependence} Lifts X::VectorField The values for  time_dependence  and  variable_dependence  are deternimed by the values of those for the VectorField. Constructor The constructor  HamiltonianLift  returns a  HamiltonianLift  of a  VectorField . Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed))\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous))\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianLift  for given values. Examples julia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3 Alternatively, it is possible to construct the  HamiltonianLift  from a  Function  being the  VectorField . julia> HL1 = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL2 = HamiltonianLift(VectorField((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true))\njulia> HL1([1, 0], [0, 1], 1) == HL2([1, 0], [0, 1], 1)\ntrue"},{"id":883,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctproblems/stable/#CTBase.HamiltonianLift-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], Autonomous, Fixed)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], Autonomous, NonFixed)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], NonAutonomous, Fixed)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], NonAutonomous, NonFixed)"},{"id":884,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctproblems/stable/#CTBase.HamiltonianLift-Tuple{Function}","content":" CTBase.HamiltonianLift  —  Method HamiltonianLift(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianLift\n Return an  HamiltonianLift  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> HL = HamiltonianLift(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false)\njulia> HL = HamiltonianLift((x, v) -> [x[1]^2,x[2]^2+v], autonomous=true, variable=true)\njulia> HL = HamiltonianLift((t, x) -> [t+x[1]^2,x[2]^2], autonomous=false, variable=false)\njulia> HL = HamiltonianLift((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true)"},{"id":885,"pagetitle":"CTBase API","title":"CTBase.HamiltonianLift","ref":"/ctproblems/stable/#CTBase.HamiltonianLift-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianLift  —  Method Return the value of the HamiltonianLift. Examples julia> HamiltonianLift(HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]], Int64))\nIncorrectArgument \njulia> H = HamiltonianLift(VectorField(x -> [x[1]^2, 2x[2]]))\njulia> H([1, 2], [1, 1])\n5\njulia> t = 1\njulia> v = Real[]\njulia> H(t, [1, 0], [0, 1])\nMethodError\njulia> H([1, 0], [0, 1], v)\nMethodError \njulia> H(t, [1, 0], [0, 1], v)\n5\njulia> H = HamiltonianLift(VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true))\njulia> H([1, 0], [0, 1], [1, 2, 3])\n3\njulia> H(t, [1, 0], [0, 1], [1, 2, 3])\n3\njulia> H = HamiltonianLift(VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false))\njulia> H(1, [1, 2], [1, 1])\n6\njulia> H(1, [1, 0], [0, 1], v)\n6\njulia> H = HamiltonianLift(VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true))\njulia> H(1, [1, 0], [0, 1], [1, 2, 3])\n3"},{"id":886,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctproblems/stable/#CTBase.HamiltonianVectorField","content":" CTBase.HamiltonianVectorField  —  Type struct HamiltonianVectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  HamiltonianVectorField  returns a  HamiltonianVectorField  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  HamiltonianVectorField  for given values. Examples julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]"},{"id":887,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctproblems/stable/#CTBase.HamiltonianVectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function,\n    dependencies::DataType...\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonFixed)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], NonAutonomous)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], NonAutonomous, NonFixed)"},{"id":888,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctproblems/stable/#CTBase.HamiltonianVectorField-Tuple{Function}","content":" CTBase.HamiltonianVectorField  —  Method HamiltonianVectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> HamiltonianVectorField{Autonomous, Fixed}\n Return an  HamiltonianVectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)"},{"id":889,"pagetitle":"CTBase API","title":"CTBase.HamiltonianVectorField","ref":"/ctproblems/stable/#CTBase.HamiltonianVectorField-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.HamiltonianVectorField  —  Method Return the value of the HamiltonianVectorField. Examples julia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2], Int64)\nIncorrectArgument\njulia> Hv = HamiltonianVectorField((x, p) -> [x[1]^2+2p[2], x[2]-3p[2]^2]) # autonomous=true, variable=false\njulia> Hv([1, 0], [0, 1])\n[3, -3]\njulia> t = 1\njulia> v = Real[]\njulia> Hv(t, [1, 0], [0, 1])\nMethodError\njulia> Hv([1, 0], [0, 1], v)\nMethodError\njulia> Hv(t, [1, 0], [0, 1], v)\n[3, -3]\njulia> Hv = HamiltonianVectorField((x, p, v) -> [x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], variable=true)\njulia> Hv([1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv(t, [1, 0], [0, 1], [1, 2, 3, 4])\n[6, -3]\njulia> Hv = HamiltonianVectorField((t, x, p) -> [t+x[1]^2+2p[2], x[2]-3p[2]^2], autonomous=false)\njulia> Hv(1, [1, 0], [0, 1])\n[4, -3]\njulia> Hv(1, [1, 0], [0, 1], v)\n[4, -3]\njulia> Hv = HamiltonianVectorField((t, x, p, v) -> [t+x[1]^2+2p[2]+v[3], x[2]-3p[2]^2+v[4]], autonomous=false, variable=true)\njulia> Hv(1, [1, 0], [0, 1], [1, 2, 3, 4])\n[7, -3]"},{"id":890,"pagetitle":"CTBase API","title":"CTBase.IncorrectArgument","ref":"/ctproblems/stable/#CTBase.IncorrectArgument","content":" CTBase.IncorrectArgument  —  Type struct IncorrectArgument <: CTException Exception thrown when an argument is inconsistent. Fields var::String"},{"id":891,"pagetitle":"CTBase API","title":"CTBase.IncorrectMethod","ref":"/ctproblems/stable/#CTBase.IncorrectMethod","content":" CTBase.IncorrectMethod  —  Type struct IncorrectMethod <: CTException Exception thrown when a method is incorrect. Fields var::Symbol"},{"id":892,"pagetitle":"CTBase API","title":"CTBase.IncorrectOutput","ref":"/ctproblems/stable/#CTBase.IncorrectOutput","content":" CTBase.IncorrectOutput  —  Type struct IncorrectOutput <: CTException Exception thrown when the output is incorrect. Fields var::String"},{"id":893,"pagetitle":"CTBase API","title":"CTBase.Index","ref":"/ctproblems/stable/#CTBase.Index","content":" CTBase.Index  —  Type mutable struct Index Fields val::Integer"},{"id":894,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctproblems/stable/#CTBase.Lagrange","content":" CTBase.Lagrange  —  Type struct Lagrange{time_dependence, variable_dependence} Fields f::Function The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Lagrange  returns a  Lagrange  cost of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], Autonomous, Fixed)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, Autonomous, Fixed)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], Autonomous, NonFixed)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, Fixed)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  Lagrange  cost for given values. Examples julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3"},{"id":895,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctproblems/stable/#CTBase.Lagrange-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function,\n    dependencies::DataType...\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n"},{"id":896,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctproblems/stable/#CTBase.Lagrange-Tuple{Function}","content":" CTBase.Lagrange  —  Method Lagrange(\n    f::Function;\n    autonomous,\n    variable\n) -> Lagrange{Autonomous, Fixed}\n Return a  Lagrange  cost of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\n"},{"id":897,"pagetitle":"CTBase API","title":"CTBase.Lagrange","ref":"/ctproblems/stable/#CTBase.Lagrange-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Lagrange  —  Method Return the value of the Lagrange function. Examples julia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> Lagrange((x, u) -> 2x[2]-u[1]^2, Int64)\nIncorrectArgument\njulia> L = Lagrange((x, u) -> [2x[2]-u[1]^2], autonomous=true, variable=false)\njulia> L([1, 0], [1])\nMethodError\njulia> L = Lagrange((x, u) -> 2x[2]-u[1]^2, autonomous=true, variable=false)\njulia> L([1, 0], [1])\n-1\njulia> t = 1\njulia> v = Real[]\njulia> L(t, [1, 0], [1])\nMethodError\njulia> L([1, 0], [1], v)\nMethodError\njulia> L(t, [1, 0], [1], v)\n-1\njulia> L = Lagrange((x, u, v) -> 2x[2]-u[1]^2+v[3], autonomous=true, variable=true)\njulia> L([1, 0], [1], [1, 2, 3])\n2\njulia> L(t, [1, 0], [1], [1, 2, 3])\n2\njulia> L = Lagrange((t, x, u) -> t+2x[2]-u[1]^2, autonomous=false, variable=false)\njulia> L(1, [1, 0], [1])\n0\njulia> L(1, [1, 0], [1], v)\n0\njulia> L = Lagrange((t, x, u, v) -> t+2x[2]-u[1]^2+v[3], autonomous=false, variable=true)\njulia> L(1, [1, 0], [1], [1, 2, 3])\n3"},{"id":898,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctproblems/stable/#CTBase.Mayer","content":" CTBase.Mayer  —  Type struct Mayer{variable_dependence} Fields f::Function The default value for  variable_dependence  is  Fixed . Constructor The constructor  Mayer  returns a  Mayer  cost of a function. The function must take 2 or 3 arguments  (x0, xf)  or  (x0, xf, v) , if the function is variable, it must be specified.  Dependencies are specified with a boolean,  variable ,  false  by default or with a  DataType ,  NonFixed/Fixed ,  Fixed  by default. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed) Warning When the state is of dimension 1, consider  x0  and  xf  as a scalar. Call The call returns the evaluation of the  Mayer  cost for given values. If a variable is given for a non variable dependent Mayer cost, it will be ignored. Examples julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1],Real[])\n1\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4"},{"id":899,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctproblems/stable/#CTBase.Mayer-Tuple{Function, Vararg{DataType}}","content":" CTBase.Mayer  —  Method Mayer(\n    f::Function,\n    dependencies::DataType...;\n    variable\n) -> Mayer\n Return a  Mayer  cost of a function. Dependencies are specified with a DataType: NonFixed/Fixed, or with a boolean, variable, false by default. julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G = Mayer((x0, xf) -> xf[2]-x0[1], Fixed)\njulia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], NonFixed)"},{"id":900,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctproblems/stable/#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Mayer  —  Method Return the evaluation of the Mayer cost at  x0 ,  xf ,  v . julia> G = Mayer((x0, xf, v) -> v[3]+xf[2]-x0[1], variable=true)\njulia> G([0, 0], [1, 1], [1, 2, 3])\n4"},{"id":901,"pagetitle":"CTBase API","title":"CTBase.Mayer","ref":"/ctproblems/stable/#CTBase.Mayer-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Mayer  —  Method Return the evaluation of the Mayer cost at  x0 ,  xf . julia> G = Mayer((x0, xf) -> xf[2]-x0[1])\njulia> G([0, 0], [1, 1])\n1"},{"id":902,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctproblems/stable/#CTBase.MixedConstraint","content":" CTBase.MixedConstraint  —  Type struct MixedConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  Lagrange  in the usage, but the dimension of the output of the function  f  is arbitrary. The default value for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  MixedConstraint  returns a  MixedConstraint  of a function. The function must take 2 to 4 arguments,  (x, u)  to  (t, x, u, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Same for the control. Call The call returns the evaluation of the  MixedConstraint  for given values. Examples julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":903,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctproblems/stable/#CTBase.MixedConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Autonomous, Fixed)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], Autonomous, NonFixed)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], NonAutonomous, Fixed)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], NonAutonomous, NonFixed)"},{"id":904,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctproblems/stable/#CTBase.MixedConstraint-Tuple{Function}","content":" CTBase.MixedConstraint  —  Method MixedConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> MixedConstraint{Autonomous, Fixed}\n Return the  MixedConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)"},{"id":905,"pagetitle":"CTBase API","title":"CTBase.MixedConstraint","ref":"/ctproblems/stable/#CTBase.MixedConstraint-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.MixedConstraint  —  Method Return the value of the MixedConstraint function. julia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], Int64)\nIncorrectArgument\njulia> M = MixedConstraint((x, u) -> [2x[2]-u^2, x[1]], autonomous=true, variable=false)\njulia> M([1, 0], 1)\n[-1, 1]\njulia> t = 1\njulia> v = Real[]\njulia> MethodError M(t, [1, 0], 1)\njulia> MethodError M([1, 0], 1, v)\njulia> M(t, [1, 0], 1, v)\n[-1, 1]\njulia> M = MixedConstraint((x, u, v) -> [2x[2]-u^2+v[3], x[1]], autonomous=true, variable=true)\njulia> M([1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M(t, [1, 0], 1, [1, 2, 3])\n[2, 1]\njulia> M = MixedConstraint((t, x, u) -> [t+2x[2]-u^2, x[1]], autonomous=false, variable=false)\njulia> M(1, [1, 0], 1)\n[0, 1]\njulia> M(1, [1, 0], 1, v)\n[0, 1]\njulia> M = MixedConstraint((t, x, u, v) -> [t+2x[2]-u^2+v[3], x[1]], autonomous=false, variable=true)\njulia> M(1, [1, 0], 1, [1, 2, 3])\n[3, 1]"},{"id":906,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctproblems/stable/#CTBase.Multiplier","content":" CTBase.Multiplier  —  Type struct Multiplier{time_dependence, variable_dependence} Fields f::Function Similar to  ControlLaw  in the usage. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  Multiplier  returns a  Multiplier  of a function. The function must take 2 to 4 arguments,  (x, p)  to  (t, x, p, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true) Warning When the state and costate are of dimension 1, consider  x  and  p  as scalars. Call The call returns the evaluation of the  Multiplier  for given values. Examples julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":907,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctproblems/stable/#CTBase.Multiplier-Tuple{Function, Vararg{DataType}}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function,\n    dependencies::DataType...\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], Autonomous, Fixed)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], Autonomous, NonFixed)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], NonAutonomous, Fixed)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], NonAutonomous, NonFixed)"},{"id":908,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctproblems/stable/#CTBase.Multiplier-Tuple{Function}","content":" CTBase.Multiplier  —  Method Multiplier(\n    f::Function;\n    autonomous,\n    variable\n) -> Multiplier{Autonomous, Fixed}\n Return the  Multiplier  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)"},{"id":909,"pagetitle":"CTBase API","title":"CTBase.Multiplier","ref":"/ctproblems/stable/#CTBase.Multiplier-Tuple{Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}","content":" CTBase.Multiplier  —  Method Return the value of the Multiplier function. julia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> Multiplier((x, p) -> x[1]^2+2p[2], Int64)\nIncorrectArgument\njulia> μ = Multiplier((x, p) -> x[1]^2+2p[2], autonomous=true, variable=false)\njulia> μ([1, 0], [0, 1])\n3\njulia> t = 1\njulia> v = Real[]\njulia> μ(t, [1, 0], [0, 1])\nMethodError\njulia> μ([1, 0], [0, 1], v)\nMethodError\njulia> μ(t, [1, 0], [0, 1], v)\n3\njulia> μ = Multiplier((x, p, v) -> x[1]^2+2p[2]+v[3], autonomous=true, variable=true)\njulia> μ([1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ(t, [1, 0], [0, 1], [1, 2, 3])\n6\njulia> μ = Multiplier((t, x, p) -> t+x[1]^2+2p[2], autonomous=false, variable=false)\njulia> μ(1, [1, 0], [0, 1])\n4\njulia> μ(1, [1, 0], [0, 1], v)\n4\njulia> μ = Multiplier((t, x, p, v) -> t+x[1]^2+2p[2]+v[3], autonomous=false, variable=true)\njulia> μ(1, [1, 0], [0, 1], [1, 2, 3])\n7"},{"id":910,"pagetitle":"CTBase API","title":"CTBase.NonAutonomous","ref":"/ctproblems/stable/#CTBase.NonAutonomous","content":" CTBase.NonAutonomous  —  Type abstract type NonAutonomous <: TimeDependence"},{"id":911,"pagetitle":"CTBase API","title":"CTBase.NonFixed","ref":"/ctproblems/stable/#CTBase.NonFixed","content":" CTBase.NonFixed  —  Type abstract type NonFixed <: VariableDependence"},{"id":912,"pagetitle":"CTBase API","title":"CTBase.NotImplemented","ref":"/ctproblems/stable/#CTBase.NotImplemented","content":" CTBase.NotImplemented  —  Type struct NotImplemented <: CTException Exception thrown when a method is not implemented. Fields var::String"},{"id":913,"pagetitle":"CTBase API","title":"CTBase.OptimalControlModel","ref":"/ctproblems/stable/#CTBase.OptimalControlModel","content":" CTBase.OptimalControlModel  —  Type mutable struct OptimalControlModel{time_dependence<:TimeDependence, variable_dependence<:VariableDependence} <: CTBase.AbstractOptimalControlModel Fields model_expression::Union{Nothing, Expr} : Default: nothing initial_time::Union{Nothing, Index, Real} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time::Union{Nothing, Index, Real} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing lagrange::Union{Nothing, Lagrange} : Default: nothing mayer::Union{Nothing, Mayer} : Default: nothing criterion::Union{Nothing, Symbol} : Default: nothing dynamics::Union{Nothing, Dynamics} : Default: nothing constraints::Dict{Symbol, Tuple} : Default: Dict{Symbol, Tuple{Vararg{Any}}}()"},{"id":914,"pagetitle":"CTBase API","title":"CTBase.OptimalControlSolution","ref":"/ctproblems/stable/#CTBase.OptimalControlSolution","content":" CTBase.OptimalControlSolution  —  Type mutable struct OptimalControlSolution <: CTBase.AbstractOptimalControlSolution Type of an optimal control solution. Fields times::Union{Nothing, StepRangeLen, AbstractVector{<:Real}} : Default: nothing initial_time_name::Union{Nothing, String} : Default: nothing final_time_name::Union{Nothing, String} : Default: nothing time_name::Union{Nothing, String} : Default: nothing control_dimension::Union{Nothing, Integer} : Default: nothing control_components_names::Union{Nothing, Vector{String}} : Default: nothing control_name::Union{Nothing, String} : Default: nothing control::Union{Nothing, Function} : Default: nothing state_dimension::Union{Nothing, Integer} : Default: nothing state_components_names::Union{Nothing, Vector{String}} : Default: nothing state_name::Union{Nothing, String} : Default: nothing state::Union{Nothing, Function} : Default: nothing variable_dimension::Union{Nothing, Integer} : Default: nothing variable_components_names::Union{Nothing, Vector{String}} : Default: nothing variable_name::Union{Nothing, String} : Default: nothing variable::Union{Nothing, Real, AbstractVector{<:Real}} : Default: nothing costate::Union{Nothing, Function} : Default: nothing objective::Union{Nothing, Real} : Default: nothing iterations::Union{Nothing, Integer} : Default: nothing stopping::Union{Nothing, Symbol} : Default: nothing message::Union{Nothing, String} : Default: nothing success::Union{Nothing, Bool} : Default: nothing infos::Dict{Symbol, Any} : Default: Dict{Symbol, Any}()"},{"id":915,"pagetitle":"CTBase API","title":"CTBase.ParsingError","ref":"/ctproblems/stable/#CTBase.ParsingError","content":" CTBase.ParsingError  —  Type struct ParsingError <: CTException Exception thrown for syntax error during abstract parsing. Fields var::String"},{"id":916,"pagetitle":"CTBase API","title":"CTBase.PrintCallback","ref":"/ctproblems/stable/#CTBase.PrintCallback","content":" CTBase.PrintCallback  —  Type mutable struct PrintCallback <: CTCallback Callback for printing."},{"id":917,"pagetitle":"CTBase API","title":"CTBase.PrintCallback","ref":"/ctproblems/stable/#CTBase.PrintCallback-Tuple","content":" CTBase.PrintCallback  —  Method Call the callback."},{"id":918,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctproblems/stable/#CTBase.StateConstraint","content":" CTBase.StateConstraint  —  Type struct StateConstraint{time_dependence, variable_dependence} Fields f::Function Similar to  VectorField  in the usage, but the dimension of the output of the function  f  is arbitrary. The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  StateConstraint  returns a  StateConstraint  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  StateConstraint  for given values. Examples julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":919,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctproblems/stable/#CTBase.StateConstraint-Tuple{Function, Vararg{DataType}}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function,\n    dependencies::DataType...\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], Autonomous, Fixed)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], Autonomous, NonFixed)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous, Fixed)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)"},{"id":920,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctproblems/stable/#CTBase.StateConstraint-Tuple{Function}","content":" CTBase.StateConstraint  —  Method StateConstraint(\n    f::Function;\n    autonomous,\n    variable\n) -> StateConstraint{Autonomous, Fixed}\n Return the  StateConstraint  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)"},{"id":921,"pagetitle":"CTBase API","title":"CTBase.StateConstraint","ref":"/ctproblems/stable/#CTBase.StateConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.StateConstraint  —  Method Return the value of the StateConstraint function. julia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> StateConstraint(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> S = StateConstraint(x -> [x[1]^2, 2x[2]], autonomous=true, variable=false)\njulia> S([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> S(t, [1, -1], v)\n[1, -2]\njulia> S = StateConstraint((x, v) -> [x[1]^2, 2x[2]+v[3]], autonomous=true, variable=true)\njulia> S([1, -1], [1, 2, 3])\n[1, 1]\njulia> S(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> S = StateConstraint((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false, variable=false)\njulia>  S(1, [1, -1])\n[2, -2]\njulia>  S(1, [1, -1], v)\n[2, -2]\njulia> S = StateConstraint((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia>  S(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":922,"pagetitle":"CTBase API","title":"CTBase.States","ref":"/ctproblems/stable/#CTBase.States","content":" CTBase.States  —  Type Type alias for a vector of states."},{"id":923,"pagetitle":"CTBase API","title":"CTBase.StopCallback","ref":"/ctproblems/stable/#CTBase.StopCallback","content":" CTBase.StopCallback  —  Type Stopping callback."},{"id":924,"pagetitle":"CTBase API","title":"CTBase.StopCallback","ref":"/ctproblems/stable/#CTBase.StopCallback-Tuple","content":" CTBase.StopCallback  —  Method Call the callback."},{"id":925,"pagetitle":"CTBase API","title":"CTBase.Time","ref":"/ctproblems/stable/#CTBase.Time","content":" CTBase.Time  —  Type Type alias for a time."},{"id":926,"pagetitle":"CTBase API","title":"CTBase.TimeDependence","ref":"/ctproblems/stable/#CTBase.TimeDependence","content":" CTBase.TimeDependence  —  Type abstract type TimeDependence"},{"id":927,"pagetitle":"CTBase API","title":"CTBase.Times","ref":"/ctproblems/stable/#CTBase.Times","content":" CTBase.Times  —  Type Type alias for a vector of times."},{"id":928,"pagetitle":"CTBase API","title":"CTBase.UnauthorizedCall","ref":"/ctproblems/stable/#CTBase.UnauthorizedCall","content":" CTBase.UnauthorizedCall  —  Type struct UnauthorizedCall <: CTException Exception thrown when a call to a function is not authorized. Fields var::String"},{"id":929,"pagetitle":"CTBase API","title":"CTBase.VariableConstraint","ref":"/ctproblems/stable/#CTBase.VariableConstraint","content":" CTBase.VariableConstraint  —  Type struct VariableConstraint Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VariableConstraint  returns a  VariableConstraint  of a function. The function must take 1 argument,  v . Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]]) Warning When the variable is of dimension 1, consider  v  as a scalar. Call The call returns the evaluation of the  VariableConstraint  for given values. Examples julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]"},{"id":930,"pagetitle":"CTBase API","title":"CTBase.VariableConstraint","ref":"/ctproblems/stable/#CTBase.VariableConstraint-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VariableConstraint  —  Method Return the value of the VariableConstraint function. julia> V = VariableConstraint(v -> [v[1]^2, 2v[2]])\njulia> V([1, -1])\n[1, -2]"},{"id":931,"pagetitle":"CTBase API","title":"CTBase.VariableDependence","ref":"/ctproblems/stable/#CTBase.VariableDependence","content":" CTBase.VariableDependence  —  Type abstract type VariableDependence"},{"id":932,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctproblems/stable/#CTBase.VectorField","content":" CTBase.VectorField  —  Type struct VectorField{time_dependence, variable_dependence} <: CTBase.AbstractVectorField{time_dependence, variable_dependence} Fields f::Function The default values for  time_dependence  and  variable_dependence  are  Autonomous  and  Fixed  respectively. Constructor The constructor  VectorField  returns a  VectorField  of a function. The function must take 1 to 3 arguments,  x  to  (t, x, v) , if the function is variable or non autonomous, it must be specified.  Dependencies are specified either with : booleans,  autonomous  and  variable , respectively  true  and  false  by default  DataType ,  Autonomous / NonAutonomous  and  NonFixed / Fixed , respectively  Autonomous  and  Fixed  by default. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed) Warning When the state is of dimension 1, consider  x  as a scalar. Call The call returns the evaluation of the  VectorField  for given values. Examples julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":933,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctproblems/stable/#CTBase.VectorField-Tuple{Function, Vararg{DataType}}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function,\n    dependencies::DataType...\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with DataType, Autonomous, NonAutonomous and Fixed, NonFixed. julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], NonFixed)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], NonAutonomous)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], NonAutonomous, NonFixed)"},{"id":934,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctproblems/stable/#CTBase.VectorField-Tuple{Function}","content":" CTBase.VectorField  —  Method VectorField(\n    f::Function;\n    autonomous,\n    variable\n) -> VectorField{Autonomous, Fixed}\n Return a  VectorField  of a function. Dependencies are specified with a boolean, variable, false by default, autonomous, true by default. julia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)"},{"id":935,"pagetitle":"CTBase API","title":"CTBase.VectorField","ref":"/ctproblems/stable/#CTBase.VectorField-Tuple{Union{Real, AbstractVector{<:Real}}}","content":" CTBase.VectorField  —  Method Return the value of the VectorField. Examples julia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> VectorField(x -> [x[1]^2, 2x[2]], Int64)\nIncorrectArgument\njulia> V = VectorField(x -> [x[1]^2, 2x[2]]) # autonomous=true, variable=false\njulia> V([1, -1])\n[1, -2]\njulia> t = 1\njulia> v = Real[]\njulia> V(t, [1, -1])\nMethodError\njulia> V([1, -1], v)\nMethodError\njulia> V(t, [1, -1], v)\n[1, -2]\njulia> V = VectorField((x, v) -> [x[1]^2, 2x[2]+v[3]], variable=true)\njulia> V([1, -1], [1, 2, 3])\n[1, 1]\njulia> V(t, [1, -1], [1, 2, 3])\n[1, 1]\njulia> V = VectorField((t, x) -> [t+x[1]^2, 2x[2]], autonomous=false)\njulia> V(1, [1, -1])\n[2, -2]\njulia> V(1, [1, -1], v)\n[2, -2]\njulia> V = VectorField((t, x, v) -> [t+x[1]^2, 2x[2]+v[3]], autonomous=false, variable=true)\njulia> V(1, [1, -1], [1, 2, 3])\n[2, 1]"},{"id":936,"pagetitle":"CTBase API","title":"CTBase.ctNumber","ref":"/ctproblems/stable/#CTBase.ctNumber","content":" CTBase.ctNumber  —  Type Type alias for a real number."},{"id":937,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/ctproblems/stable/#CTBase.:⋅-Tuple{Function, Function}","content":" CTBase.:⋅  —  Method ⋅(X::Function, f::Function) -> Function\n Lie derivative of a scalar function along a function. In this case both functions will be considered autonomous and non-variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (φ⋅f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (φ⋅f)(1, [1, 2], [2, 1])\nMethodError"},{"id":938,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/ctproblems/stable/#CTBase.:⋅-Tuple{VectorField{Autonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{Autonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#105#107\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in autonomous case Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> (X⋅f)([1, 2])\n0"},{"id":939,"pagetitle":"CTBase API","title":"CTBase.:⋅","ref":"/ctproblems/stable/#CTBase.:⋅-Tuple{VectorField{NonAutonomous, <:VariableDependence}, Function}","content":" CTBase.:⋅  —  Method ⋅(\n    X::VectorField{NonAutonomous, <:VariableDependence},\n    f::Function\n) -> CTBase.var\"#109#111\"\n Lie derivative of a scalar function along a vector field : L_X(f) = X⋅f, in nonautonomous case Example julia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> (X⋅f)(1, [1, 2], [2, 1])\n10"},{"id":940,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctproblems/stable/#CTBase.Lie-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function,\n    dependences::DataType...\n) -> Function\n Lie derivative of a scalar function along a vector field or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, NonAutonomous, NonFixed)(1, [1, 2], [2, 1])\n10"},{"id":941,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctproblems/stable/#CTBase.Lie-Tuple{Function, Function}","content":" CTBase.Lie  —  Method Lie(\n    X::Function,\n    f::Function;\n    autonomous,\n    variable\n) -> Function\n Lie derivative of a scalar function along a function. Dependencies are specified with boolean : autonomous and variable. Example julia> φ = x -> [x[2], -x[1]]\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(φ,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(φ, f, autonomous=false, variable=true)(1, [1, 2], [2, 1])\n10"},{"id":942,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctproblems/stable/#CTBase.Lie-Tuple{VectorField, Function}","content":" CTBase.Lie  —  Method Lie(X::VectorField, f::Function) -> Function\n Lie derivative of a scalar function along a vector field. Example julia> φ = x -> [x[2], -x[1]]\njulia> X = VectorField(φ)\njulia> f = x -> x[1]^2 + x[2]^2\njulia> Lie(X,f)([1, 2])\n0\njulia> φ = (t, x, v) -> [t + x[2] + v[1], -x[1] + v[2]]\njulia> X = VectorField(φ, NonAutonomous, NonFixed)\njulia> f = (t, x, v) -> t + x[1]^2 + x[2]^2\njulia> Lie(X, f)(1, [1, 2], [2, 1])\n10"},{"id":943,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctproblems/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{Autonomous, V}, VectorField{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{Autonomous, V<:VariableDependence},\n    Y::VectorField{Autonomous, V<:VariableDependence}\n) -> VectorField{Autonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), autonomous case Example julia> f = x -> [x[2], 2x[1]]\njulia> g = x -> [3x[2], -x[1]]\njulia> X = VectorField(f)\njulia> Y = VectorField(g)\njulia> Lie(X, Y)([1, 2])\n[7, -14]"},{"id":944,"pagetitle":"CTBase API","title":"CTBase.Lie","ref":"/ctproblems/stable/#CTBase.Lie-Union{Tuple{V}, Tuple{VectorField{NonAutonomous, V}, VectorField{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Lie  —  Method Lie(\n    X::VectorField{NonAutonomous, V<:VariableDependence},\n    Y::VectorField{NonAutonomous, V<:VariableDependence}\n) -> VectorField{NonAutonomous}\n Lie bracket of two vector fields: [X, Y] = Lie(X, Y), nonautonomous case Example julia> f = (t, x, v) -> [t + x[2] + v, -2x[1] - v]\njulia> g = (t, x, v) -> [t + 3x[2] + v, -x[1] - v]\njulia> X = VectorField(f, NonAutonomous, NonFixed)\njulia> Y = VectorField(g, NonAutonomous, NonFixed)\njulia> Lie(X, Y)(1, [1, 2], 1)\n[-7,12]"},{"id":945,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/ctproblems/stable/#CTBase.Lift-Tuple{Function, Vararg{DataType}}","content":" CTBase.Lift  —  Method Lift(\n    X::Function,\n    dependences::DataType...\n) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField or a function. Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2"},{"id":946,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/ctproblems/stable/#CTBase.Lift-Tuple{Function}","content":" CTBase.Lift  —  Method Lift(X::Function; autonomous, variable) -> HamiltonianLift\n Return the HamiltonianLift of a function. Dependencies are specified with boolean : autonomous and variable. Example julia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2"},{"id":947,"pagetitle":"CTBase API","title":"CTBase.Lift","ref":"/ctproblems/stable/#CTBase.Lift-Tuple{VectorField}","content":" CTBase.Lift  —  Method Lift(X::VectorField) -> HamiltonianLift\n Return the HamiltonianLift of a VectorField. Example julia> HL = Lift(VectorField(x -> [x[1]^2,x[2]^2], autonomous=true, variable=false))\njulia> HL([1, 0], [0, 1])\n0\njulia> HL = Lift(VectorField((t, x, v) -> [t+x[1]^2,x[2]^2+v], autonomous=false, variable=true))\njulia> HL(1, [1, 0], [0, 1], 1)\n1\njulia> H = Lift(x -> 2x)\njulia> H(1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, autonomous=false, variable=true)\njulia> H(1, 1, 1, 1)\n2\njulia> H = Lift((t, x, v) -> 2x + t - v, NonAutonomous, NonFixed)\njulia> H(1, 1, 1, 1)\n2"},{"id":948,"pagetitle":"CTBase API","title":"CTBase.Model","ref":"/ctproblems/stable/#CTBase.Model-Tuple{Vararg{DataType}}","content":" CTBase.Model  —  Method Model(\n    dependencies::DataType...\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following argument: dependencies : either  Autonomous  or  NonAutonomous . Default is  Autonomous . And either  NonFixed  or  Fixed . Default is  Fixed . Examples julia> ocp = Model()\njulia> ocp = Model(NonAutonomous)\njulia> ocp = Model(Autonomous, NonFixed) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control."},{"id":949,"pagetitle":"CTBase API","title":"CTBase.Model","ref":"/ctproblems/stable/#CTBase.Model-Tuple{}","content":" CTBase.Model  —  Method Model(\n;\n    autonomous,\n    variable\n) -> OptimalControlModel{Autonomous, Fixed}\n Return a new  OptimalControlModel  instance, that is a model of an optimal control problem. The model is defined by the following optional keyword argument: autonomous : either  true  or  false . Default is  true . variable : either  true  or  false . Default is  false . Examples julia> ocp = Model()\njulia> ocp = Model(autonomous=false)\njulia> ocp = Model(autonomous=false, variable=true) Note If the time dependence of the model is defined as nonautonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of time and state, and possibly control. If the model is defined as autonomous, then, the dynamics function, the lagrange cost and the path constraints must be defined as functions of state, and possibly control."},{"id":950,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctproblems/stable/#CTBase.Poisson-Tuple{Function, Function, Vararg{DataType}}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function,\n    dependences::DataType...\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with DataType : Autonomous, NonAutonomous and Fixed, NonFixed. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":951,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctproblems/stable/#CTBase.Poisson-Tuple{Function, Function}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::Function;\n    autonomous,\n    variable\n) -> Hamiltonian\n Poisson bracket of two functions : {f, g} = Poisson(f, g) Dependencies are specified with boolean : autonomous and variable. Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> Poisson(f, g, autonomous=false, variable=true)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":952,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctproblems/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{Autonomous, V}, AbstractHamiltonian{Autonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{Autonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{Autonomous, V<:VariableDependence}\n) -> HamiltonianLift{Autonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> G = Hamiltonian(g)\njulia> Poisson(f, g)([1, 2], [2, 1])\n-20            \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20"},{"id":953,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctproblems/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{AbstractHamiltonian{NonAutonomous, V}, AbstractHamiltonian{NonAutonomous, V}}} where V<:VariableDependence","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{NonAutonomous, V<:VariableDependence},\n    g::AbstractHamiltonian{NonAutonomous, V<:VariableDependence}\n) -> HamiltonianLift{NonAutonomous}\n Poisson bracket of two Hamiltonian functions (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g), non autonomous case Example julia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n-76\njulia> Poisson(f, g, NonAutonomous, NonFixed)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":954,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctproblems/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{AbstractHamiltonian{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence},\n    g::Function\n) -> Hamiltonian\n Poisson bracket of an Hamiltonian function (subtype of AbstractHamiltonian) and a function : {f, g} = Poisson(f, g), autonomous case Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> F = Hamiltonian(f)\njulia> Poisson(F, g)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> F = Hamiltonian(f, autonomous=false, variable=true)\njulia> Poisson(F, g)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":955,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctproblems/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{Function, AbstractHamiltonian{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::Function,\n    g::AbstractHamiltonian{T<:TimeDependence, V<:VariableDependence}\n) -> Hamiltonian\n Poisson bracket of a function and an Hamiltonian function (subtype of AbstractHamiltonian) : {f, g} = Poisson(f, g) Example julia> f = (x, p) -> x[2]^2 + 2x[1]^2 + p[1]^2\njulia> g = (x, p) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1]\njulia> G = Hamiltonian(g)          \njulia> Poisson(f, G)([1, 2], [2, 1])\n-20\njulia> f = (t, x, p, v) -> t*v[1]*x[2]^2 + 2x[1]^2 + p[1]^2 + v[2]\njulia> g = (t, x, p, v) -> 3x[2]^2 + -x[1]^2 + p[2]^2 + p[1] + t - v[2]\njulia> G = Hamiltonian(g, autonomous=false, variable=true)\njulia> Poisson(f, G)(2, [1, 2], [2, 1], [4, 4])\n-76"},{"id":956,"pagetitle":"CTBase API","title":"CTBase.Poisson","ref":"/ctproblems/stable/#CTBase.Poisson-Union{Tuple{V}, Tuple{T}, Tuple{HamiltonianLift{T, V}, HamiltonianLift{T, V}}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.Poisson  —  Method Poisson(\n    f::HamiltonianLift{T<:TimeDependence, V<:VariableDependence},\n    g::HamiltonianLift{T<:TimeDependence, V<:VariableDependence}\n) -> HamiltonianLift\n Poisson bracket of two HamiltonianLift functions : {f, g} = Poisson(f, g) Example julia> f = x -> [x[1]^2+x[2]^2, 2x[1]^2]\njulia> g = x -> [3x[2]^2, x[2]-x[1]^2]\njulia> F = Lift(f)\njulia> G = Lift(g)\njulia> Poisson(F, G)([1, 2], [2, 1])\n-64\njulia> f = (t, x, v) -> [t*v[1]*x[2]^2, 2x[1]^2 + + v[2]]\njulia> g = (t, x, v) -> [3x[2]^2 + -x[1]^2, t - v[2]]\njulia> F = Lift(f, NonAutonomous, NonFixed)\njulia> G = Lift(g, NonAutonomous, NonFixed)\njulia> Poisson(F, G)(2, [1, 2], [2, 1], [4, 4])\n100"},{"id":957,"pagetitle":"CTBase API","title":"CTBase.add","ref":"/ctproblems/stable/#CTBase.add-Tuple{Tuple{Vararg{Tuple{Vararg{Symbol}}}}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{Vararg{Tuple{Vararg{Symbol}}}},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Concatenate the description  y  at the tuple of descriptions  x  if it is not already in the tuple  x . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions = add(descriptions, (:b,))\n((:a,), (:b,))"},{"id":958,"pagetitle":"CTBase API","title":"CTBase.add","ref":"/ctproblems/stable/#CTBase.add-Tuple{Tuple{}, Tuple{Vararg{Symbol}}}","content":" CTBase.add  —  Method add(\n    x::Tuple{},\n    y::Tuple{Vararg{Symbol}}\n) -> Tuple{Tuple{Vararg{Symbol}}}\n Return a tuple containing only the description  y . Example julia> descriptions = ()\njulia> descriptions = add(descriptions, (:a,))\n((:a,),)\njulia> descriptions[1]\n(:a,)"},{"id":959,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctproblems/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on a range of the state, or a value constraint on a range of the  :variable . Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ])\njulia> constraint!(ocp, :initial, 2:3, [ 0, 0 ])\njulia> constraint!(ocp, :final, Index(2), 0)\njulia> constraint!(ocp, :variable, 2:3, [ 0, 3 ])"},{"id":960,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctproblems/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint (whole range). Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :final, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :control, [ 0, 0 ], [ 2, 3 ])\njulia> constraint!(ocp, :state, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 0, 1) # the variable here is of dimension 1"},{"id":961,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctproblems/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial  or  :final  value constraint on the state, or a  :variable  value. Can also be used with  :state  and  :control . Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> constraint!(ocp, :initial, [ 0, 0 ])\njulia> constraint!(ocp, :final, 2) # if the state is of dimension 1\njulia> constraint!(ocp, :variable, [ 3, 0, 1 ])"},{"id":962,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctproblems/stable/#CTBase.constraint!","content":" CTBase.constraint!  —  Function constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel,\n    type::Symbol,\n    f::Function,\n    val::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  value functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[2], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u+v[1], 0)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u-t*v[2], 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t+v[1], [ 0, 0, 0 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]-u*v[1], 0)"},{"id":963,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctproblems/stable/#CTBase.constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel,\n    type::Symbol;\n    rg,\n    f,\n    val,\n    lb,\n    ub,\n    label\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :final, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :control, val=Index(1), lb=0, ub=2)\njulia> constraint!(ocp, :state, rg=2:3, lb=[ 0, 0 ], ub=[ 1, 2 ])\njulia> constraint!(ocp, :initial, rg=1:2:5, lb=[ 0, 0, 0 ], ub=[ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, rg=1:2, lb=[ 0, 0 ], ub=[ 1, 2 ])"},{"id":964,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctproblems/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{<:TimeDependence, V}, Symbol, Union{Index, OrdinalRange{<:Integer}}, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where V<:VariableDependence","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    rg::Union{Index, OrdinalRange{<:Integer}},\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add an  :initial ,  :final ,  :control ,  :state  or  :variable  box constraint on a range. Note The range of the constraint must be contained in 1:n if the constraint is on the state, or 1:m if the constraint is on the control, or 1:q if the constraint is on the variable. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. Examples julia> constraint!(ocp, :initial, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :final, Index(1), 0, 2)\njulia> constraint!(ocp, :control, Index(1), 0, 2)\njulia> constraint!(ocp, :state, 2:3, [ 0, 0 ], [ 1, 2 ])\njulia> constraint!(ocp, :initial, 1:2:5, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :variable, 1:2, [ 0, 0 ], [ 1, 2 ])"},{"id":965,"pagetitle":"CTBase API","title":"CTBase.constraint!","ref":"/ctproblems/stable/#CTBase.constraint!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Union{Real, AbstractVector{<:Real}}, Union{Real, AbstractVector{<:Real}}, Symbol}} where {T, V}","content":" CTBase.constraint!  —  Method constraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}}\n)\nconstraint!(\n    ocp::OptimalControlModel{T, V},\n    type::Symbol,\n    f::Function,\n    lb::Union{Real, AbstractVector{<:Real}},\n    ub::Union{Real, AbstractVector{<:Real}},\n    label::Symbol\n)\n Add a  :boundary ,  :control ,  :state ,  :mixed  or  :variable  box functional constraint. Note The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples # variable independent ocp\njulia> constraint!(ocp, :boundary, (x0, xf) -> x0[3]+xf[2], 0, 1)\n\n# variable dependent ocp\njulia> constraint!(ocp, :boundary, (x0, xf, v) -> x0[3]+xf[2]*v[1], 0, 1)\n\n# time independent and variable independent ocp\njulia> constraint!(ocp, :control, u -> 2u, 0, 1)\njulia> constraint!(ocp, :state, x -> x-1, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u) -> x[1]-u, 0, 1)\n\n# time dependent and variable independent ocp\njulia> constraint!(ocp, :control, (t, u) -> 2u, 0, 1)\njulia> constraint!(ocp, :state, (t, x) -> x-t, [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u) -> x[1]-u, 0, 1)\n\n# time independent and variable dependent ocp\njulia> constraint!(ocp, :control, (u, v) -> 2u*v[1], 0, 1)\njulia> constraint!(ocp, :state, (x, v) -> x-v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (x, u, v) -> x[1]-v[2]*u, 0, 1)\n\n# time dependent and variable dependent ocp\njulia> constraint!(ocp, :control, (t, u, v) -> 2u+v[2], 0, 1)\njulia> constraint!(ocp, :state, (t, x, v) -> x-t*v[1], [ 0, 0, 0 ], [ 1, 2, 1 ])\njulia> constraint!(ocp, :mixed, (t, x, u, v) -> x[1]*v[2]-u, 0, 1)"},{"id":966,"pagetitle":"CTBase API","title":"CTBase.constraint","ref":"/ctproblems/stable/#CTBase.constraint-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.constraint  —  Method constraint(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    label::Symbol\n) -> Any\n Retrieve a labeled constraint. The result is a function associated with the constraint computation (not taking into account provided value / bounds). Example julia> constraint!(ocp, :initial, 0, :c0)\njulia> c = constraint(ocp, :c0)\njulia> c(1)\n1"},{"id":967,"pagetitle":"CTBase API","title":"CTBase.constraint_type","ref":"/ctproblems/stable/#CTBase.constraint_type-NTuple{7, Any}","content":" CTBase.constraint_type  —  Method constraint_type(\n    e,\n    t,\n    t0,\n    tf,\n    x,\n    u,\n    v\n) -> Union{Symbol, Tuple{Symbol, Any}}\n Return the type constraint among  :initial ,  :final ,  :boundary ,  :control_range ,  :control_fun ,  :state_range ,  :state_fun ,  :mixed ,  :variable_range ,  :variable_fun  ( :other  otherwise), together with the appropriate value (range, updated expression...) Example julia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u; v = :v\n\njulia> constraint_type(:( ẏ(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( ẋ(s) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( x(0)' ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(t)' ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( x(0) ), t, t0, tf, x, u, v)\n(:initial, nothing)\n\njulia> constraint_type(:( x[1:2:5](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2:5)\n\njulia> constraint_type(:( x[1:2](0) ), t, t0, tf, x, u, v)\n(:initial, 1:2)\n\njulia> constraint_type(:( x[1](0) ), t, t0, tf, x, u, v)\n(:initial, Index(1))\n\njulia> constraint_type(:( 2x[1](0)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x(tf) ), t, t0, tf, x, u, v)\n(:final, nothing)\nj\njulia> constraint_type(:( x[1:2:5](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2:5)\n\njulia> constraint_type(:( x[1:2](tf) ), t, t0, tf, x, u, v)\n(:final, 1:2)\n\njulia> constraint_type(:( x[1](tf) ), t, t0, tf, x, u, v)\n(:final, Index(1))\n\njulia> constraint_type(:( 2x[1](tf)^2 ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( x[1](tf) - x[2](0) ), t, t0, tf, x, u, v)\n:boundary\n\njulia> constraint_type(:( u[1:2:5](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2:5)\n\njulia> constraint_type(:( u[1:2](t) ), t, t0, tf, x, u, v)\n(:control_range, 1:2)\n\njulia> constraint_type(:( u[1](t) ), t, t0, tf, x, u, v)\n(:control_range, Index(1))\n\njulia> constraint_type(:( u(t) ), t, t0, tf, x, u, v)\n(:control_range, nothing)\n\njulia> constraint_type(:( 2u[1](t)^2 ), t, t0, tf, x, u, v)\n:control_fun\n\njulia> constraint_type(:( x[1:2:5](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2:5)\n\njulia> constraint_type(:( x[1:2](t) ), t, t0, tf, x, u, v)\n(:state_range, 1:2)\n\njulia> constraint_type(:( x[1](t) ), t, t0, tf, x, u, v)\n(:state_range, Index(1))\n\njulia> constraint_type(:( x(t) ), t, t0, tf, x, u, v)\n(:state_range, nothing)\n\njulia> constraint_type(:( 2x[1](t)^2 ), t, t0, tf, x, u, v)\n:state_fun\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](0)^2 * x(t) ), t, t0, tf, x, u, v)\n:other\n\njulia> constraint_type(:( 2u[1](t)^2 * x(t) + v ), t, t0, tf, x, u, v)\n:mixed\n\njulia> constraint_type(:( v[1:2:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:2:9)\n\njulia> constraint_type(:( v[1:10] ), t, t0, tf, x, u, v)\n(:variable_range, 1:10)\n\njulia> constraint_type(:( v[2] ), t, t0, tf, x, u, v)\n(:variable_range, Index(2))\n\njulia> constraint_type(:( v ), t, t0, tf, x, u, v)\n(:variable_range, nothing)\n\njulia> constraint_type(:( v^2  + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v ^ 2 + 1))\n\njulia> constraint_type(:( v[2]^2 + 1 ), t, t0, tf, x, u, v)\n(:variable_fun, :(v[2] ^ 2 + 1))"},{"id":968,"pagetitle":"CTBase API","title":"CTBase.constraints_labels","ref":"/ctproblems/stable/#CTBase.constraints_labels-Tuple{OptimalControlModel}","content":" CTBase.constraints_labels  —  Method constraints_labels(\n    ocp::OptimalControlModel\n) -> Base.KeySet{Symbol, Dict{Symbol, Tuple}}\n Return the labels of the constraints as a  Base.keys . Example julia> constraints_labels(ocp)"},{"id":969,"pagetitle":"CTBase API","title":"CTBase.control!","ref":"/ctproblems/stable/#CTBase.control!","content":" CTBase.control!  —  Function control!(ocp::OptimalControlModel, m::Integer)\ncontrol!(ocp::OptimalControlModel, m::Integer, name::String)\ncontrol!(\n    ocp::OptimalControlModel,\n    m::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the control dimension and possibly the names of each coordinate. Note You must use control! only once to set the control dimension. Examples julia> control!(ocp, 1)\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"u\"]\n\njulia> control!(ocp, 1, \"v\")\njulia> ocp.control_dimension\n1\njulia> ocp.control_components_names\n[\"v\"]\n\njulia> control!(ocp, 2)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"u₁\", \"u₂\"]\n\njulia> control!(ocp, 2, :v)\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]\n\njulia> control!(ocp, 2, \"v\")\njulia> ocp.control_dimension\n2\njulia> ocp.control_components_names\n[\"v₁\", \"v₂\"]"},{"id":970,"pagetitle":"CTBase API","title":"CTBase.ct_repl","ref":"/ctproblems/stable/#CTBase.ct_repl-Tuple{}","content":" CTBase.ct_repl  —  Method ct_repl(; debug, demo) -> Any\n Create a ct REPL."},{"id":971,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/ctproblems/stable/#CTBase.ctgradient-Tuple{Function, Any}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x) -> Any\n Return the gradient of  f  at  x ."},{"id":972,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/ctproblems/stable/#CTBase.ctgradient-Tuple{Function, Real}","content":" CTBase.ctgradient  —  Method ctgradient(f::Function, x::Real) -> Any\n Return the gradient of  f  at  x ."},{"id":973,"pagetitle":"CTBase API","title":"CTBase.ctgradient","ref":"/ctproblems/stable/#CTBase.ctgradient-Tuple{VectorField, Any}","content":" CTBase.ctgradient  —  Method ctgradient(X::VectorField, x) -> Any\n Return the gradient of  X  at  x ."},{"id":974,"pagetitle":"CTBase API","title":"CTBase.ctindices","ref":"/ctproblems/stable/#CTBase.ctindices-Tuple{Integer}","content":" CTBase.ctindices  —  Method ctindices(i::Integer) -> String\n Return  i  > 0 as a subscript."},{"id":975,"pagetitle":"CTBase API","title":"CTBase.ctinterpolate","ref":"/ctproblems/stable/#CTBase.ctinterpolate-Tuple{Any, Any}","content":" CTBase.ctinterpolate  —  Method ctinterpolate(x, f) -> Any\n Return the interpolation of  f  at  x ."},{"id":976,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/ctproblems/stable/#CTBase.ctjacobian-Tuple{Function, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x) -> Any\n Return the Jacobian of  f  at  x ."},{"id":977,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/ctproblems/stable/#CTBase.ctjacobian-Tuple{Function, Real}","content":" CTBase.ctjacobian  —  Method ctjacobian(f::Function, x::Real) -> Any\n Return the Jacobian of  f  at  x ."},{"id":978,"pagetitle":"CTBase API","title":"CTBase.ctjacobian","ref":"/ctproblems/stable/#CTBase.ctjacobian-Tuple{VectorField, Any}","content":" CTBase.ctjacobian  —  Method ctjacobian(X::VectorField, x) -> Any\n Return the Jacobian of  X  at  x ."},{"id":979,"pagetitle":"CTBase API","title":"CTBase.ctupperscripts","ref":"/ctproblems/stable/#CTBase.ctupperscripts-Tuple{Integer}","content":" CTBase.ctupperscripts  —  Method ctupperscripts(i::Integer) -> String\n Return  i  > 0 as an upperscript."},{"id":980,"pagetitle":"CTBase API","title":"CTBase.dynamics!","ref":"/ctproblems/stable/#CTBase.dynamics!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Function}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.dynamics!  —  Method dynamics!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    f::Function\n)\n Set the dynamics. Note You can use dynamics! only once to define the dynamics. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> dynamics!(ocp, f)"},{"id":981,"pagetitle":"CTBase API","title":"CTBase.getFullDescription","ref":"/ctproblems/stable/#CTBase.getFullDescription-Tuple{Tuple{Vararg{Symbol}}, Tuple{Vararg{Tuple{Vararg{Symbol}}}}}","content":" CTBase.getFullDescription  —  Method getFullDescription(\n    desc::Tuple{Vararg{Symbol}},\n    desc_list::Tuple{Vararg{Tuple{Vararg{Symbol}}}}\n) -> Tuple{Vararg{Symbol}}\n Return a complete description from an incomplete description  desc  and  a list of complete descriptions  desc_list . If several complete descriptions are possible,  then the first one is returned. Example julia> desc_list = ((:a, :b), (:b, :c), (:a, :c))\n((:a, :b), (:b, :c), (:a, :c))\njulia> getFullDescription((:a,), desc_list)\n(:a, :b)"},{"id":982,"pagetitle":"CTBase API","title":"CTBase.get_priority_print_callbacks","ref":"/ctproblems/stable/#CTBase.get_priority_print_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_print_callbacks  —  Method get_priority_print_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority print callbacks."},{"id":983,"pagetitle":"CTBase API","title":"CTBase.get_priority_stop_callbacks","ref":"/ctproblems/stable/#CTBase.get_priority_stop_callbacks-Tuple{Tuple{Vararg{CTCallback}}}","content":" CTBase.get_priority_stop_callbacks  —  Method get_priority_stop_callbacks(\n    cbs::Tuple{Vararg{CTCallback}}\n) -> Tuple{Vararg{CTCallback}}\n Get the highest priority stop callbacks."},{"id":984,"pagetitle":"CTBase API","title":"CTBase.is_max","ref":"/ctproblems/stable/#CTBase.is_max-Tuple{OptimalControlModel}","content":" CTBase.is_max  —  Method is_max(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :max ."},{"id":985,"pagetitle":"CTBase API","title":"CTBase.is_min","ref":"/ctproblems/stable/#CTBase.is_min-Tuple{OptimalControlModel}","content":" CTBase.is_min  —  Method is_min(ocp::OptimalControlModel) -> Bool\n Return  true  if the criterion type of  ocp  is  :min ."},{"id":986,"pagetitle":"CTBase API","title":"CTBase.is_time_dependent","ref":"/ctproblems/stable/#CTBase.is_time_dependent-Tuple{OptimalControlModel{NonAutonomous}}","content":" CTBase.is_time_dependent  —  Method is_time_dependent(\n    ocp::OptimalControlModel{NonAutonomous}\n) -> Bool\n Return  true  if the model has been defined as time dependent."},{"id":987,"pagetitle":"CTBase API","title":"CTBase.is_time_independent","ref":"/ctproblems/stable/#CTBase.is_time_independent-Tuple{OptimalControlModel}","content":" CTBase.is_time_independent  —  Method is_time_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as time independent."},{"id":988,"pagetitle":"CTBase API","title":"CTBase.is_variable_dependent","ref":"/ctproblems/stable/#CTBase.is_variable_dependent-Tuple{OptimalControlModel{<:TimeDependence, NonFixed}}","content":" CTBase.is_variable_dependent  —  Method is_variable_dependent(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed}\n) -> Bool\n Return  true  if the model has been defined as variable dependent."},{"id":989,"pagetitle":"CTBase API","title":"CTBase.is_variable_independent","ref":"/ctproblems/stable/#CTBase.is_variable_independent-Tuple{OptimalControlModel}","content":" CTBase.is_variable_independent  —  Method is_variable_independent(ocp::OptimalControlModel) -> Bool\n Return  true  if the model has been defined as variable independent."},{"id":990,"pagetitle":"CTBase API","title":"CTBase.nlp_constraints","ref":"/ctproblems/stable/#CTBase.nlp_constraints-Tuple{OptimalControlModel}","content":" CTBase.nlp_constraints  —  Method nlp_constraints(\n    ocp::OptimalControlModel\n) -> Tuple{Tuple{Vector{Real}, CTBase.var\"#ξ#99\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#η#100\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ψ#101\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#ϕ#102\", Vector{Real}}, Tuple{Vector{Real}, CTBase.var\"#θ#103\", Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}, Tuple{Vector{Real}, Vector{Int64}, Vector{Real}}}\n Return a 6-tuple of tuples: (ξl, ξ, ξu)  are control constraints (ηl, η, ηu)  are state constraints (ψl, ψ, ψu)  are mixed constraints (ϕl, ϕ, ϕu)  are boundary constraints (θl, θ, θu)  are variable constraints (ul, uind, uu)  are control linear constraints of a subset of indices (xl, xind, xu)  are state linear constraints of a subset of indices (vl, vind, vu)  are variable linear constraints of a subset of indices Note The dimensions of the state and control must be set before calling  nlp_constraints . Example julia> (ξl, ξ, ξu), (ηl, η, ηu), (ψl, ψ, ψu), (ϕl, ϕ, ϕu), (θl, θ, θu),\n    (ul, uind, uu), (xl, xind, xu), (vl, vind, vu) = nlp_constraints(ocp)"},{"id":991,"pagetitle":"CTBase API","title":"CTBase.objective!","ref":"/ctproblems/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    g::Function,\n    f⁰::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  g  and  f⁰ . Type can be  :bolza . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Example julia> objective!(ocp, :bolza, (x0, xf) -> x0[1] + xf[2], (x, u) -> x[1]^2 + u^2) # the control is of dimension 1"},{"id":992,"pagetitle":"CTBase API","title":"CTBase.objective!","ref":"/ctproblems/stable/#CTBase.objective!-Union{Tuple{V}, Tuple{T}, Tuple{OptimalControlModel{T, V}, Symbol, Function}, Tuple{OptimalControlModel{T, V}, Symbol, Function, Symbol}} where {T<:TimeDependence, V<:VariableDependence}","content":" CTBase.objective!  —  Method objective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function\n)\nobjective!(\n    ocp::OptimalControlModel{T<:TimeDependence, V<:VariableDependence},\n    type::Symbol,\n    f::Function,\n    criterion::Symbol\n)\n Set the criterion to the function  f . Type can be  :mayer  or  :lagrange . Criterion is  :min  or  :max . Note You can use objective! only once to define the objective. The state, control and variable dimensions must be set before. Use state!, control! and variable!. The times must be set before. Use time!. When an element is of dimension 1, consider it as a scalar. Examples julia> objective!(ocp, :mayer, (x0, xf) -> x0[1] + xf[2])\njulia> objective!(ocp, :lagrange, (x, u) -> x[1]^2 + u^2) # the control is of dimension 1 Warning If you set twice the objective, only the last one will be taken into account."},{"id":993,"pagetitle":"CTBase API","title":"CTBase.remove_constraint!","ref":"/ctproblems/stable/#CTBase.remove_constraint!-Tuple{OptimalControlModel, Symbol}","content":" CTBase.remove_constraint!  —  Method remove_constraint!(ocp::OptimalControlModel, label::Symbol)\n Remove a labeled constraint. Example julia> remove_constraint!(ocp, :con)"},{"id":994,"pagetitle":"CTBase API","title":"CTBase.replace_call","ref":"/ctproblems/stable/#CTBase.replace_call-Tuple{Any, Symbol, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Symbol, t, y) -> Any\n Replace calls in e of the form  (...x...)(t)  by  (...y...) . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( x[1](0) * 2x(tf) - x[2](tf) * 2x(0) )\n:((x[1])(0) * (2 * x(tf)) - (x[2])(tf) * (2 * x(0)))\n\njulia> x0 = Symbol(x, 0); e = replace_call(e, x, t0, x0)\n:(x0[1] * (2 * x(tf)) - (x[2])(tf) * (2x0))\n\njulia> xf = Symbol(x, \"f\"); replace_call(ans, x, tf, xf)\n:(x0[1] * (2xf) - xf[2] * (2x0))\n\njulia> e = :( A*x(t) + B*u(t) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(A * x + B * u)\n\njulia> e = :( F0(x(t)) + u(t)*F1(x(t)) ); replace_call(replace_call(e, x, t, x), u, t, u)\n:(F0(x) + u * F1(x))\n\njulia> e = :( 0.5u(t)^2 ); replace_call(e, u, t, u)\n:(0.5 * u ^ 2)"},{"id":995,"pagetitle":"CTBase API","title":"CTBase.replace_call","ref":"/ctproblems/stable/#CTBase.replace_call-Tuple{Any, Vector{Symbol}, Any, Any}","content":" CTBase.replace_call  —  Method replace_call(e, x::Vector{Symbol}, t, y) -> Any\n Replace calls in e of the form  (...x1...x2...)(t)  by  (...y1...y2...)  for all symbols  x1 ,  x2 ... in the vector  x . Example \njulia> t = :t; t0 = 0; tf = :tf; x = :x; u = :u;\n\njulia> e = :( (x^2 + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:(xx ^ 2 + uu[1])\n\njulia> e = :( ((x^2)(t0) + u[1])(t) ); replace_call(e, [ x, u ], t , [ :xx, :uu ])\n:((xx ^ 2)(t0) + uu[1])"},{"id":996,"pagetitle":"CTBase API","title":"CTBase.state!","ref":"/ctproblems/stable/#CTBase.state!","content":" CTBase.state!  —  Function state!(ocp::OptimalControlModel, n::Integer)\nstate!(ocp::OptimalControlModel, n::Integer, name::String)\nstate!(\n    ocp::OptimalControlModel,\n    n::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the state dimension and possibly the names of each component. Note You must use state! only once to set the state dimension. Examples julia> state!(ocp, 1)\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"x\"]\n\njulia> state!(ocp, 1, \"y\")\njulia> ocp.state_dimension\n1\njulia> ocp.state_components_names\n[\"y\"]\n\njulia> state!(ocp, 2)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"x₁\", \"x₂\"]\n\njulia> state!(ocp, 2, :y)\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]\n\njulia> state!(ocp, 2, \"y\")\njulia> ocp.state_dimension\n2\njulia> ocp.state_components_names\n[\"y₁\", \"y₂\"]"},{"id":997,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctproblems/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(ocp::OptimalControlModel, t0::Real, tf::Real)\ntime!(\n    ocp::OptimalControlModel,\n    t0::Real,\n    tf::Real,\n    name::String\n)\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, 0, 1)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, 0, 1, \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, 0, 1, :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\""},{"id":998,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctproblems/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real}\n) -> Any\ntime!(\n    ocp::OptimalControlModel,\n    times::AbstractVector{<:Real},\n    name::String\n) -> Any\n Fix initial and final times to  times[1]  and  times[2] , respectively. Examples julia> time!(ocp, [ 0, 1 ])\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"t\"\n\njulia> time!(ocp, [ 0, 1 ], \"s\")\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\"\n\njulia> time!(ocp, [ 0, 1 ], :s)\njulia> ocp.initial_time\n0\njulia> ocp.final_time\n1\njulia> ocp.time_name\n\"s\""},{"id":999,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctproblems/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    t0::Real,\n    indf::Index,\n    name::String\n)\n Fix initial time, final time is free and given by the variable at the provided index. Note You must use time! only once to set either the initial or the final time, or both. Examples julia> time!(ocp, 0, Index(2), \"t\")"},{"id":1000,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctproblems/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    tf::Real,\n    name::String\n)\n Fix final time, initial time is free and given by the variable at the provided index. Examples julia> time!(ocp, Index(2), 1, \"t\")"},{"id":1001,"pagetitle":"CTBase API","title":"CTBase.time!","ref":"/ctproblems/stable/#CTBase.time!","content":" CTBase.time!  —  Function time!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index\n)\ntime!(\n    ocp::OptimalControlModel{<:TimeDependence, NonFixed},\n    ind0::Index,\n    indf::Index,\n    name::String\n)\n Initial and final times are free and given by the variable at the provided indices. Examples julia> time!(ocp, Index(2), Index(3), \"t\")"},{"id":1002,"pagetitle":"CTBase API","title":"CTBase.variable!","ref":"/ctproblems/stable/#CTBase.variable!","content":" CTBase.variable!  —  Function variable!(ocp::OptimalControlModel, q::Integer)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String\n)\nvariable!(\n    ocp::OptimalControlModel,\n    q::Integer,\n    name::String,\n    components_names::Vector{String}\n)\n Define the variable dimension and possibly the names of each component. Note You can use variable! once to set the variable dimension when the model is  NonFixed . Examples julia> variable!(ocp, 1, \"v\")\njulia> variable!(ocp, 2, \"v\", [ \"v₁\", \"v₂\" ])"},{"id":1003,"pagetitle":"CTBase API","title":"CTBase.∂ₜ","ref":"/ctproblems/stable/#CTBase.∂ₜ-Tuple{Any}","content":" CTBase.∂ₜ  —  Method ∂ₜ(f) -> CTBase.var\"#114#116\"\n Partial derivative wrt time of a function. Example julia> ∂ₜ((t,x) -> t*x)(0,8)\n8"},{"id":1004,"pagetitle":"CTBase API","title":"RecipesBase.plot!","ref":"/ctproblems/stable/#RecipesBase.plot!-Tuple{Plots.Plot, OptimalControlSolution}","content":" RecipesBase.plot!  —  Method plot!(\n    p::Plots.Plot,\n    sol::OptimalControlSolution;\n    layout,\n    control,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Plots.Plot\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate."},{"id":1005,"pagetitle":"CTBase API","title":"RecipesBase.plot","ref":"/ctproblems/stable/#RecipesBase.plot-Tuple{OptimalControlSolution}","content":" RecipesBase.plot  —  Method plot(\n    sol::OptimalControlSolution;\n    layout,\n    state_style,\n    control_style,\n    costate_style,\n    kwargs...\n) -> Any\n Plot the optimal control solution  sol  using the layout  layout . Notes. The argument  layout  can be  :group  or  :split  (default). The keyword arguments  state_style ,  control_style  and  costate_style  are passed to the  plot  function of the  Plots  package. The  state_style  is passed to the plot of the state, the  control_style  is passed to the plot of the control and the  costate_style  is passed to the plot of the costate."},{"id":1006,"pagetitle":"CTBase API","title":"CTBase.@Lie","ref":"/ctproblems/stable/#CTBase.@Lie-Tuple{Expr}","content":" CTBase.@Lie  —  Macro Macros for Lie and Poisson brackets Example julia> F0 = VectorField(x -> [x[1], x[2], (1-x[3])])\njulia> F1 = VectorField(x -> [0, -x[3], x[2]])\njulia> @Lie [F0, F1]([1, 2, 3])\n[0, 5, 4]\njulia> H0 = Hamiltonian((x, p) -> 0.5*(2x[1]^2+x[2]^2+p[1]^2))\njulia> H1 = Hamiltonian((x, p) -> 0.5*(3x[1]^2+x[2]^2+p[2]^2))\njulia> @Lie {H0, H1}([1, 2, 3], [1,0,7])\n3.0"},{"id":1007,"pagetitle":"CTBase API","title":"CTBase.@def","ref":"/ctproblems/stable/#CTBase.@def","content":" CTBase.@def  —  Macro Define an optimal control problem. One pass parsing of the definition. Example @def ocp begin\n    tf ∈ R, variable\n    t ∈ [ 0, tf ], time\n    x ∈ R², state\n    u ∈ R, control\n    tf ≥ 0\n    -1 ≤ u(t) ≤ 1\n    q = x₁\n    v = x₂\n    q(0) == 1\n    v(0) == 2\n    q(tf) == 0\n    v(tf) == 0\n    0 ≤ q(t) ≤ 5,       (1)\n    -2 ≤ v(t) ≤ 3,      (2)\n    ẋ(t) == [ v(t), u(t) ]\n    tf → min\nend"},{"id":1010,"pagetitle":"List of descriptions","title":"List of descriptions","ref":"/ctproblems/stable/#descriptions-list","content":" List of descriptions To print the complete list of problems descriptions: using CTProblems\nProblemsDescriptions() (:integrator, :consumption, :x_dim_2, :u_dim_1, :lagrange, :u_cons, :non_diff_wrt_u)\n(:integrator, :energy, :x_dim_2, :u_dim_1, :lagrange, :u_cons)\n(:integrator, :energy, :distance, :x_dim_2, :u_dim_1, :bolza)\n(:integrator, :energy, :x_dim_2, :u_dim_1, :lagrange, :x_cons, :order_2)\n(:integrator, :energy, :x_dim_2, :u_dim_1, :lagrange, :noconstraints)\n(:integrator, :time, :x_dim_2, :u_dim_1, :mayer, :u_cons)\n(:goddard, :classical, :altitude, :x_dim_3, :u_dim_1, :mayer, :x_cons, :u_cons, :singular_arc)\n(:lqr, :x_dim_2, :u_dim_1, :lagrange)\n(:orbital_transfert, :consumption, :x_dim_4, :u_dim_2, :lagrange, :u_cons, :non_diff_wrt_u)\n(:orbital_transfert, :energy, :x_dim_4, :u_dim_2, :lagrange)\n(:orbital_transfert, :time, :x_dim_4, :u_dim_2, :mayer, :u_cons)\n(:exponential, :consumption, :x_dim_1, :u_dim_1, :lagrange, :non_diff_wrt_u)\n(:exponential, :energy, :x_dim_1, :u_dim_1, :lagrange)\n(:exponential, :time, :x_dim_1, :u_dim_1, :lagrange)\n(:integrator, :energy, :free_final_time, :x_dim_1, :u_dim_1, :lagrange)\n(:integrator, :lqr, :free_final_time, :x_dim_1, :u_dim_1, :bolza)\n(:integrator, :x_dim_1, :u_dim_1, :lagrange, :mixed_constraint)\n(:turnpike, :integrator, :state_energy, :x_dim_1, :u_dim_1, :lagrange, :u_cons, :singular_arc)\n(:integrator, :state_dime_1, :lagrange, :x_cons, :u_cons, :nonautonomous)\n You can use more sophisticated rules to filter. You simply have to define a logical condition with the combination of symbols and the three operators:  ! ,  |  and  & , respectively for the negation, the disjunction and the conjunction. Here is an example to get the problems descriptions which does not contain  :lagrange , or contains  :time  (the  or  is not exclusive): @ProblemsDescriptions !:lagrange | :time (:integrator, :energy, :distance, :x_dim_2, :u_dim_1, :bolza)\n(:integrator, :time, :x_dim_2, :u_dim_1, :mayer, :u_cons)\n(:goddard, :classical, :altitude, :x_dim_3, :u_dim_1, :mayer, :x_cons, :u_cons, :singular_arc)\n(:orbital_transfert, :time, :x_dim_4, :u_dim_2, :mayer, :u_cons)\n(:exponential, :time, :x_dim_1, :u_dim_1, :lagrange)\n(:integrator, :lqr, :free_final_time, :x_dim_1, :u_dim_1, :bolza)\n"},{"id":1013,"pagetitle":"How to add a new problem","title":"How to add a new problem","ref":"/ctproblems/stable/#add-new-pb","content":" How to add a new problem How to add a new problem Find a description Create a new file with an empty template Code the model and the solution Add a unit test"},{"id":1014,"pagetitle":"How to add a new problem","title":"Find a description","ref":"/ctproblems/stable/#Find-a-description","content":" Find a description Let us assume you want to add a  planar orbital time minimisation  transfer problem from space mechanics.  This problem will be described by a  Description , cf.  CTBase.jl , following the  nomenclature  given in  src/CTProblems.jl . For instance: (:orbital, :time, :x_dim_4, u_dim_2, :mayer) Nomenclature: :name_of_the_problem , and other symbols for a clear description if the objective is classical, you can mention it:  :time ,  :energy ,  :consumption then dimensions:  :x_dim_1 ,  :x_dim_2 ...  :u_dim_1 ,  :u_dim_2 ... objective type:  :lagrange ,  :mayer ,  :bolza constraint arc (active on the solution):  :x_cons ,  :u_cons ,  :mixed_constraint singular arc (on the solution):  :singular_arc differentiability:  :non_diff_wrt_x ,  :non_diff_wrt_u"},{"id":1015,"pagetitle":"How to add a new problem","title":"Create a new file with an empty template","ref":"/ctproblems/stable/#Create-a-new-file-with-an-empty-template","content":" Create a new file with an empty template You have to create a new file in the directory  src/problems . For instance: touch src/problems/orbital_planar.jl Add it to the list of problems, in  src/CTProblems.jl : list_of_problems_files = [\n    \"...\",\n    \"orbital_planar.jl\",\n] Then, you can write into this file the following empty template. Warning It is required to define a variable named  EXAMPLE  containing the description. EXAMPLE=(:orbital, :time, :x_dim_4, u_dim_2, :mayer)\n\n@eval function OCPDef{EXAMPLE}()\n\n    # the description\n    title = \"Planar orbital transfer\"\n\n    # the model: to be completed\n    ocp = Model()\n\n    # the solution: to be completed\n    sol = OptimalControlSolution()\n\n    sol.message = \"structure: ...\"  # Give the structure as an additional info. \n                                    # For instance, B+S for positive bang followed\n                                    # a by singular arc.\n                                    \n    sol.infos[:resolution] = :numerical # Either :numerical or :analytical\n                                        # depending on how you get the solution\n\n    #\n    return OptimalControlProblem(title, ocp, sol)\n\nend"},{"id":1016,"pagetitle":"How to add a new problem","title":"Code the model and the solution","ref":"/ctproblems/stable/#Code-the-model-and-the-solution","content":" Code the model and the solution For now, you have to complete the model and the solution. You can take example from the already existing problems in  src/problems . See also the documentation of  CTBase.jl . Try to fulfill all the fields of  OptimalControlSolution ."},{"id":1017,"pagetitle":"How to add a new problem","title":"Add a unit test","ref":"/ctproblems/stable/#Add-a-unit-test","content":" Add a unit test To complete the process, a unit test must be created. See the  test  directory for examples. The unit test should be written by a different person to robustify the process."},{"id":1020,"pagetitle":"Private functions","title":"Private functions","ref":"/ctproblems/stable/#Private-functions","content":" Private functions"},{"id":1021,"pagetitle":"Private functions","title":"CTProblems.AbstractCTProblem","ref":"/ctproblems/stable/#CTProblems.AbstractCTProblem","content":" CTProblems.AbstractCTProblem  —  Type abstract type AbstractCTProblem source"},{"id":1022,"pagetitle":"Private functions","title":"CTProblems.CTProblemsException","ref":"/ctproblems/stable/#CTProblems.CTProblemsException","content":" CTProblems.CTProblemsException  —  Type abstract type CTProblemsException <: Exception source"},{"id":1023,"pagetitle":"Private functions","title":"CTProblems.NonExistingProblem","ref":"/ctproblems/stable/#CTProblems.NonExistingProblem","content":" CTProblems.NonExistingProblem  —  Type struct NonExistingProblem <: CTProblems.CTProblemsException Fields example::Tuple{Vararg{Symbol}} source"},{"id":1024,"pagetitle":"Private functions","title":"CTProblems.OCPDef","ref":"/ctproblems/stable/#CTProblems.OCPDef","content":" CTProblems.OCPDef  —  Type struct OCPDef{description} A type used to define new problems with a default constructor that throws a  NonExistingProblem  exception if there is no optimal control problem described by  example . Example julia> CTProblems.OCPDef{(:ocp, :dummy)}()\nERROR: there is no optimal control problem described by (:ocp, :dummy) source"},{"id":1025,"pagetitle":"Private functions","title":"CTProblems.OptimalControlProblem","ref":"/ctproblems/stable/#CTProblems.OptimalControlProblem","content":" CTProblems.OptimalControlProblem  —  Type struct OptimalControlProblem <: CTProblems.AbstractCTProblem Fields title::String model::OptimalControlModel solution::OptimalControlSolution Example julia> using CTProblems\njulia> using CTBase\njulia> title = \"My empty optimal control problem\"\njulia> ocp = Model()\njulia> sol = OptimalControlSolution()\njulia> prob = CTProblems.OptimalControlProblem(title, ocp, sol)\njulia> prob isa CTProblems.AbstractCTProblem\ntrue\njulia> prob isa CTProblems.OptimalControlProblem\ntrue source"},{"id":1026,"pagetitle":"Private functions","title":"Base.show","ref":"/ctproblems/stable/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, CTProblems.OptimalControlProblem}","content":" Base.show  —  Method show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    problem::CTProblems.OptimalControlProblem\n)\n Show the title and the types of the model and the solution of the optimal control problem. julia> Problem(:integrator, :energy, :x_dim_2, :u_dim_1)\ntitle           = Double integrator - energy min\nmodel    (Type) = CTBase.OptimalControlModel{:autonomous, :scalar}\nsolution (Type) = CTBase.OptimalControlSolution source"},{"id":1027,"pagetitle":"Private functions","title":"Base.show","ref":"/ctproblems/stable/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{Vararg{CTProblems.OptimalControlProblem}}}","content":" Base.show  —  Method show(\n    io::IO,\n    _::MIME{Symbol(\"text/plain\")},\n    problems::Tuple{Vararg{CTProblems.OptimalControlProblem}}\n)\n Print a tuple of optimal control problems. source"},{"id":1028,"pagetitle":"Private functions","title":"Base.show","ref":"/ctproblems/stable/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Tuple{}}","content":" Base.show  —  Method show(io::IO, _::MIME{Symbol(\"text/plain\")}, t::Tuple{})\n Print an empty tuple. source"},{"id":1029,"pagetitle":"Private functions","title":"Base.showerror","ref":"/ctproblems/stable/#Base.showerror-Tuple{IO, CTProblems.NonExistingProblem}","content":" Base.showerror  —  Method showerror(io::IO, e::CTProblems.NonExistingProblem)\n Print the error message when the optimal control problem described by  e.example  does not exist.  source"},{"id":1030,"pagetitle":"Private functions","title":"CTProblems._keep","ref":"/ctproblems/stable/#CTProblems._keep-Tuple{Tuple{Vararg{Symbol}}, Expr}","content":" CTProblems._keep  —  Method _keep(\n    description::Tuple{Vararg{Symbol}},\n    e::Expr\n) -> Union{Missing, Nothing, Bool}\n Return if  description  is consistent with the expression  e . source"},{"id":1031,"pagetitle":"Private functions","title":"CTProblems._keep","ref":"/ctproblems/stable/#CTProblems._keep-Tuple{Tuple{Vararg{Symbol}}, QuoteNode}","content":" CTProblems._keep  —  Method _keep(\n    description::Tuple{Vararg{Symbol}},\n    e::QuoteNode\n) -> Union{Missing, Bool}\n If  e.value  is a Symbol, then return  e.value ∈ description . source"},{"id":1032,"pagetitle":"Private functions","title":"CTProblems._keep","ref":"/ctproblems/stable/#CTProblems._keep-Tuple{Tuple{Vararg{Symbol}}, Symbol, Expr}","content":" CTProblems._keep  —  Method _keep(\n    description::Tuple{Vararg{Symbol}},\n    s::Symbol,\n    e::Expr\n) -> Union{Missing, Bool}\n If s is the Symbol \"!\", then return  !_keep(description, e) . source"},{"id":1033,"pagetitle":"Private functions","title":"CTProblems._keep","ref":"/ctproblems/stable/#CTProblems._keep-Tuple{Tuple{Vararg{Symbol}}, Symbol, QuoteNode}","content":" CTProblems._keep  —  Method _keep(\n    description::Tuple{Vararg{Symbol}},\n    s::Symbol,\n    e::QuoteNode\n) -> Union{Missing, Bool}\n If  e.value  is a Symbol and if s is the Symbol \"!\", then return  e.value ∉ description . source"},{"id":1034,"pagetitle":"Private functions","title":"CTProblems._problems_without_dummy","ref":"/ctproblems/stable/#CTProblems._problems_without_dummy-Tuple{}","content":" CTProblems._problems_without_dummy  —  Method _problems_without_dummy() -> Tuple\n Return the list of optimal control problems (without the dummy problem). source"},{"id":1037,"pagetitle":"Introduction","title":"CTProblems.jl","ref":"/ctproblems/stable/#introduction","content":" CTProblems.jl The  CTProblems.jl  package is part of the  control-toolbox ecosystem . Install To install a package from the control-toolbox ecosystem,  please visit the  installation page . This package provides a  list of optimal control problems . Each problem is composed of a short title, a model and the solution. You can get access to any problem by a simple  Description , that is a tuple of (Julia) symbols. For instance, to get the energy minimisation exponential problem, simply using CTProblems\nprob = Problem(:exponential, :energy) title           = simple exponential - energy min\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Note In the example above, we have given a partial description to the function  Problem .  The complete description of this problem is (:exponential, :energy, :x_dim_1, :u_dim_1, :lagrange) Warning If you give a partial description, then, if several complete descriptions contains the partial one, then, only the problem with the highest priority is returned. The higher in the list, the higher is the priority. See the  list of descriptions  to check the priorities. Once you have selected a problem, you can get access to its title: prob.title \"simple exponential - energy min\" Its model is given by prob.model t ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\nẋ(t) == -(x(t)) + u(t)\n∫(0.5 * u(t) ^ 2) → min\n And you can plot the solution. plot(prob.solution, size=(700, 500))"},{"id":1040,"pagetitle":"List of problems","title":"List of problems","ref":"/ctproblems/stable/#problems-list","content":" List of problems List of problems Characteristics of the problems Get some problems for tests"},{"id":1041,"pagetitle":"List of problems","title":"Characteristics of the problems","ref":"/ctproblems/stable/#Characteristics-of-the-problems","content":" Characteristics of the problems In the following table, we give some characteristics about the problems and their solutions. Problem (x, u) dims Objective Constraint arc Singular arc Differentiable Time dependence Double integrator consumption (2, 1) Lagrange ✅ u ❌ ❌ u autonomous Double integrator energy (2, 1) Lagrange ❌ ❌ ✅ autonomous Double integrator energy cc (2, 1) Lagrange ✅ u ❌ ✅ autonomous Double integrator energy distance (2, 1) Bolza ❌ ❌ ✅ autonomous Double integrator energy sc (2, 1) Lagrange ✅ x ❌ ✅ autonomous Double integrator time (2, 1) Mayer ✅ u ❌ ✅ autonomous Goddard (3, 1) Mayer ✅ x, u ✅ ✅ autonomous LQR (2, 1) Lagrange ❌ ❌ ✅ autonomous Orbital transfert consumption (4, 2) Lagrange ✅ u ❌ ❌ u autonomous Orbital transfert energy (4, 2) Lagrange ❌ ❌ ✅ autonomous Orbital transfert time (4, 2) Mayer ✅ u ❌ ✅ autonomous Simple exponential consumption (1, 1) Lagrange ✅ u ❌ ❌ u autonomous Simple exponential energy (1, 1) Lagrange ❌ ❌ ✅ autonomous Simple exponential time (1, 1) Mayer ✅ u ❌ ✅ autonomous Simple integrator energy (1, 1) Lagrange ❌ ❌ ✅ autonomous Simple integrator lqr (1, 1) Bolza ❌ ❌ ✅ autonomous Simple integrator mixed constraint (1, 1) Lagrange ✅ (x,u) ❌ ✅ autonomous Simple integrator turnpike (1, 1) Lagrange ✅ u ✅ ✅ autonomous Simple integrator non autonomous (1, 1) Lagrange ✅ x ❌ ✅ non autonomous Legend: Problem : a name with a link to the problem page (x, u) dims : dimension of the state and the control Objective : Lagrange, Mayer or Bolza Constraint arc  (active on the solution): ❌ (no) ✅ x(pure state constraints) ✅ u (pure control constraints) ✅ (x,u) (mixed state/control constraints) Singular arc : in the case of affine problems, we tell if the solution has a singular arc, that is a non-empty arc along which the switching function vanishes. ❌ (no) ✅ (yes) Differentiable : ✅ (yes) ❌ x (the dynamics and/or other data from the model is non differentiable wrt to the state) ❌ u (the dynamics and/or other data from the model is non differentiable wrt to the control) Time dependence : autonomous or non autonomous"},{"id":1042,"pagetitle":"List of problems","title":"Get some problems for tests","ref":"/ctproblems/stable/#Get-some-problems-for-tests","content":" Get some problems for tests To get all the problems as a  Tuple  of  OptimalControlProblem , simply Problems() To get all the problems with one dimensional state and Lagrange cost: Problems(:x_dim_1, :lagrange) You can use more sophisticated rules to filter. You simply have to define a logical condition with the combination of symbols and the three operators:  ! ,  |  and  & , respectively for the negation, the disjunction and the conjunction. Here is an example to get the problems, as a  Tuple  of  OptimalControlProblem , whom description does not contain  :lagrange , or contains  :time  (the  or  is not exclusive): @Problems !:lagrange | :time"},{"id":1047,"pagetitle":"Double integrator: consumption minimisation","title":"Double integrator: consumption minimisation","ref":"/ctproblems/stable/problems/#DIC","content":" Double integrator: consumption minimisation The consumption minimisation double integrator problem consists in minimising \\[    \\int_{0}^{1} |u(t)| \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t), \\quad u(t) \\in [-5,5]\\] and the limit conditions \\[    x(0) = (-1,0), \\quad x(1) = (0,0).\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :consumption, :x_dim_2, :u_dim_1, :lagrange, :u_cons, :non_diff_wrt_u) title           = Double integrator consumption - mininimise ∫ |u| under the constraint |u| ≤ γ\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R², state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\n-γ ≤ u(t) ≤ γ, u_con\nẋ(t) == A * x(t) + B * u(t)\n∫abs(u(t)) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1050,"pagetitle":"Double integrator: energy minimisation","title":"Double integrator: energy minimisation","ref":"/ctproblems/stable/problems/#DIE","content":" Double integrator: energy minimisation The energy minimisation problem consists in minimising the cost functional in Lagrange form \\[    \\frac{1}{2}\\int_{t_0}^{t_f} u^2(t) \\, \\mathrm{d}t\\] subject to the constraints for  $t \\in [t_0, t_f]$  a.e. \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t) \\in \\mathbb{R},\\] and the limit conditions \\[    x(t_0) = (a, b), \\quad x(t_f) = x_f,\\] with  $a$ ,  $b \\in \\mathbb{R}$ ,  $x_f \\in \\mathbb{R}^2$  and  $t_f \\ge t_0 = 0$  fixed. Denoting  $H(x, p, u) \\coloneqq p_1 x_2 + p_2 u - u^2/2$  the pseudo-Hamiltonian (in the normal case), then, by the  Pontryagin Maximum Principle , the maximising control is given in feedback form by \\[    u(x, p) \\coloneqq p_2.\\] Thus, solving this optimal control problem leads to solve the following boundary value problem: \\[    \\left\\{\n    \\begin{aligned}\n        & \\dot{x}_1(t) = x_2(t), \\quad \n        \\dot{x}_2(t) = u(x(t), p(t)), \\quad \n        \\dot{p}_1(t) = 0, \\quad \n        \\dot{p}_2(t) = -p_1(t), \\\\\n        & x(0) = (a, b), \\quad x(t_f) = x_f.\n    \\end{aligned}\n    \\right.\\] where  $p(t) = (p_1(t), p_2(t))$  is the costate vector. Integrating first the differential system, we get \\[    \\left\\{\n    \\begin{aligned}\n        p_1(t) &= \\alpha, \\\\[0.3em]\n        p_2(t) &= -\\alpha t + \\beta, \\\\[0.3em]\n        x_2(t) &= b + \\int_0^t (-\\alpha s + \\beta) \\mathrm{d} s = \n        b + \\beta t - \\frac{\\alpha}{2} t^2, \\\\[0.3em]\n        x_1(t) &= a + b t + \\frac{\\beta}{2} t^2 - \\frac{\\alpha}{6} t^3,\n    \\end{aligned}\n    \\right.    \\] with  $p(0) = (\\alpha, \\beta)$  the parameters to identify. Solving the boundary value problem, that is finding  $(\\alpha, \\beta)$ , is then equivalent to solve the shooting equation \\[    S(\\alpha, \\beta) \\coloneqq\n    \\begin{pmatrix}\n        \\displaystyle a + b\\, t_f + \\frac{\\beta}{2} t_f^2 - \\frac{\\alpha}{6} t_f^3 \\\\[0.5em]\n        \\displaystyle b + \\beta\\, t_f - \\frac{\\alpha}{2} t_f^2\n    \\end{pmatrix}\n    - x_f = A\\, p_0 - B = 0,\\] where we set \\[    A \\coloneqq \n    \\begin{pmatrix}\n    -\\frac{t_f^3}{6} & \\frac{t_f^2}{2} \\\\[0.5em]\n     -\\frac{t_f^2}{2} & t_f\n    \\end{pmatrix},\n    \\quad\n    B \\coloneqq ( -a-b t_f, -b) + x_f\n    \\quad\n    \\text{and}\n    \\quad \n    p_0 \\coloneqq (\\alpha, \\beta).\\] Note that the  shooting function $S$  is linear. If  $t_f \\ne 0$ , then,  $A$  is invertible since  $\\det A = t_f^4/12$  and the solution is then given by \\[    p^*_0 = A^{-1} B.\\] For an illusration we set  $t_f=1$ ,  $x_0 = (-1, 0)$  and  $x_f = (0, 0)$ , see the following figure. The red sphere represents the solution. You can access the problem from the  CTProblems.jl  package: using CTProblems\nprob = Problem(:integrator, :energy, :x_dim_2, :u_dim_1, :lagrange, :noconstraints) title           = Double integrator energy - minimise ∫ u²\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R², state\nu ∈ R, control\nx(t0) == [-1, 0], initial_con\nx(tf) == [0, 0], final_con\nẋ(t) == A * x(t) + B * u(t)\n∫(0.5 * u(t) ^ 2) → min\n You can plot the solution. plot(prob.solution, size=(700, 700))"},{"id":1053,"pagetitle":"Double integrator: energy minimisation control constraint","title":"Double integrator: energy minimisation control constraint","ref":"/ctproblems/stable/problems/#DIECC","content":" Double integrator: energy minimisation control constraint The energy minimisation with control constraint double integrator problem consists in minimising \\[    0.5\\int_{0}^{1} {u(t)}^2 \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t), \\quad u(t) \\in [-5,5]\\] and the limit conditions \\[    x(0) = (-1,0), \\quad x(1) = (0,0).\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :energy, :x_dim_2, :u_dim_1, :lagrange, :u_cons) title           = Double integrator energy - mininimise ∫ u² under the constraint |u| ≤ γ\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R², state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\n-γ ≤ u(t) ≤ γ, u_con\nẋ(t) == A * x(t) + B * u(t)\n∫(0.5 * u(t) ^ 2) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1056,"pagetitle":"Double integrator: energy and distance minimisation","title":"Double integrator: energy and distance minimisation","ref":"/ctproblems/stable/problems/#DIED","content":" Double integrator: energy and distance minimisation The energy and distance minimisation double integrator problem consists in minimising \\[    -0.5*x_1(t_f) + 0.5*\\int_{0}^{1} {u(t)}^2 \\, \\mathrm{d}t \\] subject to the constraints \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t), \\quad u(t) \\in \\R\\] and the limit conditions \\[    x(0) = (0,0)\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :energy, :distance, :x_dim_2, :u_dim_1, :bolza) title           = Double integrator energy/distance - minimise -x₁ + ∫ u²\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R², state\nu ∈ R, control\nx(t0) == x0, initial_con\nẋ(t) == A * x(t) + B * u(t)\n-0.5 * x₁(tf) + ∫(0.5 * u(t) ^ 2) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1059,"pagetitle":"Double integrator: energy minimisation state constraint","title":"Double integrator: energy minimisation state constraint","ref":"/ctproblems/stable/problems/#DIESC","content":" Double integrator: energy minimisation state constraint The energy minimisation with control constraint double integrator problem consists in minimising \\[    0.5\\int_{0}^{1} {u(t)}^2 \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t), \\quad u(t) \\in \\R \\\\\n    x_1(t) \\leq l\\] and the limit conditions \\[    x(0) = (0,1), \\quad x(1) = (0,-1).\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :energy, :x_dim_2, :u_dim_1, :lagrange, :x_cons, :order_2) title           = Double integrator energy - mininimise ∫ u² under the constraint x₁ ≤ l\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R², state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\n-Inf ≤ x₁(t) ≤ l, x_con\nẋ(t) == A * x(t) + B * u(t)\n∫(0.5 * u(t) ^ 2) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1062,"pagetitle":"Double integrator: time minimisation","title":"Double integrator: time minimisation","ref":"/ctproblems/stable/problems/#DIT","content":" Double integrator: time minimisation The time minimisation double integrator problem consists in minimising \\[    tf \\] subject to the constraints \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = u(t), \\quad u(t) \\in [-1,1]\\] and the limit conditions \\[    x(0) = (-1,0), \\quad x(t_f) = (0,0)\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :time, :x_dim_2, :u_dim_1, :mayer, :u_cons) title           = Double integrator time - minimise tf under the constraint |u| ≤ γ\nmodel    (Type) = OptimalControlModel{Autonomous, NonFixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model tf ∈ R, variable\nt ∈ [t0, tf], time\nx ∈ R², state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\n-γ ≤ u(t) ≤ γ, u_con\nẋ(t) == A * x(t) + B * u(t)\ntf → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1065,"pagetitle":"Goddard with state constraints","title":"Goddard with state constraints","ref":"/ctproblems/stable/problems/#Godda","content":" Goddard with state constraints This well-known problem [1] [2]  models the ascent of a rocket through the atmosphere, and we restrict here ourselves to vertical (one dimensional) trajectories. The state variables are the altitude  $r$ , speed  $v$  and mass  $m$  of the rocket during the flight, for a total dimension of 3.  The rocket is subject to gravity  $g$ , thrust  $u$  and drag force  $D$  (function of speed and altitude). The final time  $T$  is free, and the objective is to reach a maximal altitude with a bounded fuel consumption. We thus want to solve the optimal control problem in Mayer form \\[    \\max\\, r(T)\\] subject to the control dynamics \\[    \\dot{r} = v, \\quad\n    \\dot{v} = \\frac{T_{\\max}\\,u - D(r,v)}{m} - g, \\quad\n    \\dot{m} = -u,\\] and subject to the control constraint  $u(t) \\in [0,1]$  and the state constraint  $v(t) \\leq v_{\\max}$ . The initial state is fixed while only the final mass is prescribed. Note The Hamiltonian is affine with respect to the control, so singular arcs may occur, as well as constrained arcs due to the path constraint on the velocity (see below)."},{"id":1066,"pagetitle":"Goddard with state constraints","title":"Model and solution","ref":"/ctproblems/stable/problems/#Model-and-solution","content":" Model and solution using CTProblems You can access the problem in the CTProblems package: prob = Problem(:goddard) title           = Goddard problem with state constraint - maximise altitude\nmodel    (Type) = OptimalControlModel{Autonomous, NonFixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model Cd = 310\nTmax = 3.5\nβ = 500\nb = 2\nt0 = 0\nr0 = 1\nv0 = 0\nvmax = 0.1\nm0 = 1\nmf = 0.6\nx0 = [r0, v0, m0]\ntf ∈ R, variable\nt ∈ [t0, tf], time\nx ∈ R³, state\nu ∈ R, control\nr = x₁\nv = x₂\nm = x₃\n0 ≤ u(t) ≤ 1, u_con\nr(t) ≥ r0, x_con_rmin\n0 ≤ v(t) ≤ vmax, x_con_vmax\nx(t0) == x0, initial_con\nm(tf) == mf, final_con\nẋ(t) == F0(x(t)) + u(t) * F1(x(t))\nr(tf) → max\n with  function F0(x)\n    r, v, m = x\n    D = Cd * v^2 * exp(-β*(r - 1))\n    return [ v, -D/m - 1/r^2, 0 ]\nend\nfunction F1(x)\n    r, v, m = x\n    return [ 0, Tmax/m, -b*Tmax ]\nend You can plot the solution. plot(prob.solution, size=(700, 700)) The solution is given by: # initial costate\nprintln(\"p0 = \", prob.solution.infos[:initial_costate])\n\n# switching times\nprintln(\"t1 = \", prob.solution.infos[:switching_times][1])\nprintln(\"t2 = \", prob.solution.infos[:switching_times][2])\nprintln(\"t3 = \", prob.solution.infos[:switching_times][3])\n\n# final time\nprintln(\"T  = \", prob.solution.infos[:final_time]) p0 = [3.945764658668555, 0.15039559623198723, 0.053712712939991955]\nt1 = 0.023509684041475312\nt2 = 0.059737380900899015\nt3 = 0.10157134842460895\nT  = 0.20204744057146434"},{"id":1067,"pagetitle":"Goddard with state constraints","title":"References","ref":"/ctproblems/stable/problems/#References","content":" References 1 R.H. Goddard. A Method of Reaching Extreme Altitudes, volume 71(2) of Smithsonian Miscellaneous Collections. Smithsonian institution, City of Washington, 1919. 2 H. Seywald and E.M. Cliff. Goddard problem in presence of a dynamic pressure limit. Journal of Guidance, Control, and Dynamics, 16(4):776–781, 1993."},{"id":1070,"pagetitle":"LQR: energy and distance minimisation","title":"LQR: energy and distance minimisation","ref":"/ctproblems/stable/problems/#LQR","content":" LQR: energy and distance minimisation The energy and distance minimisation LQR problem consists in minimising \\[    0.5*\\int_{0}^{5} x_1(t)^2 + x_2(t)^2 + u(t)^2 \\, \\mathrm{d}t \\] subject to the constraints \\[    \\dot x_1(t) = x_2(t), \\quad \\dot x_2(t) = -x_1(t) + u(t), \\quad u(t) \\in \\R\\] and the limit conditions \\[    x(0) = (0,1)\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:lqr, :x_dim_2, :u_dim_1, :lagrange) title           = lqr - dimension 2 - ricatti\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R², state\nu ∈ R, control\nx(t0) == x0, initial_con\nẋ(t) == A * x(t) + B * u(t)\n∫(0.5 * (x₁(t) ^ 2 + x₂(t) ^ 2 + u(t) ^ 2)) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1073,"pagetitle":"Orbital transfert: consumption minimisation","title":"Orbital transfert: consumption minimisation","ref":"/ctproblems/stable/problems/#OTC","content":" Orbital transfert: consumption minimisation The orbital transfer consumption minimisation problem consists in minimising \\[     \\int_{0}^{tf} \\lVert u(t) \\rVert \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x_1(t) = x_3(t) \\\\\n    \\dot x_2(t) = x_4(t) \\\\\n    \\dot x_3(t) = -\\frac{\\mu*x_1(t)}{r(t)^3} + u_1(t) \\\\\n    \\dot x_4(t) = -\\frac{\\mu*x_2(t)}{r(t)^3} + u_2(t) \\\\\n    \\lVert u(t) \\rVert \\leq \\gamma_{max} \\\\\n    r(t) = \\sqrt{x_1(t)^2 + x_2(t)^2}\\] and the limit conditions \\[    x_1(0) = x_{0,1}, \\quad x_2(0) = x_{0,2}, \\quad x_3(0) = x_{0,3}, \\quad x_4(0) = x_{0,4} \\\\\n    r(tf) = r_f, \\quad x_3(t_f) = -\\sqrt{\\frac{\\mu}{{r_f}^3}}*x_2(t_f), \\quad x_4(t_f) = -\\sqrt{\\frac{\\mu}{{r_f}^3}}*x_1(t_f) \\\\\\] with the constants \\[t_0 = 0 \\\\\nt_f = 20 \\\\\nx0 = [-42272.67, 0, 0, -5796.72] \\\\\nμ      = 5.1658620912*1e12 \\\\\nrf     = 42165 \\\\\nm_0     = 2000 \\\\\nF_{max} = 100 \\\\\nγ_{max}  = \\frac{F_{max}*3600.0^2}{m_0*10^3} \\\\\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:orbital_transfert, :consumption) title           = Orbital transfert - consumption minimisation - ∫ ‖u‖ dt \nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R⁴, state\nu ∈ R², control\nx(t0) == x0, initial_con\n[norm((x(tf))[1:2]) - rf, x₃(tf) + α * x₂(tf), x₄(tf) - α * x₁(tf)] == [0, 0, 0], boundary_con\n0 ≤ norm(u(t)) ≤ 1, u_con\nẋ(t) == A * [(-μ * x₁(t)) / sqrt(x₁(t) ^ 2 + x₂(t) ^ 2) ^ 3; (-μ * x₂(t)) / sqrt(x₁(t) ^ 2 + x₂(t) ^ 2) ^ 3; x₃(t); x₄(t)] + B * u(t)\n∫(norm(u(t))) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1076,"pagetitle":"Orbital transfert: energy minimisation","title":"Orbital transfert: energy minimisation","ref":"/ctproblems/stable/problems/#OTE","content":" Orbital transfert: energy minimisation The energy minimisation orbital transfer problem consists in minimising \\[    0.5\\int_{0}^{tf} {\\lVert u(t) \\rVert}^2 \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x_1(t) = x_3(t) \\\\\n    \\dot x_2(t) = x_4(t) \\\\\n    \\dot x_3(t) = -\\frac{\\mu*x_1(t)}{r(t)^3} + u_1(t) \\\\\n    \\dot x_4(t) = -\\frac{\\mu*x_2(t)}{r(t)^3} + u_2(t) \\\\\n    \\lVert u(t) \\rVert \\leq \\gamma_{max} \\\\\n    r(t) = \\sqrt{x_1(t)^2 + x_2(t)^2}\\] and the limit conditions \\[    x_1(0) = x_{0,1}, \\quad x_2(0) = x_{0,2}, \\quad x_3(0) = x_{0,3}, \\quad x_4(0) = x_{0,4} \\\\\n    r(tf) = r_f, \\quad x_3(t_f) = -\\sqrt{\\frac{\\mu}{{r_f}^3}}*x_2(t_f), \\quad x_4(t_f) = -\\sqrt{\\frac{\\mu}{{r_f}^3}}*x_1(t_f) \\\\\\] with the constants \\[t_0 = 0 \\\\\nt_f = 20 \\\\\nx0 = [-42272.67, 0, 0, -5796.72] \\\\\nμ      = 5.1658620912*1e12 \\\\\nrf     = 42165 \\\\\nm_0     = 2000 \\\\\nF_{max} = 100 \\\\\nγ_{max}  = \\frac{F_{max}*3600.0^2}{m_0*10^3} \\\\\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:orbital_transfert, :energy) title           = Orbital transfert - energy minimisation - min ∫ ‖u‖² dt\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R⁴, state\nu ∈ R², control\nx(t0) == x0, initial_con\n[norm((x(tf))[1:2]) - rf, x₃(tf) + α * x₂(tf), x₄(tf) - α * x₁(tf)] == [0, 0, 0], boundary_con\n0 ≤ norm(u(t)) ≤ 1, u_con\nẋ(t) == A * [(-μ * x₁(t)) / sqrt(x₁(t) ^ 2 + x₂(t) ^ 2) ^ 3; (-μ * x₂(t)) / sqrt(x₁(t) ^ 2 + x₂(t) ^ 2) ^ 3; x₃(t); x₄(t)] + B * u(t)\n∫(0.5 * (u₁(t) ^ 2 + u₂(t) ^ 2)) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1079,"pagetitle":"Orbital transfert: time minimisation","title":"Orbital transfert: time minimisation","ref":"/ctproblems/stable/problems/#OTT","content":" Orbital transfert: time minimisation The time minimisation orbital transfer problem consists in minimising \\[    t_f\\] subject to the constraints \\[    \\dot x_1(t) = x_3(t) \\\\\n    \\dot x_2(t) = x_4(t) \\\\\n    \\dot x_3(t) = -\\frac{\\mu*x_1(t)}{r(t)^3} + u_1(t) \\\\\n    \\dot x_4(t) = -\\frac{\\mu*x_2(t)}{r(t)^3} + u_2(t) \\\\\n    \\lVert u(t) \\rVert \\leq \\gamma_{max} \\\\\n    r(t) = \\sqrt{x_1(t)^2 + x_2(t)^2}\\] and the limit conditions \\[    x_1(0) = x_{0,1}, \\quad x_2(0) = x_{0,2}, \\quad x_3(0) = x_{0,3}, \\quad x_4(0) = x_{0,4} \\\\\n    r(tf) = r_f, \\quad x_3(t_f) = -\\sqrt{\\frac{\\mu}{{r_f}^3}}*x_2(t_f), \\quad x_4(t_f) = -\\sqrt{\\frac{\\mu}{{r_f}^3}}*x_1(t_f) \\\\\\] with the constants \\[t_0 = 0 \\\\\nx0 = [-42272.67, 0, 0, -5796.72] \\\\\nμ      = 5.1658620912*1e12 \\\\\nrf     = 42165 \\\\\nm_0     = 2000 \\\\\nF_{max} = 100 \\\\\nγ_{max}  = \\frac{F_{max}*3600.0^2}{m_0*10^3} \\\\\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:orbital_transfert, :time) title           = Orbital transfert - time minimisation\nmodel    (Type) = OptimalControlModel{Autonomous, NonFixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model tf ∈ R, variable\nt ∈ [t0, tf], time\nx ∈ R⁴, state\nu ∈ R², control\nx(t0) == x0, initial_con\n[norm((x(tf))[1:2]) - rf, x₃(tf) + α * x₂(tf), x₄(tf) - α * x₁(tf)] == [0, 0, 0], boundary_con\n0 ≤ norm(u(t)) ≤ γ_max, u_con\nẋ(t) == A * [(-μ * x₁(t)) / sqrt(x₁(t) ^ 2 + x₂(t) ^ 2) ^ 3; (-μ * x₂(t)) / sqrt(x₁(t) ^ 2 + x₂(t) ^ 2) ^ 3; x₃(t); x₄(t)] + B * u(t)\ntf → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1082,"pagetitle":"Simple exponential: consumption minimisation","title":"Simple exponential: consumption minimisation","ref":"/ctproblems/stable/problems/#SEC","content":" Simple exponential: consumption minimisation The consumption minimisation simple exponential problem consists in minimising \\[    \\int_{0}^{1} |u(t)| \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x(t) = - x(t) + u(t), u(t) \\in [-1,1]\\] and the limit conditions \\[    x(0) = -1, \\quad x(1) = 0.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:exponential, :consumption) title           = simple exponential - conso min\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\n-1 ≤ u(t) ≤ 1, u_con\nẋ(t) == -(x(t)) + u(t)\n∫abs(u(t)) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1085,"pagetitle":"Simple exponential: energy minimisation","title":"Simple exponential: energy minimisation","ref":"/ctproblems/stable/problems/#SEE","content":" Simple exponential: energy minimisation The energy minimisation simple exponential problem consists in minimising \\[    \\frac{1}{2}\\int_{0}^{1} u^2(t) \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x(t) = - x(t) + u(t), u(t) \\in \\mathbb{R}\\] and the limit conditions \\[    x(0) = -1, \\quad x(1) = 0.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:exponential, :energy) title           = simple exponential - energy min\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\nẋ(t) == -(x(t)) + u(t)\n∫(0.5 * u(t) ^ 2) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1088,"pagetitle":"Simple exponential: time minimisation","title":"Simple exponential: time minimisation","ref":"/ctproblems/stable/problems/#SET","content":" Simple exponential: time minimisation The time minimisation simple exponential problem consists in minimising \\[    tf\\] subject to the constraints \\[    \\dot x(t) = - x(t) + u(t), u(t) \\in [-1,1]\\] and the limit conditions \\[    x(0) = -1, \\quad x(1) = 0.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:exponential, :time) title           = simple exponential - time min\nmodel    (Type) = OptimalControlModel{Autonomous, NonFixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model tf ∈ R, variable\nt ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\n-γ ≤ u(t) ≤ γ, u_con\nẋ(t) == -(x(t)) + u(t)\ntf → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1091,"pagetitle":"Simple integrator: energy minimisation","title":"Simple integrator: energy minimisation","ref":"/ctproblems/stable/problems/#SIEM","content":" Simple integrator: energy minimisation The energy minimisation simple integrator problem consists in minimising \\[    \\frac{1}{2}\\int_{0}^{t_f} u^2(t) \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x(t) = u(t),\\] and the limit conditions \\[    x(0) = 0, \\quad c(t_f,x(t_f)) = 0, \\\\\n    c(t_f,x_f) = x_f - t_f - 10, \\text{ free } t_f > 0.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :energy, :free_final_time, :x_dim_1, :u_dim_1, :lagrange) Then, the model is given by prob.model tf ∈ R, variable\nt ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\n(x(tf) - tf) - 10 == 0, boundary_constraint\nẋ(t) == u(t)\n∫(0.5 * u(t) ^ 2) → min\n You can plot the solution. plot(prob.solution)"},{"id":1094,"pagetitle":"Simple integrator: lqr minimisation","title":"Simple integrator: lqr minimisation","ref":"/ctproblems/stable/problems/#SILM","content":" Simple integrator: lqr minimisation The lqr minimisation simple integrator problem consists in minimising \\[    t_f + \\frac{1}{2}\\int_{0}^{t_f} (x^2(t) + u^2(t)) \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x(t) = u(t),\\] and the limit conditions \\[    x(0) = 0, \\quad x(t_f) = x_f, \\text{ free } t_f > 0.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :lqr, :free_final_time, :x_dim_1, :u_dim_1, :bolza) Then, the model is given by prob.model tf ∈ R, variable\nt ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\nẋ(t) == u(t)\ntf + ∫(0.5 * (u(t) ^ 2 + x(t) ^ 2)) → min\n You can plot the solution. plot(prob.solution)"},{"id":1097,"pagetitle":"Simple integrator: constraint minimisation mixed constraint","title":"Simple integrator: constraint minimisation mixed constraint","ref":"/ctproblems/stable/problems/#SICMMC","content":" Simple integrator: constraint minimisation mixed constraint The constraint-min simple integrator problem consists in minimising \\[    -\\int_{0}^{1} u(t) \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x(t) = u(t), u(t) \\in [0,\\infty], \\\\\n    x(t) + u(t) \\in [-\\infty,0]\\] and the limit conditions \\[    x(0) = -1, \\quad x(1) = xf.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :x_dim_1, :u_dim_1, :lagrange, :mixed_constraint) title           = simple integrator - mixed constraint\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\n0 ≤ u(t) ≤ +Inf, u_con\n-Inf ≤ x(t) + u(t) ≤ 0, mixed_con\nẋ(t) == u(t)\n∫(-(u(t))) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1100,"pagetitle":"Simple integrator: state energy minimisation nonsmooth turnpike","title":"Simple integrator: state energy minimisation nonsmooth turnpike","ref":"/ctproblems/stable/problems/#SISE","content":" Simple integrator: state energy minimisation nonsmooth turnpike The state energy minimisation simple integrator problem consists in minimising \\[    \\int_{0}^{2} x(t)^2 \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x(t) = u(t), u(t) \\in [0,\\gamma], \\\\\\] and the limit conditions \\[    x(0) = 1, \\quad x(2) = 0.5.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:turnpike, :integrator, :state_energy, :x_dim_1, :u_dim_1, :lagrange, :u_cons, :singular_arc) title           = simple nonsmooth turnpike - state energy min - affine system in u\nmodel    (Type) = OptimalControlModel{Autonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\nx(tf) == xf, final_con\n-1 ≤ u(t) ≤ 1, u_con\nẋ(t) == u(t)\n∫(x(t) ^ 2) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"},{"id":1103,"pagetitle":"Simple integrator: constraint minimisation state and control constraint non autonomous","title":"Simple integrator: constraint minimisation state and control constraint non autonomous","ref":"/ctproblems/stable/problems/#SINA","content":" Simple integrator: constraint minimisation state and control constraint non autonomous The constraint minimisation simple integrator problem consists in minimising \\[    \\int_{0}^{3} e^{-α*t}*u(t) \\, \\mathrm{d}t\\] subject to the constraints \\[    \\dot x(t) = u(t), u(t) \\in [0,3], \\\\\n    1 - x(t) - (t-1)^2 \\in [-\\infty,0]\\] and the limit conditions \\[    x(0) = 0, \\quad x(1) = xf.\\] You can access the problem in the CTProblems package: using CTProblems\nprob = Problem(:integrator, :state_dime_1, :lagrange, :x_cons, :u_cons, :nonautonomous) title           = simple integrator - state and control constraints - nonautonomous\nmodel    (Type) = OptimalControlModel{NonAutonomous, Fixed}\nsolution (Type) = OptimalControlSolution Then, the model is given by prob.model t ∈ [t0, tf], time\nx ∈ R, state\nu ∈ R, control\nx(t0) == x0, initial_con\n0 ≤ u(t) ≤ 3, u_con\n-Inf ≤ (1 - x(t)) - (t - 2) ^ 2 ≤ 0, x_con\nẋ(t) == u(t)\n∫(exp(-α * t) * u(t)) → min\n You can plot the solution. plot(prob.solution, size=(700, 400))"}]